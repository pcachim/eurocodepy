{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This site contains the project documentation for the eurocodepy project that is a python package for using Eurocodes. Its aim is to give you a framework to build your project documentation using Python, MkDocs, mkdocstrings, and the Material for MkDocs theme.</p> <p>Eurocodepy are Python functions to work with structural eurocodes. Material data is stored in a JSON file. Current materials in the database are:</p> <p>urrent materials in the database are:</p> <ul> <li>concrete (C20 to C90)</li> <li>timber (C, D, GL)</li> <li>reinforcement (B400, B500, A400, A500)</li> <li>structural steel (S235, S275, S355, S450)</li> </ul> <p>Available european steel profiles are:</p> <ul> <li>IPE</li> <li>HEA</li> <li>HEB</li> <li>HEM</li> <li>L</li> <li>C</li> <li>T</li> <li>Pipe</li> <li>Box</li> <li>Double L</li> <li>Double C</li> </ul> <p>There are also some functions to work with material properties:</p> <ul> <li>creep_coef</li> <li>shrink_strain</li> </ul> <p>The existing functions are listed in the page 'Reference'. They are divided by eurocode.</p>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<p>The documentation follows the best practice for project documentation as described by Daniele Procida in the Di\u00e1taxis documentation framework and consists of four separate parts:</p> <ol> <li>Tutorials</li> <li>How-To Guides</li> <li>Reference</li> <li>Explanation</li> <li>License</li> </ol> <p>Quickly find what you're looking for depending on your use case by looking at the different pages.</p>"},{"location":"#projet-overview","title":"Projet overview","text":"<p>Provide several functions to help designers working with Eurocodes.</p> <p>This module allows the user to make mathematical calculations.</p> <p>The module contains the following functions:</p> <p><code>db</code>: Returns the database of the Eurocodes. <code>ec1</code>: Returns functions for ec1 calculations. <code>ec2</code>: Returns functions for ec2 calculations. <code>ec3</code>: Returns functions for ec3 calculations. <code>ec5</code>: Returns functions for ec5 calculations. <code>ec7</code>: Returns functions for ec7 calculations. <code>ec8</code>: Returns functions for ec8 calculations.</p>"},{"location":"#eurocodepy.get_national_params","title":"<code>get_national_params(local=locale.PT, concelho='Lisboa')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>locale</code> <code>str</code> <p>description. Defaults to \"PT\".</p> required <code>concelho</code> <code>str</code> <p>description. Defaults to \"Lisboa\".</p> <code>'Lisboa'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>description</p> Source code in <code>eurocodepy/__init__.py</code> <pre><code>def get_national_params(local: locale = locale.PT, concelho: str = \"Lisboa\") -&gt; dict:\n    \"\"\"\n\n    Args:\n        locale (str, optional): _description_. Defaults to \"PT\".\n        concelho (str, optional): _description_. Defaults to \"Lisboa\".\n\n    Returns:\n        dict: _description_\n    \"\"\"\n    pt_data = locale[local.name]\n    row = pt_data[pt_data['Concelho'] == concelho]\n    # Convert to dict if found\n    if not row.empty:\n        result = row.iloc[0].to_dict()\n        print(result)\n    else:\n        result = None\n        print(\"Concelho not found.\")\n    return result\n</code></pre>"},{"location":"#support","title":"Support","text":"<p>If you need any help you can contact the developer via email.</p> <p>Github: [http://github.com/pcachim/eurocodepy]</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>I want to thank my house plants for providing me with a negligible amount of oxygen each day. Also, I want to thank the sun for providing more than half of their nourishment free of charge.</p>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at [INSERT EMAIL ADDRESS]. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project contributors who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p>"},{"location":"STYLE_GUIDE/","title":"Python Style Guide","text":"<p>This document outlines the guidelines for writing Python code for our project. Following these guidelines helps ensure that the code is consistent and easy to read.</p>"},{"location":"STYLE_GUIDE/#code-formatting","title":"Code Formatting","text":"<ul> <li>Use 4 spaces for indentation.</li> <li>Use a space after the # for inline comments.</li> <li>Use blank lines to separate logical sections of code.</li> </ul> <pre><code>if x &gt; 0:\n    print('x is positive')\nelse:\n    print('x is non-positive')\n\n# This is an inline comment.\n\ndef function_name(parameter):\n    # Code inside function.\n</code></pre>"},{"location":"STYLE_GUIDE/#naming-conventions","title":"Naming Conventions","text":""},{"location":"STYLE_GUIDE/#variables","title":"Variables","text":"<ul> <li>Use descriptive names that accurately reflect the purpose of the variable.</li> <li>Use snake_case for variable names.</li> </ul> <pre><code>number_of_items = 5\ntotal_price = 10.50\n</code></pre>"},{"location":"STYLE_GUIDE/#functions","title":"Functions","text":"<ul> <li>Use descriptive names that accurately reflect the purpose of the function.</li> <li>Use snake_case for function names.</li> </ul> <pre><code>def calculate_total_price(quantity, price):\n    return quantity * price\n````\n\n### Classes\n\n- Use PascalCase for class names.\n\n```python\nclass User:\n    # ...\n````\n\n### File Names\n\n- Use snake_case for file names.\n\n```text\nmain_script.py\nuser_profile.py\n</code></pre>"},{"location":"STYLE_GUIDE/#comments","title":"Comments","text":"<ul> <li>Use comments to explain non-obvious or complex code.</li> <li>Use complete sentences and proper grammar.</li> <li>Begin comments with a capital letter.</li> <li>Use one space after the # for inline comments.</li> <li>Use multi-line comments for longer explanations.</li> </ul> <pre><code># Add the value to the list.\nmy_list.append(value)\n\n\"\"\"\nThis function takes two parameters:\n- name: a string representing the name of the user\n- age: an integer representing the age of the user\n\nIt returns a greeting message.\n\"\"\"\ndef greet(name, age):\n    # ...\n</code></pre>"},{"location":"STYLE_GUIDE/#miscellaneous","title":"Miscellaneous","text":"<ul> <li>Use double quotes for strings.</li> <li>Use parentheses for tuple packing and unpacking.</li> <li>Always use is or is not to compare with None.</li> <li>Use a blank line before and after a return statement.</li> <li>Use None instead of '' or [] for default values of function arguments.</li> </ul> <p>```python message = \"Hello, world!\" print(message)</p> <p>a, b, c = (1, 2, 3)</p> <p>if x is None:     # ...</p> <p>def my_function(arg1, arg2=None):     # ...</p> <p>def my_other_function(arg1, arg2=[]):     # This is bad.</p> <p>def my_good_function(arg1, arg2=None):     if arg2 is None:         arg2 = []     # ... ````</p>"},{"location":"STYLE_GUIDE/#resources","title":"Resources","text":"<p>PEP 8 -- Style Guide for Python Code\\ Google Python Style Guide\\ Python Code Style: A Guide to Writing Readable Code</p>"},{"location":"copyright/","title":"Contributing Guidelines and Copyright Notice","text":""},{"location":"copyright/#contributing-guidelines","title":"Contributing Guidelines","text":"<p>We welcome contributions from everyone. Please read these guidelines before submitting a pull request or issue.</p>"},{"location":"copyright/#code-of-conduct","title":"Code of Conduct","text":"<p>We expect all contributors to adhere to our Code of Conduct. Please read it before contributing.</p>"},{"location":"copyright/#issues","title":"Issues","text":"<p>If you find a bug or have a feature request, please submit an issue on our GitHub issue tracker. Please check the existing issues to make sure your issue hasn't already been reported.</p> <p>When submitting an issue, please provide as much detail as possible, including steps to reproduce the issue if applicable.</p>"},{"location":"copyright/#pull-requests","title":"Pull Requests","text":"<p>We welcome pull requests from everyone. Please ensure that your PR adheres to the following guidelines:</p> <ol> <li>Before submitting a PR, please create an issue first and wait for approval from a project maintainer.</li> <li>Your code should follow our style guide.</li> <li>Write tests for any new functionality.</li> <li>Ensure that all tests pass before submitting your pull request.</li> <li>Include documentation for any new functionality you've added.</li> <li>Make sure your code has no linter errors or warnings.</li> <li>Be sure to explain what your changes do and why they are necessary.</li> </ol>"},{"location":"copyright/#getting-started","title":"Getting Started","text":"<p>To get started with contributing, take a look at the issues on our GitHub issue tracker. If you have any questions or need any help, please don't hesitate to reach out to us on Slack.</p> <p>Thank you for contributing to our project!</p>"},{"location":"copyright/#copyright-notice","title":"Copyright Notice","text":"<p>Copyright (c) 2025 Paulo Cachim</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"explanation/","title":"Background","text":"<p>This part of the project documentation focuses on an understanding-oriented approach. You'll get a chance to read about the background of the project, as well as reasoning about how it was implemented.</p> <p>Note: Expand this section by considering the following points:</p> <ul> <li>Give context and background on your library</li> <li>Explain why you created it</li> <li>Provide multiple examples and approaches of how     to work with it</li> <li>Help the reader make connections</li> <li>Avoid writing instructions or technical descriptions     here</li> </ul>"},{"location":"how-to-guides/","title":"How to guides","text":"<p>This part of the project documentation focuses on a problem-oriented approach. You'll tackle common tasks that you might have, with the help of the code provided in this project.</p>"},{"location":"how-to-guides/#how-to-add-two-numbers","title":"How To Add Two Numbers?","text":"<p>You have two numbers and you need to add them together. You're in luck! The <code>calculator</code> package can help you get this done.</p> <p>Download the code from this GitHub repository and place the <code>calculator/</code> folder in the same directory as your Python script:</p> <pre><code>your_project/\n\u2502\n\u251c\u2500\u2500 calculator/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 calculations.py\n\u2502\n\u2514\u2500\u2500 your_script.py\n</code></pre> <p>Inside of <code>your_script.py</code> you can now import the <code>add()</code> function from the <code>calculator.calculations</code> module:</p> <pre><code># your_script.py\nfrom calculator.calculations import add\n</code></pre> <p>After you've imported the function, you can use it to add any two numbers that you need to add:</p> <pre><code># your_script.py\nfrom calculator.calculations import add\n\nprint(add(20, 22))  # OUTPUT: 42.0\n</code></pre> <p>You're now able to add any two numbers, and you'll always get a <code>float</code> as a result.</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>This part of the project documentation focuses on a learning-oriented approach. You'll learn how to get started with the code in this project.</p> <p>Note: Expand this section by considering the following points:</p> <ul> <li>Help newcomers with getting started</li> <li>Teach readers about your library by making them     write code</li> <li>Inspire confidence through examples that work for     everyone, repeatably</li> <li>Give readers an immediate sense of achievement</li> <li>Show concrete examples, no abstractions</li> <li>Provide the minimum necessary explanation</li> <li>Avoid any distractions</li> </ul>"},{"location":"tutorials/#tutorial-1","title":"Tutorial 1","text":"<p>Tutorial 1</p>"},{"location":"tutorials/#tutorial-2","title":"Tutorial 2","text":"<p>Tutorial 2</p>"},{"location":"modules/ec1/","title":"Eurocode 7: ec7 module","text":""},{"location":"modules/ec1/#overview","title":"Overview","text":"<p>Welcome to the ec7 module off eurocodepy package. This module is a toolkit designed to assist engineers and geotechnical professionals in calculating and analyzing earth pressure coefficients and soil bearing capacity based on the Eurocode 7 (EC7) standards.</p>"},{"location":"modules/ec1/#features","title":"Features","text":"<ol> <li>Active Earth Pressure Analysis Perform active earth pressure calculations according to Eurocode 7 standards. Input parameters include soil properties, wall geometry, and external loads. Output results include the magnitude and distribution of active earth pressure on the retaining structure.</li> <li>Soil Bearing Capacity Analysis Calculate soil bearing capacity based on the Eurocode 7 guidelines. Input parameters include soil properties, foundation geometry, and relevant loadings. Output results include the ultimate and allowable bearing capacities for shallow foundations.</li> <li>Compliance with Eurocode 7 The package adheres to the Eurocode 7 standards, ensuring accurate and reliable calculations. Regular updates will be provided to align with any changes or amendments to the Eurocode 7 specifications. Installation</li> </ol>"},{"location":"modules/ec1/#usage","title":"Usage","text":"<p>Import the eurocodepy package  Initialize the active earth pressure or soil bearing capacity calculation objects. Set the input parameters such as soil properties, wall/foundation geometry, and loads. Run the calculation method to obtain the results. Access the output data and analyze the results.</p> <pre><code># Import the EC7Package module\nfrom eurocodepy.ec7 import pressure_coefficients, bearing_resistance \n\n# Example for Active Earth Pressure\nactive_pressure_calculator = ActiveEarthPressure()\nactive_pressure_calculator.set_soil_properties(...)\nactive_pressure_calculator.set_wall_geometry(...)\nactive_pressure_calculator.set_external_loads(...)\nactive_pressure_calculator.calculate_active_pressure()\nresults = active_pressure_calculator.get_results()\n\n# Example for Soil Bearing Capacity\nbearing_capacity_calculator = SoilBearingCapacity()\nbearing_capacity_calculator.set_soil_properties(...)\nbearing_capacity_calculator.set_foundation_geometry(...)\nbearing_capacity_calculator.set_loadings(...)\nbearing_capacity_calculator.calculate_bearing_capacity()\nresults = bearing_capacity_calculator.get_results()\nContribution Guidelines\n</code></pre>"},{"location":"modules/ec7/","title":"Eurocode 7: ec7 module","text":""},{"location":"modules/ec7/#overview","title":"Overview","text":"<p>Welcome to the ec7 module off eurocodepy package. This module is a toolkit designed to assist engineers and geotechnical professionals in calculating and analyzing earth pressure coefficients and soil bearing capacity based on the Eurocode 7 (EC7) standards.</p>"},{"location":"modules/ec7/#features","title":"Features","text":"<ol> <li>Active Earth Pressure Analysis Perform active earth pressure calculations according to Eurocode 7 standards. Input parameters include soil properties, wall geometry, and external loads. Output results include the magnitude and distribution of active earth pressure on the retaining structure.</li> <li>Soil Bearing Capacity Analysis Calculate soil bearing capacity based on the Eurocode 7 guidelines. Input parameters include soil properties, foundation geometry, and relevant loadings. Output results include the ultimate and allowable bearing capacities for shallow foundations.</li> <li>Compliance with Eurocode 7 The package adheres to the Eurocode 7 standards, ensuring accurate and reliable calculations. Regular updates will be provided to align with any changes or amendments to the Eurocode 7 specifications. Installation</li> </ol>"},{"location":"modules/ec7/#usage","title":"Usage","text":"<p>Import the eurocodepy package  Initialize the active earth pressure or soil bearing capacity calculation objects. Set the input parameters such as soil properties, wall/foundation geometry, and loads. Run the calculation method to obtain the results. Access the output data and analyze the results.</p> <pre><code># Import the EC7Package module\nfrom eurocodepy.ec7 import pressure_coefficients, bearing_resistance \n\n# Example for Active Earth Pressure\nactive_pressure_calculator = ActiveEarthPressure()\nactive_pressure_calculator.set_soil_properties(...)\nactive_pressure_calculator.set_wall_geometry(...)\nactive_pressure_calculator.set_external_loads(...)\nactive_pressure_calculator.calculate_active_pressure()\nresults = active_pressure_calculator.get_results()\n\n# Example for Soil Bearing Capacity\nbearing_capacity_calculator = SoilBearingCapacity()\nbearing_capacity_calculator.set_soil_properties(...)\nbearing_capacity_calculator.set_foundation_geometry(...)\nbearing_capacity_calculator.set_loadings(...)\nbearing_capacity_calculator.calculate_bearing_capacity()\nresults = bearing_capacity_calculator.get_results()\nContribution Guidelines\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>eurocodepy<ul> <li>db</li> <li>ec1<ul> <li>snow</li> <li>wind<ul> <li>pressure</li> </ul> </li> </ul> </li> <li>ec2<ul> <li>crack</li> <li>fire<ul> <li>fire_base</li> </ul> </li> <li>material</li> <li>sls<ul> <li>creep</li> <li>shrinkage</li> </ul> </li> <li>uls<ul> <li>beam</li> <li>bend_circ</li> <li>shear</li> <li>shell</li> </ul> </li> </ul> </li> <li>ec3</li> <li>ec5<ul> <li>sls<ul> <li>deformation</li> <li>vibration</li> </ul> </li> </ul> </li> <li>ec7<ul> <li>bearing_capacity</li> <li>earth_pressures</li> <li>retaining_wall</li> </ul> </li> <li>ec8<ul> <li>spectrum</li> </ul> </li> <li>params</li> <li>utils<ul> <li>dict_tools</li> <li>plotly_templates</li> <li>section_properties</li> <li>stress</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/eurocodepy/","title":"eurocodepy","text":"<p>Provide several functions to help designers working with Eurocodes.</p> <p>This module allows the user to make mathematical calculations.</p> <p>The module contains the following functions:</p> <p><code>db</code>: Returns the database of the Eurocodes. <code>ec1</code>: Returns functions for ec1 calculations. <code>ec2</code>: Returns functions for ec2 calculations. <code>ec3</code>: Returns functions for ec3 calculations. <code>ec5</code>: Returns functions for ec5 calculations. <code>ec7</code>: Returns functions for ec7 calculations. <code>ec8</code>: Returns functions for ec8 calculations.</p>"},{"location":"reference/eurocodepy/#eurocodepy.get_national_params","title":"<code>get_national_params(local=locale.PT, concelho='Lisboa')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>locale</code> <code>str</code> <p>description. Defaults to \"PT\".</p> required <code>concelho</code> <code>str</code> <p>description. Defaults to \"Lisboa\".</p> <code>'Lisboa'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>description</p> Source code in <code>eurocodepy/__init__.py</code> <pre><code>def get_national_params(local: locale = locale.PT, concelho: str = \"Lisboa\") -&gt; dict:\n    \"\"\"\n\n    Args:\n        locale (str, optional): _description_. Defaults to \"PT\".\n        concelho (str, optional): _description_. Defaults to \"Lisboa\".\n\n    Returns:\n        dict: _description_\n    \"\"\"\n    pt_data = locale[local.name]\n    row = pt_data[pt_data['Concelho'] == concelho]\n    # Convert to dict if found\n    if not row.empty:\n        result = row.iloc[0].to_dict()\n        print(result)\n    else:\n        result = None\n        print(\"Concelho not found.\")\n    return result\n</code></pre>"},{"location":"reference/eurocodepy/db/","title":"db","text":""},{"location":"reference/eurocodepy/db/#eurocodepy.db.dict2obj","title":"<code>dict2obj(dict1)</code>","text":"<p>Converts a dictionary to a custom object using json.loads and object_hook.</p> <p>Parameters:</p> Name Type Description Default <code>dict1</code> <p>The input dictionary.</p> required <p>Returns:</p> Type Description <p>A custom object representing the dictionary.</p> Source code in <code>eurocodepy/db.py</code> <pre><code>def dict2obj(dict1):\n    \"\"\"\n    Converts a dictionary to a custom object using json.loads and object_hook.\n\n    Args:\n        dict1: The input dictionary.\n\n    Returns:\n        A custom object representing the dictionary.\n    \"\"\"\n\n    class obj:\n        \"\"\"\n        Custom object class used as the object_hook.\n        \"\"\"\n        def __init__(self, dict1):\n            \"\"\"\n            Constructor that updates the object's __dict__ with the dictionary.\n            \"\"\"\n            self.__dict__.update(dict1)\n\n    return json.loads(json.dumps(dict1), object_hook=obj)\n</code></pre>"},{"location":"reference/eurocodepy/db/#eurocodepy.db.wind_get_params","title":"<code>wind_get_params(code='PT', zone='ZonaA', terrain='II')</code>","text":"<p>Returns the wind parameters for the specified code.</p> Source code in <code>eurocodepy/db.py</code> <pre><code>def wind_get_params(code: str = \"PT\", zone: str=\"ZonaA\", terrain: str = \"II\") -&gt; tuple:\n    \"\"\"Returns the wind parameters for the specified code.\"\"\"\n    wind = WindLoads[\"locale\"][code]\n    vb0 = wind[\"base_velocity\"][zone][\"vb0\"]\n    z0 = wind[\"terrain\"][terrain][\"z0\"]\n    zmin = wind[\"terrain\"][terrain][\"zmin\"]\n    return vb0, zmin, z0\n</code></pre>"},{"location":"reference/eurocodepy/params/","title":"params","text":""},{"location":"reference/eurocodepy/params/#eurocodepy.params.seismic_get_params","title":"<code>seismic_get_params(code, seismic_type, soil_type, importance_class)</code>","text":"<p>Gets the seismic spectrum parameters for a given code, seismic type, soil type, and importance class. This function retrieves the seismic spectrum parameters from the SeismicLoads database based on the provided parameters. It returns a dictionary containing the spectrum parameters, including the importance coefficient. The parameters are case-insensitive for soil type and importance class, but the seismic type should be provided in uppercase. The function is designed to work with different localization codes, such as \"PT\" for Portugal or \"EU\" for standard CEN. The seismic types can include \"PT1\", \"PT2\", \"PTA\" for Portugal, or \"CEN-1\", \"CEN-2\" for CEN standards. This function is useful for engineers and designers who need to apply seismic loads according to Eurocode standards. Args:     code (str): Localization code (e.g., \"PT\" for Portugal, \"EU\" for standard CEN).     seismic_type (str): type of seismic action (e.g., \"PT1\", \"PT2\", \"PTA\", \"CEN-1\", \"CEN-2\").     soil_type (str): soil type (e.g., \"A\", \"B\", \"C\", \"D\", \"E\" for different soil conditions).      importance_class (str): importance class (e.g., \"i\", \"ii\", \"iii\", \"iv\").</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>spectrum parameters for the specified code, seismic type, soil type, and importance class.</p> Source code in <code>eurocodepy/params.py</code> <pre><code>def seismic_get_params(code, seismic_type, soil_type, importance_class) -&gt; dict:\n    \"\"\"Gets the seismic spectrum parameters for a given code, seismic type, soil type, and importance class.\n    This function retrieves the seismic spectrum parameters from the SeismicLoads database based on the provided parameters.\n    It returns a dictionary containing the spectrum parameters, including the importance coefficient.\n    The parameters are case-insensitive for soil type and importance class, but the seismic type should be provided in uppercase.\n    The function is designed to work with different localization codes, such as \"PT\" for Portugal or \"EU\" for standard CEN.\n    The seismic types can include \"PT1\", \"PT2\", \"PTA\" for Portugal, or \"CEN-1\", \"CEN-2\" for CEN standards.\n    This function is useful for engineers and designers who need to apply seismic loads according to Eurocode standards.\n    Args:\n        code (str): Localization code (e.g., \"PT\" for Portugal, \"EU\" for standard CEN).\n        seismic_type (str): type of seismic action (e.g., \"PT1\", \"PT2\", \"PTA\", \"CEN-1\", \"CEN-2\").\n        soil_type (str): soil type (e.g., \"A\", \"B\", \"C\", \"D\", \"E\" for different soil conditions).   \n        importance_class (str): importance class (e.g., \"i\", \"ii\", \"iii\", \"iv\").\n\n    Returns:\n        dict: spectrum parameters for the specified code, seismic type, soil type, and importance class.\n    \"\"\"\n    code = str.upper(code)\n    seismic_type = str.upper(seismic_type)\n    soil_type = str.upper(soil_type)\n    importance_class = str.lower(importance_class)\n    if code not in SeismicLoads[\"Locale\"]:\n        raise ValueError(f\"Invalid code: {code}. Available codes: {list(SeismicLoads['Locale'].keys())}\")\n    if seismic_type not in SeismicLoads[\"Locale\"][code][\"Spectrum\"]:\n        raise ValueError(f\"Invalid seismic type: {seismic_type}. Available types: {list(SeismicLoads['Locale'][code]['Spectrum'].keys())}\")\n    if soil_type not in SeismicLoads[\"Locale\"][code][\"Spectrum\"][seismic_type]:\n        raise ValueError(f\"Invalid soil type: {soil_type}. Available types: {list(SeismicLoads['Locale'][code]['Spectrum'][seismic_type].keys())}\")\n    if importance_class not in SeismicLoads[\"Locale\"][code][\"ImportanceClass\"]:\n        raise ValueError(f\"Invalid importance class: {importance_class}. Available classes: {list(SeismicLoads['Locale'][code]['ImportanceCoef'].keys())}\")\n\n    # Retrieve the spectrum parameters\n    spectrum = SeismicLoads[\"Locale\"][code][\"Spectrum\"][seismic_type][str.upper(soil_type)]\n    spectrum[\"ImportanceCoef\"] = SeismicLoads[\"Locale\"][code][\"ImportanceCoef\"][seismic_type][importance_class]\n    return spectrum\n</code></pre>"},{"location":"reference/eurocodepy/params/#eurocodepy.params.wind_get_params","title":"<code>wind_get_params(code='PT', zone='ZonaA', terrain='II')</code>","text":"<p>Gets the wind load parameters for a given code, zone, and terrain. This function retrieves the wind load parameters from the WindLoads database based on the provided parameters. It returns a tuple containing the base velocity, minimum height, roughness length, and roughness length for terrain II. The parameters are case-insensitive for the zone and terrain, but the code should be provided in uppercase. The function is designed to work with different localization codes, such as \"PT\" for Portugal or \"EU\" for standard CEN. The zones can include \"ZonaA\", \"ZonaB\", etc., and the terrain types can include \"I\", \"II\", \"III\", etc. This function is useful for engineers and designers who need to apply wind loads according to Eurocode standards.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Localization code. Defaults to \"PT\".</p> <code>'PT'</code> <code>zone</code> <code>str</code> <p>Wind zone. Defaults to \"ZonaA\" for Portugal.</p> <code>'ZonaA'</code> <code>terrain</code> <code>str</code> <p>terrain type. Defaults to \"II\".</p> <code>'II'</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>wind load parameters for the specified code, zone, and terrain.</p> <code>tuple</code> <p>The tuple contains: - vb0 (float): base velocity for the specified zone. - zmin (float): minimum height for the specified terrain. - z0 (float): roughness length for the specified terrain. - z0II (float): roughness length for terrain II.</p> Source code in <code>eurocodepy/params.py</code> <pre><code>def wind_get_params(code: str = \"PT\", zone: str=\"ZonaA\", terrain: str = \"II\") -&gt; tuple:\n    \"\"\"Gets the wind load parameters for a given code, zone, and terrain.\n    This function retrieves the wind load parameters from the WindLoads database based on the provided parameters.\n    It returns a tuple containing the base velocity, minimum height, roughness length, and roughness length for terrain II.\n    The parameters are case-insensitive for the zone and terrain, but the code should be provided in uppercase.\n    The function is designed to work with different localization codes, such as \"PT\" for Portugal or \"EU\" for standard CEN.\n    The zones can include \"ZonaA\", \"ZonaB\", etc., and the terrain types can include \"I\", \"II\", \"III\", etc.\n    This function is useful for engineers and designers who need to apply wind loads according to Eurocode standards.\n\n    Args:\n        code (str, optional): Localization code. Defaults to \"PT\".\n        zone (str, optional): Wind zone. Defaults to \"ZonaA\" for Portugal.\n        terrain (str, optional): terrain type. Defaults to \"II\".\n\n    Returns:\n        tuple: wind load parameters for the specified code, zone, and terrain.\n        The tuple contains:\n            - vb0 (float): base velocity for the specified zone.\n            - zmin (float): minimum height for the specified terrain.\n            - z0 (float): roughness length for the specified terrain.\n            - z0II (float): roughness length for terrain II.\n    \"\"\"\n    terrain = str.upper(terrain)\n    code = str.upper(code)\n\n    wind = WindLoads[\"locale\"][code]\n    vb0 = wind[\"base_velocity\"][zone][\"vb0\"]\n    z0 = wind[\"terrain\"][terrain][\"z0\"]\n    z0II = wind[\"terrain\"][\"II\"][\"z0\"]\n    zmin = wind[\"terrain\"][terrain][\"zmin\"]\n    return vb0, zmin, z0, z0II\n</code></pre>"},{"location":"reference/eurocodepy/ec1/","title":"ec1","text":""},{"location":"reference/eurocodepy/ec1/snow/","title":"snow","text":""},{"location":"reference/eurocodepy/ec1/wind/","title":"wind","text":""},{"location":"reference/eurocodepy/ec1/wind/#eurocodepy.ec1.wind.I_v","title":"<code>I_v(z, z_min, z_0, co, k_I=1)</code>","text":"<p>Calculates the turbulence intensity, Iv(z), at height z. It is defined as the standard deviation of the turbulence divided by the mean wind velocity.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance</p> required <code>z_min</code> <code>float</code> <p>minimum height.</p> required <code>z_0</code> <code>float</code> <p>roughness length.</p> required <code>co</code> <code>float</code> <p>orography factor.</p> required <code>k_I</code> <code>float</code> <p>turbulence intensity factor. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>turbulence intensity</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def I_v(z: float, z_min: float, z_0: float, co: float, k_I:float=1) -&gt; float:\n    \"\"\"Calculates the turbulence intensity, Iv(z), at height z.\n    It is defined as the standard deviation of the turbulence divided by the mean wind velocity.\n\n    Args:\n        z (float): vertical distance\n        z_min (float, optional): minimum height.\n        z_0 (float, optional): roughness length.\n        co (float): orography factor.\n        k_I (float, optional): turbulence intensity factor. Defaults to 1.\n\n    Returns:\n        float: turbulence intensity\n    \"\"\"\n    zeff = z if z &gt;= z_min else z_min\n    Iv = k_I / co / log(zeff/z_0)\n    return Iv\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/#eurocodepy.ec1.wind.c_o","title":"<code>c_o(z, x=0, H=0, Lu=10, Ld=1000)</code>","text":"<p>Calculates the orography factor. Args:     z (float): vertical distance     x (float, optional): horizontal distance. Defaults to 0.     H (float, optional): height of the hill/cliff. Defaults to 0.     Lu (float, optional): length of the hill/cliff. Defaults to 10.     Ld (float, optional): length of the cliff. Defaults to 1000, meaning it's a cliff.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>orography factor</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def c_o(z: float, x: float=0, H: float=0, Lu: float=10, Ld: float=1000) -&gt; float:\n    \"\"\"Calculates the orography factor.\n    Args:\n        z (float): vertical distance\n        x (float, optional): horizontal distance. Defaults to 0.\n        H (float, optional): height of the hill/cliff. Defaults to 0.\n        Lu (float, optional): length of the hill/cliff. Defaults to 10.\n        Ld (float, optional): length of the cliff. Defaults to 1000, meaning it's a cliff.\n\n    Returns:\n        float: orography factor\n    \"\"\"\n    phi = H/Lu\n    if phi &lt; 0.05: return 1.0\n    s = s_coef(x, z, H, Lu, Ld)\n    return 1.0+2.0*s*phi if phi &lt; 0.3 else 1.0+0.6*s\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/#eurocodepy.ec1.wind.c_r","title":"<code>c_r(z, z_min, z_0, z_0II)</code>","text":"<p>Calculate the roughness factor</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance.</p> required <code>z_min</code> <code>float</code> <p>minimum height.</p> required <code>z_0</code> <code>float</code> <p>roughness length.</p> required <code>z_OII</code> <code>float</code> <p>roughness length for terrain II.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the roughness factor</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def c_r(z: float, z_min: float, z_0: float, z_0II: float) -&gt; float:\n    \"\"\" Calculate the roughness factor\n\n    Args:\n        z (float): vertical distance.\n        z_min (float, optional): minimum height.\n        z_0 (float, optional): roughness length.\n        z_OII (float, optional): roughness length for terrain II.\n\n    Returns:\n        float: the roughness factor\n    \"\"\"\n    k_r = 0.19*((z_0/z_0II)**0.07)\n    zeff = z if z &gt;= z_min else z_min\n    return k_r * log(zeff/z_0)\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/#eurocodepy.ec1.wind.q_p","title":"<code>q_p(z, vb, z_min, z_0, cr, co, rho=1.25, k_I=1)</code>","text":"<p>Calculates the peak velocity pressure, qp(z), at height z,  which includes mean and short-term velocity fluctuations.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance.</p> required <code>vb</code> <code>float</code> <p>fundamental value of the basic wind velocity.</p> required <code>z_min</code> <code>float</code> <p>minimum height.</p> required <code>z_0</code> <code>float</code> <p>roughness length.</p> required <code>cr</code> <code>float</code> <p>terrain roughness factor.</p> required <code>co</code> <code>float</code> <p>orography factor.</p> required <code>rho</code> <code>float</code> <p>air density. Defaults to 1.25 kg/m3.</p> <code>1.25</code> <code>k_I</code> <code>float</code> <p>turbulence intensity factor. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>peak velocity pressure</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def q_p(z: float, vb: float, z_min: float, z_0: float, cr: float, co: float, rho: float=1.25, k_I:float=1) -&gt; float:\n    \"\"\"Calculates the peak velocity pressure, qp(z), at height z, \n    which includes mean and short-term velocity fluctuations.\n\n    Args:\n        z (float): vertical distance.\n        vb (float): fundamental value of the basic wind velocity.\n        z_min (float, optional): minimum height.\n        z_0 (float, optional): roughness length.\n        cr (float): terrain roughness factor.\n        co (float): orography factor.\n        rho (float, optional): air density. Defaults to 1.25 kg/m3.\n        k_I (float, optional): turbulence intensity factor. Defaults to 1.\n\n    Returns:\n        float: peak velocity pressure\n    \"\"\"\n    v = cr * co * vb\n    zeff = z if z &gt;= z_min else z_min\n    Iv = k_I / co / log(zeff/z_0)\n    qp = 0.5 * (1.0 + 7*Iv) * v**2 * rho\n    return qp\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/#eurocodepy.ec1.wind.s_coef","title":"<code>s_coef(x, z, H, Lu, Ld=1000)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>horizontal distance</p> required <code>z</code> <code>float</code> <p>vertical distance</p> required <code>H</code> <code>float</code> <p>height of the hill/cliff</p> required <code>Lu</code> <code>float</code> <p>length of the hill/cliff</p> required <code>Ld</code> <code>float</code> <p>length of the cliff. Defaults to 1000, meaning it's a cliff.</p> <code>1000</code> <p>Returns:     float: description</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def s_coef(x: float, z: float, H: float, Lu: float, Ld: float=1000) -&gt; float:\n    \"\"\"_summary_\n\n    Args:\n        x (float): horizontal distance\n        z (float): vertical distance\n        H (float): height of the hill/cliff\n        Lu (float): length of the hill/cliff\n        Ld (float, optional): length of the cliff. Defaults to 1000, meaning it's a cliff.\n    Returns:\n        float: _description_\n    \"\"\"\n    phi0 = H/Ld\n    phi = H/Lu\n\n    if phi &lt; 0.05: return 0.0\n    orography_type = 'hill' if phi0 &gt; 0.05 else 'cliff'\n\n    Le = H/0.3 if phi &gt;= 0.3 else Lu\n    x_Lu = x/Lu\n    z_Le = z/Le\n\n    s = 0.0\n    if x_Lu &lt;= 0:\n        if -1.5 &lt; x_Lu and z_Le &lt; 2:\n            A = 0.1552*z_Le**4 -0.8575*z_Le**3 +1.8133*z_Le**2 -1.9115*z_Le +1.0124\n            B = 0.3542*z_Le**2 -1.0577*z_Le+2.6456\n            s = A*exp(B*x_Lu)\n        elif x_Lu &lt; -1.5 or z_Le &gt;= 2:\n            s = 0.0\n    else:\n        if orography_type == 'hill':\n            x_Ld = x/Ld\n            if x_Ld &lt; 2 and z_Le &lt; 2:\n                A = 0.1552*z_Le**4 -0.8575*z_Le**3 +1.8133*z_Le**2 -1.9115*z_Le +1.0124\n                B = -0.3056*z_Le**2 +1.0212*z_Le -1.7637\n                s = A*exp(B*x_Lu)\n            elif x_Ld &gt;= 2 or z_Le &gt;= 2:\n                s = 0.0\n        else: # orography_type == 'cliff'\n            x_Le = x/Le\n            if z_Le &lt; 0.1: z_Le = 0.1\n            if (0.1 &lt; x_Le &lt; 3.5) and (z_Le &lt; 2):\n                logzle = log10(z_Le)\n                A = -1.3420*logzle**3 -0.8222*logzle**2 +0.4609*logzle -0.0791\n                B = -1.0196*logzle**3 -0.8910*logzle**2 +0.5343*logzle -0.1156\n                C =  0.8030*logzle**3 +0.4236*logzle**2 -0.5738*logzle +0.1606\n                logxle = log10(x/Le)\n                s = A*logxle**2 + B*logxle + C\n            elif (0.1 &gt;= x_Le) and (z_Le &lt; 2):\n                s1 = 0.1552*z_Le**4 -0.8575*z_Le**3 +1.8133*z_Le**2 -1.9115*z_Le +1.0124\n                logzle = log10(z_Le)\n                A = -1.3420*logzle**3 -0.8222*logzle**2 +0.4609*logzle -0.0791\n                B = -1.0196*logzle**3 -0.8910*logzle**2 +0.5343*logzle -0.1156\n                C =  0.8030*logzle**3 +0.4236*logzle**2 -0.5738*logzle +0.1606\n                logxle = log10(0.1/Le)\n                s2 = A*logxle**2 + B*logxle + C\n                s = s1 + x_Le*(s2-s1)/0.1           \n            elif x_Le &gt;= 3.5 or z_Le &gt;= 2:\n                s = 0.0\n    return s\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/#eurocodepy.ec1.wind.v_b","title":"<code>v_b(vb_0, c_season=1.0, c_dir=1.0)</code>","text":"<p>Calculates the basic wind velocity </p> <p>Parameters:</p> Name Type Description Default <code>vb_0</code> <code>float</code> <p>fundamental value of the basic wind velocity</p> required <code>c_season</code> <code>float</code> <p>seasonal factor. Defaults to 1.0.</p> <code>1.0</code> <code>c_dir</code> <code>float</code> <p>directional factor. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>basic wind velocity</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def v_b(vb_0: float, c_season: float=1.0, c_dir: float=1.0) -&gt; float:\n    \"\"\"Calculates the basic wind velocity \n\n    Args:\n        vb_0 (float): fundamental value of the basic wind velocity\n        c_season (float, optional): seasonal factor. Defaults to 1.0.\n        c_dir (float, optional): directional factor. Defaults to 1.0.\n\n    Returns:\n        float: basic wind velocity \n    \"\"\"\n    return c_season * c_dir * vb_0\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/#eurocodepy.ec1.wind.v_m","title":"<code>v_m(z, vb, cr, co)</code>","text":"<p>Calculates the mean wind velocity, vm(z), at a height z above the terrain. Depends on the terrain roughness and orography and on the basic wind velocity.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance</p> required <code>vb</code> <code>float</code> <p>basic wind velocity</p> required <code>cr</code> <code>float</code> <p>terrain roughness factor.</p> required <code>co</code> <code>float</code> <p>orography factor.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>mean wind velocity, vm(z)</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def v_m(z: float, vb: float, cr: float, co: float) -&gt; float:\n    \"\"\" Calculates the mean wind velocity, vm(z), at a height z above the terrain.\n    Depends on the terrain roughness and orography and on the basic wind velocity.\n\n    Args:\n        z (float): vertical distance\n        vb (float): basic wind velocity\n        cr (float): terrain roughness factor.\n        co (float): orography factor.\n\n    Returns:\n        float: mean wind velocity, vm(z) \n    \"\"\"\n    return cr * co * vb\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/#eurocodepy.ec1.wind.v_p","title":"<code>v_p(z, vb, z_min, z_0, cr, co, k_I=1)</code>","text":"<p>Calculates the peak velocity, vp(z), at height z,  which includes mean and short-term velocity fluctuations.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance</p> required <code>vb</code> <code>float</code> <p>fundamental value of the basic wind velocity</p> required <code>z_min</code> <code>float</code> <p>minimum height.</p> required <code>z_0</code> <code>float</code> <p>roughness length.</p> required <code>cr</code> <code>float</code> <p>terrain roughness factor.</p> required <code>co</code> <code>float</code> <p>orography factor.</p> required <code>k_I</code> <code>float</code> <p>turbulence intensity factor. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>peak velocity pressure</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def v_p(z: float, vb: float, z_min: float, z_0: float, cr: float, co: float, k_I:float=1) -&gt; float:\n    \"\"\"Calculates the peak velocity, vp(z), at height z, \n    which includes mean and short-term velocity fluctuations.\n\n    Args:\n        z (float): vertical distance\n        vb (float): fundamental value of the basic wind velocity\n        z_min (float, optional): minimum height.\n        z_0 (float, optional): roughness length.\n        cr (float): terrain roughness factor.\n        co (float): orography factor.\n        k_I (float, optional): turbulence intensity factor. Defaults to 1.\n\n    Returns:\n        float: peak velocity pressure\n    \"\"\"\n    v = cr * co * vb\n    zeff = z if z &gt;= z_min else z_min\n    Iv = k_I / co / log(zeff/z_0)\n    vp = (1.0 + 7*Iv) * v\n    return vp\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/pressure/","title":"pressure","text":""},{"location":"reference/eurocodepy/ec1/wind/pressure/#eurocodepy.ec1.wind.pressure.I_v","title":"<code>I_v(z, z_min, z_0, co, k_I=1)</code>","text":"<p>Calculates the turbulence intensity, Iv(z), at height z. It is defined as the standard deviation of the turbulence divided by the mean wind velocity.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance</p> required <code>z_min</code> <code>float</code> <p>minimum height.</p> required <code>z_0</code> <code>float</code> <p>roughness length.</p> required <code>co</code> <code>float</code> <p>orography factor.</p> required <code>k_I</code> <code>float</code> <p>turbulence intensity factor. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>turbulence intensity</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def I_v(z: float, z_min: float, z_0: float, co: float, k_I:float=1) -&gt; float:\n    \"\"\"Calculates the turbulence intensity, Iv(z), at height z.\n    It is defined as the standard deviation of the turbulence divided by the mean wind velocity.\n\n    Args:\n        z (float): vertical distance\n        z_min (float, optional): minimum height.\n        z_0 (float, optional): roughness length.\n        co (float): orography factor.\n        k_I (float, optional): turbulence intensity factor. Defaults to 1.\n\n    Returns:\n        float: turbulence intensity\n    \"\"\"\n    zeff = z if z &gt;= z_min else z_min\n    Iv = k_I / co / log(zeff/z_0)\n    return Iv\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/pressure/#eurocodepy.ec1.wind.pressure.c_o","title":"<code>c_o(z, x=0, H=0, Lu=10, Ld=1000)</code>","text":"<p>Calculates the orography factor. Args:     z (float): vertical distance     x (float, optional): horizontal distance. Defaults to 0.     H (float, optional): height of the hill/cliff. Defaults to 0.     Lu (float, optional): length of the hill/cliff. Defaults to 10.     Ld (float, optional): length of the cliff. Defaults to 1000, meaning it's a cliff.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>orography factor</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def c_o(z: float, x: float=0, H: float=0, Lu: float=10, Ld: float=1000) -&gt; float:\n    \"\"\"Calculates the orography factor.\n    Args:\n        z (float): vertical distance\n        x (float, optional): horizontal distance. Defaults to 0.\n        H (float, optional): height of the hill/cliff. Defaults to 0.\n        Lu (float, optional): length of the hill/cliff. Defaults to 10.\n        Ld (float, optional): length of the cliff. Defaults to 1000, meaning it's a cliff.\n\n    Returns:\n        float: orography factor\n    \"\"\"\n    phi = H/Lu\n    if phi &lt; 0.05: return 1.0\n    s = s_coef(x, z, H, Lu, Ld)\n    return 1.0+2.0*s*phi if phi &lt; 0.3 else 1.0+0.6*s\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/pressure/#eurocodepy.ec1.wind.pressure.c_r","title":"<code>c_r(z, z_min, z_0, z_0II)</code>","text":"<p>Calculate the roughness factor</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance.</p> required <code>z_min</code> <code>float</code> <p>minimum height.</p> required <code>z_0</code> <code>float</code> <p>roughness length.</p> required <code>z_OII</code> <code>float</code> <p>roughness length for terrain II.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the roughness factor</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def c_r(z: float, z_min: float, z_0: float, z_0II: float) -&gt; float:\n    \"\"\" Calculate the roughness factor\n\n    Args:\n        z (float): vertical distance.\n        z_min (float, optional): minimum height.\n        z_0 (float, optional): roughness length.\n        z_OII (float, optional): roughness length for terrain II.\n\n    Returns:\n        float: the roughness factor\n    \"\"\"\n    k_r = 0.19*((z_0/z_0II)**0.07)\n    zeff = z if z &gt;= z_min else z_min\n    return k_r * log(zeff/z_0)\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/pressure/#eurocodepy.ec1.wind.pressure.q_p","title":"<code>q_p(z, vb, z_min, z_0, cr, co, rho=1.25, k_I=1)</code>","text":"<p>Calculates the peak velocity pressure, qp(z), at height z,  which includes mean and short-term velocity fluctuations.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance.</p> required <code>vb</code> <code>float</code> <p>fundamental value of the basic wind velocity.</p> required <code>z_min</code> <code>float</code> <p>minimum height.</p> required <code>z_0</code> <code>float</code> <p>roughness length.</p> required <code>cr</code> <code>float</code> <p>terrain roughness factor.</p> required <code>co</code> <code>float</code> <p>orography factor.</p> required <code>rho</code> <code>float</code> <p>air density. Defaults to 1.25 kg/m3.</p> <code>1.25</code> <code>k_I</code> <code>float</code> <p>turbulence intensity factor. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>peak velocity pressure</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def q_p(z: float, vb: float, z_min: float, z_0: float, cr: float, co: float, rho: float=1.25, k_I:float=1) -&gt; float:\n    \"\"\"Calculates the peak velocity pressure, qp(z), at height z, \n    which includes mean and short-term velocity fluctuations.\n\n    Args:\n        z (float): vertical distance.\n        vb (float): fundamental value of the basic wind velocity.\n        z_min (float, optional): minimum height.\n        z_0 (float, optional): roughness length.\n        cr (float): terrain roughness factor.\n        co (float): orography factor.\n        rho (float, optional): air density. Defaults to 1.25 kg/m3.\n        k_I (float, optional): turbulence intensity factor. Defaults to 1.\n\n    Returns:\n        float: peak velocity pressure\n    \"\"\"\n    v = cr * co * vb\n    zeff = z if z &gt;= z_min else z_min\n    Iv = k_I / co / log(zeff/z_0)\n    qp = 0.5 * (1.0 + 7*Iv) * v**2 * rho\n    return qp\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/pressure/#eurocodepy.ec1.wind.pressure.s_coef","title":"<code>s_coef(x, z, H, Lu, Ld=1000)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>horizontal distance</p> required <code>z</code> <code>float</code> <p>vertical distance</p> required <code>H</code> <code>float</code> <p>height of the hill/cliff</p> required <code>Lu</code> <code>float</code> <p>length of the hill/cliff</p> required <code>Ld</code> <code>float</code> <p>length of the cliff. Defaults to 1000, meaning it's a cliff.</p> <code>1000</code> <p>Returns:     float: description</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def s_coef(x: float, z: float, H: float, Lu: float, Ld: float=1000) -&gt; float:\n    \"\"\"_summary_\n\n    Args:\n        x (float): horizontal distance\n        z (float): vertical distance\n        H (float): height of the hill/cliff\n        Lu (float): length of the hill/cliff\n        Ld (float, optional): length of the cliff. Defaults to 1000, meaning it's a cliff.\n    Returns:\n        float: _description_\n    \"\"\"\n    phi0 = H/Ld\n    phi = H/Lu\n\n    if phi &lt; 0.05: return 0.0\n    orography_type = 'hill' if phi0 &gt; 0.05 else 'cliff'\n\n    Le = H/0.3 if phi &gt;= 0.3 else Lu\n    x_Lu = x/Lu\n    z_Le = z/Le\n\n    s = 0.0\n    if x_Lu &lt;= 0:\n        if -1.5 &lt; x_Lu and z_Le &lt; 2:\n            A = 0.1552*z_Le**4 -0.8575*z_Le**3 +1.8133*z_Le**2 -1.9115*z_Le +1.0124\n            B = 0.3542*z_Le**2 -1.0577*z_Le+2.6456\n            s = A*exp(B*x_Lu)\n        elif x_Lu &lt; -1.5 or z_Le &gt;= 2:\n            s = 0.0\n    else:\n        if orography_type == 'hill':\n            x_Ld = x/Ld\n            if x_Ld &lt; 2 and z_Le &lt; 2:\n                A = 0.1552*z_Le**4 -0.8575*z_Le**3 +1.8133*z_Le**2 -1.9115*z_Le +1.0124\n                B = -0.3056*z_Le**2 +1.0212*z_Le -1.7637\n                s = A*exp(B*x_Lu)\n            elif x_Ld &gt;= 2 or z_Le &gt;= 2:\n                s = 0.0\n        else: # orography_type == 'cliff'\n            x_Le = x/Le\n            if z_Le &lt; 0.1: z_Le = 0.1\n            if (0.1 &lt; x_Le &lt; 3.5) and (z_Le &lt; 2):\n                logzle = log10(z_Le)\n                A = -1.3420*logzle**3 -0.8222*logzle**2 +0.4609*logzle -0.0791\n                B = -1.0196*logzle**3 -0.8910*logzle**2 +0.5343*logzle -0.1156\n                C =  0.8030*logzle**3 +0.4236*logzle**2 -0.5738*logzle +0.1606\n                logxle = log10(x/Le)\n                s = A*logxle**2 + B*logxle + C\n            elif (0.1 &gt;= x_Le) and (z_Le &lt; 2):\n                s1 = 0.1552*z_Le**4 -0.8575*z_Le**3 +1.8133*z_Le**2 -1.9115*z_Le +1.0124\n                logzle = log10(z_Le)\n                A = -1.3420*logzle**3 -0.8222*logzle**2 +0.4609*logzle -0.0791\n                B = -1.0196*logzle**3 -0.8910*logzle**2 +0.5343*logzle -0.1156\n                C =  0.8030*logzle**3 +0.4236*logzle**2 -0.5738*logzle +0.1606\n                logxle = log10(0.1/Le)\n                s2 = A*logxle**2 + B*logxle + C\n                s = s1 + x_Le*(s2-s1)/0.1           \n            elif x_Le &gt;= 3.5 or z_Le &gt;= 2:\n                s = 0.0\n    return s\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/pressure/#eurocodepy.ec1.wind.pressure.v_b","title":"<code>v_b(vb_0, c_season=1.0, c_dir=1.0)</code>","text":"<p>Calculates the basic wind velocity </p> <p>Parameters:</p> Name Type Description Default <code>vb_0</code> <code>float</code> <p>fundamental value of the basic wind velocity</p> required <code>c_season</code> <code>float</code> <p>seasonal factor. Defaults to 1.0.</p> <code>1.0</code> <code>c_dir</code> <code>float</code> <p>directional factor. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>basic wind velocity</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def v_b(vb_0: float, c_season: float=1.0, c_dir: float=1.0) -&gt; float:\n    \"\"\"Calculates the basic wind velocity \n\n    Args:\n        vb_0 (float): fundamental value of the basic wind velocity\n        c_season (float, optional): seasonal factor. Defaults to 1.0.\n        c_dir (float, optional): directional factor. Defaults to 1.0.\n\n    Returns:\n        float: basic wind velocity \n    \"\"\"\n    return c_season * c_dir * vb_0\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/pressure/#eurocodepy.ec1.wind.pressure.v_m","title":"<code>v_m(z, vb, cr, co)</code>","text":"<p>Calculates the mean wind velocity, vm(z), at a height z above the terrain. Depends on the terrain roughness and orography and on the basic wind velocity.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance</p> required <code>vb</code> <code>float</code> <p>basic wind velocity</p> required <code>cr</code> <code>float</code> <p>terrain roughness factor.</p> required <code>co</code> <code>float</code> <p>orography factor.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>mean wind velocity, vm(z)</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def v_m(z: float, vb: float, cr: float, co: float) -&gt; float:\n    \"\"\" Calculates the mean wind velocity, vm(z), at a height z above the terrain.\n    Depends on the terrain roughness and orography and on the basic wind velocity.\n\n    Args:\n        z (float): vertical distance\n        vb (float): basic wind velocity\n        cr (float): terrain roughness factor.\n        co (float): orography factor.\n\n    Returns:\n        float: mean wind velocity, vm(z) \n    \"\"\"\n    return cr * co * vb\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/pressure/#eurocodepy.ec1.wind.pressure.v_p","title":"<code>v_p(z, vb, z_min, z_0, cr, co, k_I=1)</code>","text":"<p>Calculates the peak velocity, vp(z), at height z,  which includes mean and short-term velocity fluctuations.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance</p> required <code>vb</code> <code>float</code> <p>fundamental value of the basic wind velocity</p> required <code>z_min</code> <code>float</code> <p>minimum height.</p> required <code>z_0</code> <code>float</code> <p>roughness length.</p> required <code>cr</code> <code>float</code> <p>terrain roughness factor.</p> required <code>co</code> <code>float</code> <p>orography factor.</p> required <code>k_I</code> <code>float</code> <p>turbulence intensity factor. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>peak velocity pressure</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def v_p(z: float, vb: float, z_min: float, z_0: float, cr: float, co: float, k_I:float=1) -&gt; float:\n    \"\"\"Calculates the peak velocity, vp(z), at height z, \n    which includes mean and short-term velocity fluctuations.\n\n    Args:\n        z (float): vertical distance\n        vb (float): fundamental value of the basic wind velocity\n        z_min (float, optional): minimum height.\n        z_0 (float, optional): roughness length.\n        cr (float): terrain roughness factor.\n        co (float): orography factor.\n        k_I (float, optional): turbulence intensity factor. Defaults to 1.\n\n    Returns:\n        float: peak velocity pressure\n    \"\"\"\n    v = cr * co * vb\n    zeff = z if z &gt;= z_min else z_min\n    Iv = k_I / co / log(zeff/z_0)\n    vp = (1.0 + 7*Iv) * v\n    return vp\n</code></pre>"},{"location":"reference/eurocodepy/ec2/","title":"ec2","text":""},{"location":"reference/eurocodepy/ec2/#eurocodepy.ec2.Concrete","title":"<code>Concrete</code>","text":"Source code in <code>eurocodepy/ec2/__init__.py</code> <pre><code>class Concrete:\n    def __init__(self, class_name: str | ConcreteClass = \"C30/37\"):\n        \"\"\"\n        Eurocode 2 concrete properties.\n        :param fck: Characteristic compressive strength of concrete (MPa)\n        \"\"\"\n        if isinstance(class_name, ConcreteClass):\n            self.grade = class_name.value\n            class_name = class_name.value\n        elif isinstance(class_name, str):\n            self.grade = class_name\n        else:\n            raise TypeError(\"class_name must be a string or ConcreteClass enum\")\n\n        class_name = class_name.replace(\"/\", \"_\").upper()\n        if class_name not in db.ConcreteGrades.keys():\n            grades_list = [item.replace(\"_\", \"/\") for item in db.ConcreteGrades.keys()]\n            raise ValueError(f\"Concrete class '{class_name}' not found in database. Concrete type must be one of {grades_list}\")\n\n        conc = db.ConcreteGrades[class_name]\n        self.name = class_name\n        self.fck = conc[\"fck\"]  # MPa\n        self.fcm = conc[\"fcm\"]  # Mean compressive strength (MPa)\n        self.fctm = conc[\"fctm\"]  # Mean tensile strength (MPa)\n        self.fctk_05 = conc[\"fctk05\"] * self.fctm  # 5% fractile (MPa)\n        self.fctk_95 = round(1.3 * self.fctm, 1)  # 95% fractile (MPa)\n        self.Ecm = conc[\"Ecm\"]  # Modulus of elasticity (MPa)\n        self.eps_c2 = conc[\"epsc2\"]  # Strain at peak stress\n        self.eps_cu2 = conc[\"epscu2\"]  # Ultimate compressive strain\n        self.n = conc[\"n\"]  # Ultimate compressive strain\n\n        gamma_cc = db.ConcreteParams[\"gamma_cc\"]  # Partial safety factor\n        self.fcd = round(self.fck / gamma_cc, 1)  # Design yield strength (MPa)\n        gamma_ct = db.ConcreteParams[\"gamma_ct\"]  # Partial safety factor\n        self.fctd = round(self.fctk_05 / gamma_ct, 1)  # Design yield strength (MPa)\n\n    @property\n    def C25_30(self):\n        return Concrete(\"C25/30\")  # Default concrete class\n\n    @classmethod\n    def from_fck(cls, f_ck: int, name=None) -&gt; 'Concrete':\n        \"\"\"\n        Create a Concrete instance from characteristic compressive strength, using EC2 relations.\n        :param f_ck: Characteristic compressive strength of concrete (MPa)\n        :type f_ck: int\n        :return: Concrete instance\n        \"\"\"\n        fck = float(f_ck)\n        cls.fck = round(fck, 1)  # MPa\n        cls.fcm = round(fck + 8, 1)  # Mean compressive strength (MPa)\n        cls.fctm = round(0.30 * fck**(2/3), 1)  # Mean tensile strength (MPa)\n        cls.fctk_005 = round(0.7 * cls.fctm, 1)  # 5% fractile\n        cls.fctk_095 = round(1.3 * cls.fctm, 1)  # 95% fractile\n        cls.Ecm = round(22000 * (cls.fcm / 10)**0.3, 1)  # Modulus of elasticity (MPa)\n        cls.eps_c2 = 2.0 if fck &lt;= 50 else 2.0 + 0.085 * (fck - 50) ** 0.53  # Strain at peak stress\n        cls.eps_cu2 = 3.5 if fck &lt;= 50 else round(2.6+35*((90.0-fck)/100.0)**4, 1)\n        cls.n = 2.0 if fck &lt;= 50 else round(1.4+23.4*((90.0-fck)/100.0)**4, 1)\n        if name is not None:\n            cls.name = name\n            cls.grade = name\n        else:\n            cls.name = f\"C{f_ck}\"\n            cls.grade = f\"C{f_ck}\"\n\n        gamma_cc = db.ConcreteParams[\"gamma_cc\"]  # Partial safety factor\n        cls.fcd = round(cls.fck / gamma_cc, 1)  # Design yield strength (MPa)\n        gamma_ct = db.ConcreteParams[\"gamma_ct\"]  # Partial safety factor\n        cls.fctd = round(cls.fctk_05 / gamma_ct, 1)  # Design yield strength (MPa)\n\n        return cls  \n</code></pre>"},{"location":"reference/eurocodepy/ec2/#eurocodepy.ec2.Concrete.__init__","title":"<code>__init__(class_name='C30/37')</code>","text":"<p>Eurocode 2 concrete properties. :param fck: Characteristic compressive strength of concrete (MPa)</p> Source code in <code>eurocodepy/ec2/__init__.py</code> <pre><code>def __init__(self, class_name: str | ConcreteClass = \"C30/37\"):\n    \"\"\"\n    Eurocode 2 concrete properties.\n    :param fck: Characteristic compressive strength of concrete (MPa)\n    \"\"\"\n    if isinstance(class_name, ConcreteClass):\n        self.grade = class_name.value\n        class_name = class_name.value\n    elif isinstance(class_name, str):\n        self.grade = class_name\n    else:\n        raise TypeError(\"class_name must be a string or ConcreteClass enum\")\n\n    class_name = class_name.replace(\"/\", \"_\").upper()\n    if class_name not in db.ConcreteGrades.keys():\n        grades_list = [item.replace(\"_\", \"/\") for item in db.ConcreteGrades.keys()]\n        raise ValueError(f\"Concrete class '{class_name}' not found in database. Concrete type must be one of {grades_list}\")\n\n    conc = db.ConcreteGrades[class_name]\n    self.name = class_name\n    self.fck = conc[\"fck\"]  # MPa\n    self.fcm = conc[\"fcm\"]  # Mean compressive strength (MPa)\n    self.fctm = conc[\"fctm\"]  # Mean tensile strength (MPa)\n    self.fctk_05 = conc[\"fctk05\"] * self.fctm  # 5% fractile (MPa)\n    self.fctk_95 = round(1.3 * self.fctm, 1)  # 95% fractile (MPa)\n    self.Ecm = conc[\"Ecm\"]  # Modulus of elasticity (MPa)\n    self.eps_c2 = conc[\"epsc2\"]  # Strain at peak stress\n    self.eps_cu2 = conc[\"epscu2\"]  # Ultimate compressive strain\n    self.n = conc[\"n\"]  # Ultimate compressive strain\n\n    gamma_cc = db.ConcreteParams[\"gamma_cc\"]  # Partial safety factor\n    self.fcd = round(self.fck / gamma_cc, 1)  # Design yield strength (MPa)\n    gamma_ct = db.ConcreteParams[\"gamma_ct\"]  # Partial safety factor\n    self.fctd = round(self.fctk_05 / gamma_ct, 1)  # Design yield strength (MPa)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/#eurocodepy.ec2.Concrete.from_fck","title":"<code>from_fck(f_ck, name=None)</code>  <code>classmethod</code>","text":"<p>Create a Concrete instance from characteristic compressive strength, using EC2 relations. :param f_ck: Characteristic compressive strength of concrete (MPa) :type f_ck: int :return: Concrete instance</p> Source code in <code>eurocodepy/ec2/__init__.py</code> <pre><code>@classmethod\ndef from_fck(cls, f_ck: int, name=None) -&gt; 'Concrete':\n    \"\"\"\n    Create a Concrete instance from characteristic compressive strength, using EC2 relations.\n    :param f_ck: Characteristic compressive strength of concrete (MPa)\n    :type f_ck: int\n    :return: Concrete instance\n    \"\"\"\n    fck = float(f_ck)\n    cls.fck = round(fck, 1)  # MPa\n    cls.fcm = round(fck + 8, 1)  # Mean compressive strength (MPa)\n    cls.fctm = round(0.30 * fck**(2/3), 1)  # Mean tensile strength (MPa)\n    cls.fctk_005 = round(0.7 * cls.fctm, 1)  # 5% fractile\n    cls.fctk_095 = round(1.3 * cls.fctm, 1)  # 95% fractile\n    cls.Ecm = round(22000 * (cls.fcm / 10)**0.3, 1)  # Modulus of elasticity (MPa)\n    cls.eps_c2 = 2.0 if fck &lt;= 50 else 2.0 + 0.085 * (fck - 50) ** 0.53  # Strain at peak stress\n    cls.eps_cu2 = 3.5 if fck &lt;= 50 else round(2.6+35*((90.0-fck)/100.0)**4, 1)\n    cls.n = 2.0 if fck &lt;= 50 else round(1.4+23.4*((90.0-fck)/100.0)**4, 1)\n    if name is not None:\n        cls.name = name\n        cls.grade = name\n    else:\n        cls.name = f\"C{f_ck}\"\n        cls.grade = f\"C{f_ck}\"\n\n    gamma_cc = db.ConcreteParams[\"gamma_cc\"]  # Partial safety factor\n    cls.fcd = round(cls.fck / gamma_cc, 1)  # Design yield strength (MPa)\n    gamma_ct = db.ConcreteParams[\"gamma_ct\"]  # Partial safety factor\n    cls.fctd = round(cls.fctk_05 / gamma_ct, 1)  # Design yield strength (MPa)\n\n    return cls  \n</code></pre>"},{"location":"reference/eurocodepy/ec2/#eurocodepy.ec2.Prestress","title":"<code>Prestress</code>","text":"Source code in <code>eurocodepy/ec2/__init__.py</code> <pre><code>class Prestress:\n    def __init__(self, type_label: str | PrestressClass = \"Y1860S7 12.5\"):\n        \"\"\"\n        Eurocode 2 steel reinforcement properties.\n        :param type_label: Steel type label (e.g., 'Y1860S7 12.5', 'Y1860S7 15.2')\n        \"\"\"\n\n        if isinstance(type_label, PrestressClass):\n            class_name = type_label.name\n            self.name = class_name.replace(\"_\", \" \", 1).replace(\"_\", \".\", 1)\n        elif isinstance(type_label, str):\n            self.name = type_label\n            class_name = type_label.replace(\" \", \"_\")\n            class_name = class_name.replace(\".\", \"_\")\n        else:\n            raise TypeError(\"type_label must be a string or PrestressClass enum\")\n\n        if class_name not in db.PrestressGrades.keys():\n            grades_list = [item.replace(\"_\", \" \", 1).replace(\"_\", \".\", 1) for item in db.PrestressGrades.keys()]\n            raise ValueError(f\"Prestress steel class '{class_name}' not found in database. Prestress type must be one of {grades_list}\")\n\n        reinf = db.PrestressGrades[class_name]\n        self.pType = reinf[\"T\"] # 'strand', 'bar', or 'wire'\n        self.zone = reinf[\"zone\"]\n        self.fpk = reinf[\"fpk\"] # Characteristic prestress force (MPa)\n        self.fp0_1k = reinf[\"fp0_1k\"] # Characteristic prestress force at 0.1% strain (MPa)\n        self.Ep = reinf[\"Ep\"] # Modulus of elasticity (MPa)\n        self.d = reinf[\"d\"] # Diameter (mm)\n        self.Ap = reinf[\"Ap\"] # Cross-sectional area (cm\u00b2)\n\n        gamma_p = db.PrestressParams[\"gamma_p\"]  # Partial safety factor\n        self.fpd = round(self.fp0_1k / gamma_p, 0)  # Design yield strength (MPa)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/#eurocodepy.ec2.Prestress.__init__","title":"<code>__init__(type_label='Y1860S7 12.5')</code>","text":"<p>Eurocode 2 steel reinforcement properties. :param type_label: Steel type label (e.g., 'Y1860S7 12.5', 'Y1860S7 15.2')</p> Source code in <code>eurocodepy/ec2/__init__.py</code> <pre><code>def __init__(self, type_label: str | PrestressClass = \"Y1860S7 12.5\"):\n    \"\"\"\n    Eurocode 2 steel reinforcement properties.\n    :param type_label: Steel type label (e.g., 'Y1860S7 12.5', 'Y1860S7 15.2')\n    \"\"\"\n\n    if isinstance(type_label, PrestressClass):\n        class_name = type_label.name\n        self.name = class_name.replace(\"_\", \" \", 1).replace(\"_\", \".\", 1)\n    elif isinstance(type_label, str):\n        self.name = type_label\n        class_name = type_label.replace(\" \", \"_\")\n        class_name = class_name.replace(\".\", \"_\")\n    else:\n        raise TypeError(\"type_label must be a string or PrestressClass enum\")\n\n    if class_name not in db.PrestressGrades.keys():\n        grades_list = [item.replace(\"_\", \" \", 1).replace(\"_\", \".\", 1) for item in db.PrestressGrades.keys()]\n        raise ValueError(f\"Prestress steel class '{class_name}' not found in database. Prestress type must be one of {grades_list}\")\n\n    reinf = db.PrestressGrades[class_name]\n    self.pType = reinf[\"T\"] # 'strand', 'bar', or 'wire'\n    self.zone = reinf[\"zone\"]\n    self.fpk = reinf[\"fpk\"] # Characteristic prestress force (MPa)\n    self.fp0_1k = reinf[\"fp0_1k\"] # Characteristic prestress force at 0.1% strain (MPa)\n    self.Ep = reinf[\"Ep\"] # Modulus of elasticity (MPa)\n    self.d = reinf[\"d\"] # Diameter (mm)\n    self.Ap = reinf[\"Ap\"] # Cross-sectional area (cm\u00b2)\n\n    gamma_p = db.PrestressParams[\"gamma_p\"]  # Partial safety factor\n    self.fpd = round(self.fp0_1k / gamma_p, 0)  # Design yield strength (MPa)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/#eurocodepy.ec2.Reinforcement","title":"<code>Reinforcement</code>","text":"Source code in <code>eurocodepy/ec2/__init__.py</code> <pre><code>class Reinforcement:\n    def __init__(self, type_label: str | ReinforcementClass = \"B500B\"):\n        \"\"\"\n        Eurocode 2 steel reinforcement properties.\n        :param type_label: Steel type label (e.g., 'B500B', 'B500C')\n        \"\"\"\n\n        if isinstance(type_label, ReinforcementClass):\n            type_label = type_label.name\n        self.grade = type_label\n        self.name = type_label\n\n        if type_label not in db.ReinforcementGrades.keys():\n            raise ValueError(f\"Steel type '{type_label}' not found in database. Steel type must be one of {list(db.ReinforcementGrades.keys())}\")\n\n        reinf = db.ReinforcementGrades[type_label]\n        self.fyk = reinf[\"fyk\"] # Characteristic yield strength (MPa)\n        self.epsilon_uk = reinf[\"epsuk\"] # Ultimate strain (\u2030)\n        self.ftk = reinf[\"ftk\"] # Characteristic tensile strength (MPa)\n        self.Es = reinf[\"Es\"] # Modulus of elasticity (MPa)\n        self.ClassType = reinf[\"T\"] # 'A', 'B', or 'C'\n\n        gamma_s = db.ReinforcementParams[\"gamma_s\"]  # Partial safety factor\n        self.fyd = round(self.fyk / gamma_s, 1)  # Design yield strength (MPa)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/#eurocodepy.ec2.Reinforcement.__init__","title":"<code>__init__(type_label='B500B')</code>","text":"<p>Eurocode 2 steel reinforcement properties. :param type_label: Steel type label (e.g., 'B500B', 'B500C')</p> Source code in <code>eurocodepy/ec2/__init__.py</code> <pre><code>def __init__(self, type_label: str | ReinforcementClass = \"B500B\"):\n    \"\"\"\n    Eurocode 2 steel reinforcement properties.\n    :param type_label: Steel type label (e.g., 'B500B', 'B500C')\n    \"\"\"\n\n    if isinstance(type_label, ReinforcementClass):\n        type_label = type_label.name\n    self.grade = type_label\n    self.name = type_label\n\n    if type_label not in db.ReinforcementGrades.keys():\n        raise ValueError(f\"Steel type '{type_label}' not found in database. Steel type must be one of {list(db.ReinforcementGrades.keys())}\")\n\n    reinf = db.ReinforcementGrades[type_label]\n    self.fyk = reinf[\"fyk\"] # Characteristic yield strength (MPa)\n    self.epsilon_uk = reinf[\"epsuk\"] # Ultimate strain (\u2030)\n    self.ftk = reinf[\"ftk\"] # Characteristic tensile strength (MPa)\n    self.Es = reinf[\"Es\"] # Modulus of elasticity (MPa)\n    self.ClassType = reinf[\"T\"] # 'A', 'B', or 'C'\n\n    gamma_s = db.ReinforcementParams[\"gamma_s\"]  # Partial safety factor\n    self.fyd = round(self.fyk / gamma_s, 1)  # Design yield strength (MPa)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/crack/","title":"crack","text":""},{"location":"reference/eurocodepy/ec2/crack/#eurocodepy.ec2.crack.iscracked_annexLL","title":"<code>iscracked_annexLL(fctm, fcm, sigxx, sigyy, sigzz, sigxy, sigyz, sigzx)</code>","text":"<p>Checks if the point is cracked using expression (LL.101) of Annex LL of EN 1992-2:2005. Author. Paulo Cachim (2022)</p> <p>Parameters:</p> Name Type Description Default <code>fctm</code> <code>float</code> <p>mean tensile strength of concrete</p> required <code>fcm</code> <code>float</code> <p>mean comprerssive strength of concrete</p> required <code>sigxx</code> <code>float</code> <p>stress xx</p> required <code>sigyy</code> <code>float</code> <p>stress yy</p> required <code>sigzz</code> <code>float</code> <p>stress zz</p> required <code>sigxy</code> <code>float</code> <p>stress xy</p> required <code>sigyz</code> <code>float</code> <p>stress yz</p> required <code>sigzx</code> <code>float</code> <p>stress zx</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if cracked, False otherwise</p> Source code in <code>eurocodepy/ec2/crack.py</code> <pre><code>def iscracked_annexLL(fctm: float, fcm: float, \n                sigxx: float, sigyy: float, sigzz: float, \n                sigxy: float, sigyz: float, sigzx: float) -&gt; bool:\n    \"\"\"Checks if the point is cracked using expression (LL.101) of Annex LL of EN 1992-2:2005.\n    Author. Paulo Cachim (2022)\n\n    Args:\n        fctm (float): mean tensile strength of concrete\n        fcm (float): mean comprerssive strength of concrete\n        sigxx (float): stress xx\n        sigyy (float): stress yy\n        sigzz (float): stress zz\n        sigxy (float): stress xy\n        sigyz (float): stress yz\n        sigzx (float): stress zx\n\n    Returns:\n        bool: True if cracked, False otherwise\n    \"\"\"\n    # Calculate stress invariants\n    invar = utils.stress.invariants(sigxx, sigyy, sigzz, sigxy, sigyz, sigzx)\n    I1 = invar[0] / fcm\n    J2 = invar[1] / fcm / fcm\n    cos3t = invar[8]\n\n    # Calculate auxiliary parameters\n    k = fctm/fcm\n    c1 = 1.0/(0.7*k**0.9)\n    c2 = 1.0 - 6.8*(k-0.07)**2\n    alpha = 1.0/(9.0*k**1.4)\n    beta = 1.0/(3.7*k**1.1)\n    ang = math.acos(abs(c2 * cos3t))/3.0\n    lamb = c1 * math.cos(ang) if cos3t &gt;= 0 else c1 * (math.pi/3.0-ang)\n\n    # Calculate cracking condition (&gt;0 cracked; &lt;0 uncracked)\n    crack = alpha*J2 + lamb*math.sqrt(J2) + beta*I1 - 1.0\n\n    # Return cracked stated (True: cracked: False: uncracked)\n    return True if crack &gt; 0 else False\n</code></pre>"},{"location":"reference/eurocodepy/ec2/material/","title":"material","text":""},{"location":"reference/eurocodepy/ec2/material/#eurocodepy.ec2.material.beta_cc","title":"<code>beta_cc(t, s=0.25)</code>","text":"<p>Calculates the strength hardening coeficient</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>time (days)</p> required <code>s</code> <code>float</code> <p>cement type parameter. Optional, defaults to 0.25 (Type N cement)</p> <code>0.25</code> <code>s</code> <code>= 0.20, fast hardening R</code> <p>CEM42,5R, CEM52,5N e CEM52,5R</p> <code>0.25</code> <code>s</code> <code>= 0.25, normal hardening N</code> <p>CEM32,5R, CEM42,5N</p> <code>0.25</code> <code>s</code> <code>= 0.38, slow hardening S</code> <p>CEM32,5N</p> <code>0.25</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>strength hardening coeficient</p> Source code in <code>eurocodepy/ec2/material.py</code> <pre><code>def beta_cc(t: float, s: float=0.25)-&gt;float:\n    \"\"\"Calculates the strength hardening coeficient\n\n    Args:\n        t (float): time (days)\n        s (float): cement type parameter. Optional, defaults to 0.25 (Type N cement)\n\n        s = 0.20, fast hardening R: CEM42,5R, CEM52,5N e CEM52,5R\n        s = 0.25, normal hardening N: CEM32,5R, CEM42,5N\n        s = 0.38, slow hardening S: CEM32,5N\n\n    Returns:\n        float: strength hardening coeficient\n    \"\"\"\n    return np.exp(s * (1 - np.sqrt(28.0/t)))\n</code></pre>"},{"location":"reference/eurocodepy/ec2/material/#eurocodepy.ec2.material.beta_ce","title":"<code>beta_ce(t, s=0.25)</code>","text":"<p>Calculates the modulus of elasticity hardening coeficient</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>time (days)</p> required <code>s</code> <code>float</code> <p>cement type parameter. Optional, defaults to 0.25 (Type N cement)</p> <code>0.25</code> <code>s</code> <code>= 0.20, fast hardening R</code> <p>CEM42,5R, CEM52,5N e CEM52,5R</p> <code>0.25</code> <code>s</code> <code>= 0.25, normal hardening N</code> <p>CEM32,5R, CEM42,5N</p> <code>0.25</code> <code>s</code> <code>= 0.38, slow hardening S</code> <p>CEM32,5N</p> <code>0.25</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>modulus of elasticity hardening coeficient</p> Source code in <code>eurocodepy/ec2/material.py</code> <pre><code>def beta_ce(t: float, s: float=0.25)-&gt;float:\n    \"\"\"Calculates the modulus of elasticity hardening coeficient\n\n    Args:\n        t (float): time (days)\n        s (float): cement type parameter. Optional, defaults to 0.25 (Type N cement)\n\n        s = 0.20, fast hardening R: CEM42,5R, CEM52,5N e CEM52,5R\n        s = 0.25, normal hardening N: CEM32,5R, CEM42,5N\n        s = 0.38, slow hardening S: CEM32,5N\n\n    Returns:\n        float: modulus of elasticity hardening coeficient\n    \"\"\"\n    return (np.exp(s * (1 - np.sqrt(28.0/t))))**0.3\n</code></pre>"},{"location":"reference/eurocodepy/ec2/material/#eurocodepy.ec2.material.calc_creep_coef","title":"<code>calc_creep_coef(t=1000000, h0=100, rh=65, t0=10, fck=20.0, cem=0.0)</code>","text":"<p>Calculates the creep coeficient. Uses EN1992-1:2004. This function calculates the creep coefficient of concrete based on the time, effective height, relative humidity, initial time, concrete compressive strength, and cement parameter. The creep coefficient is a measure of the time-dependent deformation of concrete under sustained load. It is calculated using the coefficients defined for different concrete compressive strengths and the effects of relative humidity and time.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>int</code> <p>time, in days. Defaults to 28.</p> <code>1000000</code> <code>h0</code> <code>int</code> <p>effective height, in m. Defaults to 100.</p> <code>100</code> <code>rh</code> <code>int</code> <p>relative humidity, in percentage. Defaults to 65.</p> <code>65</code> <code>t0</code> <code>int</code> <p>description. Defaults to 10.</p> <code>10</code> <code>fck</code> <code>float</code> <p>concrete compressive strength. Defaults to 20.0.</p> <code>20.0</code> <code>cem</code> <code>float</code> <p>cement parameter. Defaults to 0.0.</p> <code>0.0</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the creep coeficient</p> Source code in <code>eurocodepy/ec2/material.py</code> <pre><code>def calc_creep_coef(t=1000000, h0=100, rh=65, t0=10, fck=20.0, cem=0.0)-&gt;float:\n    \"\"\"Calculates the creep coeficient. Uses EN1992-1:2004.\n    This function calculates the creep coefficient of concrete based on the time, effective height, relative humidity, initial time, concrete compressive strength, and cement parameter.\n    The creep coefficient is a measure of the time-dependent deformation of concrete under sustained load.\n    It is calculated using the coefficients defined for different concrete compressive strengths and the effects of relative humidity and time.\n\n    Args:\n        t (int, optional): time, in days. Defaults to 28.\n        h0 (int, optional): effective height, in m. Defaults to 100.\n        rh (int, optional): relative humidity, in percentage. Defaults to 65.\n        t0 (int, optional): _description_. Defaults to 10.\n        fck (float, optional): concrete compressive strength. Defaults to 20.0.\n        cem (float, optional): cement parameter. Defaults to 0.0.\n\n    Returns:\n        float: the creep coeficient\n    \"\"\"\n    fcm = fck+8\n    alpha1 = (35/fcm)**0.7\n    alpha2 = (35/fcm)**0.2\n    alpha3 = min(1.0, (35/fcm)**0.5)\n    tt0 = t0*((1.0+9.0/(2.0+t0**1.2))**cem)\n    phi_RH = (1.0-rh/100)/(0.1*(h0**0.33333333))\n    phi_RH = 1.0+phi_RH if fcm &lt;= 35 else (1.0+phi_RH*alpha1)*alpha2\n    beta_fcm = 16.8/math.sqrt(fcm)\n    beta_t0 = 1.0/(0.1+tt0**0.2)\n    phi_0 = beta_fcm*beta_t0*phi_RH\n\n    try:        \n        betah = min(1500*alpha3, 1.5*(1.0+math.pow(0.012*rh,18))*h0+250*alpha3)\n        betacc = math.pow((t-t0)/(betah+t-t0), 0.3)\n        phi = betacc*phi_0    \n    except:\n        betacc = 0.0\n        phi = 0.0\n\n    return phi\n</code></pre>"},{"location":"reference/eurocodepy/ec2/material/#eurocodepy.ec2.material.calc_shrink_strain","title":"<code>calc_shrink_strain(t=1000000, h0=100, ts=3, rh=65, fck=20.0, cem='Type N')</code>","text":"<p>Calculates the total shrinkage strain. Uses EN1992-1:2004. This function calculates the total shrinkage strain of concrete based on the time, effective height, time of shrinkage start, relative humidity, concrete compressive strength, and cement type. The shrinkage strain is calculated using the coefficients defined for different cement types and the concrete compressive strength.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>int</code> <p>time, in days. Defaults to 28.</p> <code>1000000</code> <code>h0</code> <code>int</code> <p>effective height, in m. Defaults to 100.</p> <code>100</code> <code>ts</code> <code>int</code> <p>time of shrinkage start. Defaults to 3.</p> <code>3</code> <code>rh</code> <code>int</code> <p>relative humidity, in percentage. Defaults to 65.</p> <code>65</code> <code>fck</code> <code>float</code> <p>concrete compressive strength. Defaults to 20.0.</p> <code>20.0</code> <code>cem</code> <code>str</code> <p>cement type. Defaults to 'Type N'.</p> <code>'Type N'</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the total shrinkage strain</p> Source code in <code>eurocodepy/ec2/material.py</code> <pre><code>def calc_shrink_strain(t=1000000, h0=100, ts=3, rh=65, fck=20.0, cem='Type N')-&gt;float:\n    \"\"\"Calculates the total shrinkage strain. Uses EN1992-1:2004.\n    This function calculates the total shrinkage strain of concrete based on the time, effective height, time of shrinkage start, relative humidity, concrete compressive strength, and cement type.\n    The shrinkage strain is calculated using the coefficients defined for different cement types and the concrete compressive strength.\n\n    Args:\n        t (int, optional): time, in days. Defaults to 28.\n        h0 (int, optional): effective height, in m. Defaults to 100.\n        ts (int, optional): time of shrinkage start. Defaults to 3.\n        rh (int, optional): relative humidity, in percentage. Defaults to 65.\n        fck (float, optional): concrete compressive strength. Defaults to 20.0.\n        cem (str, optional): cement type. Defaults to 'Type N'.\n\n    Returns:\n        float: the total shrinkage strain\n    \"\"\"\n    fcm = fck+8\n    alpha1 = cemprops[cem][0]\n    alpha2 = cemprops[cem][1]\n\n    eps_ca = 25.0e-6*(fck-10)\n    beta_as = 1.0-math.exp(-0.2*(t**0.5))\n\n    beta_rh = 1.55*(1.0-(rh/100)**3)\n    eps_cd = beta_rh*0.85e-6*((220+110*alpha1)*math.exp(-alpha2*fcm/10.0))\n    beta_ds = (t-ts)/((t-ts)+0.4*h0**1.5)\n\n    return beta_as*eps_ca + beta_ds*eps_cd\n</code></pre>"},{"location":"reference/eurocodepy/ec2/fire/","title":"fire","text":""},{"location":"reference/eurocodepy/ec2/fire/fire_base/","title":"fire_base","text":""},{"location":"reference/eurocodepy/ec2/sls/","title":"sls","text":""},{"location":"reference/eurocodepy/ec2/sls/creep/","title":"creep","text":""},{"location":"reference/eurocodepy/ec2/sls/creep/#eurocodepy.ec2.sls.creep.creep_coef","title":"<code>creep_coef(t, t0, fcm28, RH, hn, t0_T, concrete_class)</code>","text":"<p>Calculates the creep coefficient based on time, initial time, concrete compressive strength, relative humidity, effective height, initial temperature, and concrete class. This function computes the creep coefficient using the coefficients defined for different concrete compressive strengths, relative humidity, and time. The creep coefficient is a measure of the time-dependent deformation of concrete under sustained load. It combines the effects of basic creep and drying creep, adjusted for the initial time and temperature. The function uses the concrete class to determine the adjustment factor for the initial time. The function returns the total creep coefficient as a float value. Uses EN1992-1:2025.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>_type_</code> <p>description</p> required <code>t0</code> <code>_type_</code> <p>description</p> required <code>fcm28</code> <code>_type_</code> <p>description</p> required <code>RH</code> <code>_type_</code> <p>description</p> required <code>hn</code> <code>_type_</code> <p>description</p> required <code>t0_T</code> <code>_type_</code> <p>description</p> required <code>concrete_class</code> <code>_type_</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>eurocodepy/ec2/sls/creep.py</code> <pre><code>def creep_coef(t, t0, fcm28, RH, hn, t0_T, concrete_class):\n    \"\"\"Calculates the creep coefficient based on time, initial time, concrete compressive strength, relative humidity, effective height, initial temperature, and concrete class.\n    This function computes the creep coefficient using the coefficients defined for different concrete compressive strengths, relative humidity, and time.\n    The creep coefficient is a measure of the time-dependent deformation of concrete under sustained load.\n    It combines the effects of basic creep and drying creep, adjusted for the initial time and temperature.\n    The function uses the concrete class to determine the adjustment factor for the initial time.\n    The function returns the total creep coefficient as a float value.\n    Uses EN1992-1:2025.\n\n    Args:\n        t (_type_): _description_\n        t0 (_type_): _description_\n        fcm28 (_type_): _description_\n        RH (_type_): _description_\n        hn (_type_): _description_\n        t0_T (_type_): _description_\n        concrete_class (_type_): _description_\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    alpha_sc_val = alpha_sc(concrete_class)\n    t0_adj_val = t0_adj(t0_T, alpha_sc_val)\n    return varphi_bc(t, t0, fcm28, t0_adj_val) + varphi_dc(t, t0, fcm28, RH, hn, t0_adj_val)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/sls/shrinkage/","title":"shrinkage","text":""},{"location":"reference/eurocodepy/ec2/sls/shrinkage/#eurocodepy.ec2.sls.shrinkage.draw_charts","title":"<code>draw_charts(chart_data)</code>","text":"<p>Draws charts related to creep and shrinkage of concrete.</p> <p>Parameters:</p> Name Type Description Default <code>chart_data</code> <p>A dictionary containing the data for the charts.</p> required Source code in <code>eurocodepy/ec2/sls/shrinkage.py</code> <pre><code>def draw_charts(chart_data):\n    \"\"\"\n    Draws charts related to creep and shrinkage of concrete.\n\n    Args:\n        chart_data: A dictionary containing the data for the charts.\n    \"\"\"\n\n    t_values = chart_data[\"t_values\"]\n    epsilon_cs_values = chart_data[\"epsilon_cs_values\"]\n\n    # Chart 1: Creep and shrinkage over time\n    plt.figure(figsize=(10, 6))\n    plt.plot(t_values, epsilon_cs_values)\n    plt.xlabel(\"Time (days)\")\n    plt.ylabel(\"Creep and Shrinkage (x10^-6)\")\n    plt.title(\"Creep and Shrinkage Over Time\")\n    plt.grid(True)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/sls/shrinkage/#eurocodepy.ec2.sls.shrinkage.generate_chart_data","title":"<code>generate_chart_data(fcm28, RH, hn, concrete_class, alpha_NDP_b, alpha_NDP_d)</code>","text":"<p>Generates data for charts related to creep and shrinkage of concrete.</p> <p>Parameters:</p> Name Type Description Default <code>fcm28</code> <p>Characteristic compressive strength of concrete at 28 days (MPa).</p> required <code>RH</code> <p>Relative humidity (%).</p> required <code>hn</code> <p>Notional size of the concrete member (mm).</p> required <code>concrete_class</code> <p>Class of concrete ('CS', 'CN', or 'CR').</p> required <code>alpha_NDP_b</code> <p>Coefficient depending on type of cement.</p> required <code>alpha_NDP_d</code> <p>Coefficient depending on type of cement.</p> required <p>Returns:</p> Type Description <p>A dictionary containing the data for the charts.</p> Source code in <code>eurocodepy/ec2/sls/shrinkage.py</code> <pre><code>def generate_chart_data(fcm28, RH, hn, concrete_class, alpha_NDP_b, alpha_NDP_d):\n    \"\"\"\n    Generates data for charts related to creep and shrinkage of concrete.\n\n    Args:\n        fcm28: Characteristic compressive strength of concrete at 28 days (MPa).\n        RH: Relative humidity (%).\n        hn: Notional size of the concrete member (mm).\n        concrete_class: Class of concrete ('CS', 'CN', or 'CR').\n        alpha_NDP_b: Coefficient depending on type of cement.\n        alpha_NDP_d: Coefficient depending on type of cement.\n\n    Returns:\n        A dictionary containing the data for the charts.\n    \"\"\"\n\n    t_values = np.linspace(0, 365 * 50, 500)  # Time in days, up to 50 years\n    epsilon_cs_values = []\n\n    for t in t_values:\n        epsilon_cs_values.append(shrink_strain(t, 1, fcm28, RH, hn, concrete_class, alpha_NDP_b, alpha_NDP_d))\n\n    return {\n        \"t_values\": t_values,\n        \"epsilon_cs_values\": epsilon_cs_values,\n    }\n</code></pre>"},{"location":"reference/eurocodepy/ec2/sls/shrinkage/#eurocodepy.ec2.sls.shrinkage.generate_table_data","title":"<code>generate_table_data(fcm28, concrete_class, alpha_NDP_b, alpha_NDP_d)</code>","text":"<p>Generates data for the table related to creep and shrinkage of concrete.</p> <p>Parameters:</p> Name Type Description Default <code>fcm28</code> <p>Characteristic compressive strength of concrete at 28 days (MPa).</p> required <code>concrete_class</code> <p>Class of concrete ('CS', 'CN', or 'CR').</p> required <code>alpha_NDP_b</code> <p>Coefficient depending on type of cement.</p> required <code>alpha_NDP_d</code> <p>Coefficient depending on type of cement.</p> required <p>Returns:</p> Type Description <p>A dictionary containing the data for the table.</p> Source code in <code>eurocodepy/ec2/sls/shrinkage.py</code> <pre><code>def generate_table_data(fcm28, concrete_class, alpha_NDP_b, alpha_NDP_d):\n    \"\"\"\n    Generates data for the table related to creep and shrinkage of concrete.\n\n    Args:\n        fcm28: Characteristic compressive strength of concrete at 28 days (MPa).\n        concrete_class: Class of concrete ('CS', 'CN', or 'CR').\n        alpha_NDP_b: Coefficient depending on type of cement.\n        alpha_NDP_d: Coefficient depending on type of cement.\n\n    Returns:\n        A dictionary containing the data for the table.\n    \"\"\"\n\n    RH_values = [50, 65, 80]\n    t_values = [365]  # You specified t = 365 days\n    hn_values = [100, 300, 500, 700, 1000]\n    table_data = {}\n\n    for RH in RH_values:\n        table_data[RH] = {}\n        for hn in hn_values:\n            epsilon_cs_values = []\n            for t in t_values:\n                epsilon_cs_values.append(shrink_strain(t, 1, fcm28, RH, hn, concrete_class, alpha_NDP_b, alpha_NDP_d)*1000.0)\n            table_data[RH][hn] = epsilon_cs_values * 1000\n\n    return table_data\n</code></pre>"},{"location":"reference/eurocodepy/ec2/sls/shrinkage/#eurocodepy.ec2.sls.shrinkage.print_table","title":"<code>print_table(table_data)</code>","text":"<p>Prints the table related to creep and shrinkage of concrete.</p> <p>Parameters:</p> Name Type Description Default <code>table_data</code> <p>A dictionary containing the data for the table.</p> required Source code in <code>eurocodepy/ec2/sls/shrinkage.py</code> <pre><code>def print_table(table_data):\n    \"\"\"\n    Prints the table related to creep and shrinkage of concrete.\n\n    Args:\n        table_data: A dictionary containing the data for the table.\n    \"\"\"\n\n    RH_values = sorted(table_data.keys())\n    hn_values = sorted(table_data[RH_values[0]].keys())\n\n    # Print header row\n    print(\"RH \\\\ hn\\t\", end=\"\")\n    for hn in hn_values:\n        print(f\"{hn}\\t\", end=\"\")\n    print()\n\n    # Print data rows\n    for RH in RH_values:\n        print(f\"{RH}\\t\", end=\"\")\n        for hn in hn_values:\n            print(f\"{table_data[RH][hn][0]:.2f}\\t\", end=\"\")  # Assuming one t value\n        print()\n</code></pre>"},{"location":"reference/eurocodepy/ec2/sls/shrinkage/#eurocodepy.ec2.sls.shrinkage.shrink_strain","title":"<code>shrink_strain(t, ts, fcm28, RH, hn, concrete_class, alpha_NDP_b, alpha_NDP_d)</code>","text":"<p>Calculates the total shrinkage and creep strain of concrete based on time, initial time, concrete compressive strength, relative humidity, effective height, concrete class, and coefficients for cement type. This function computes the total strain by combining the basic creep strain and drying shrinkage strain, adjusted for the initial time and temperature. The basic creep strain is calculated using the concrete compressive strength and the coefficients for the concrete class. The drying shrinkage strain is calculated using the relative humidity, effective height, and coefficients for the concrete class. The function returns the total strain as a float value. Uses EN1992-1:2025.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>_type_</code> <p>description</p> required <code>ts</code> <code>_type_</code> <p>description</p> required <code>fcm28</code> <code>_type_</code> <p>description</p> required <code>RH</code> <code>_type_</code> <p>description</p> required <code>hn</code> <code>_type_</code> <p>description</p> required <code>concrete_class</code> <code>_type_</code> <p>description</p> required <code>alpha_NDP_b</code> <code>_type_</code> <p>description</p> required <code>alpha_NDP_d</code> <code>_type_</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>eurocodepy/ec2/sls/shrinkage.py</code> <pre><code>def shrink_strain(t, ts, fcm28, RH, hn, concrete_class, alpha_NDP_b, alpha_NDP_d):\n    \"\"\"Calculates the total shrinkage and creep strain of concrete based on time, initial time, concrete compressive strength, relative humidity, effective height, concrete class, and coefficients for cement type.\n    This function computes the total strain by combining the basic creep strain and drying shrinkage strain, adjusted for the initial time and temperature.\n    The basic creep strain is calculated using the concrete compressive strength and the coefficients for the concrete class.\n    The drying shrinkage strain is calculated using the relative humidity, effective height, and coefficients for the concrete class.\n    The function returns the total strain as a float value. Uses EN1992-1:2025.\n\n    Args:\n        t (_type_): _description_\n        ts (_type_): _description_\n        fcm28 (_type_): _description_\n        RH (_type_): _description_\n        hn (_type_): _description_\n        concrete_class (_type_): _description_\n        alpha_NDP_b (_type_): _description_\n        alpha_NDP_d (_type_): _description_\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    alpha_bs, alpha_ds = get_alpha_bs_ds(concrete_class)\n    return epsilon_cbs(t, fcm28, alpha_bs, alpha_NDP_b) + epsilon_cds(t, ts, fcm28, RH, hn, alpha_ds, alpha_NDP_d)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/","title":"uls","text":""},{"location":"reference/eurocodepy/ec2/uls/beam/","title":"beam","text":""},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.RCBeam","title":"<code>RCBeam</code>","text":"Source code in <code>eurocodepy/ec2/uls/beam.py</code> <pre><code>class RCBeam:\n    def __init__(self, b: float, h: float, at: float = 0.05, ac: float = 0.05,\n                conc: str=\"C25/30\", gammac = None, reinf: str=\"B500B\", gammas = None) -&gt; None:\n        \"\"\"_summary_\n\n        Args:\n            b (float): bredth of the beam in m.\n            h (float): height of the beam in m.\n            conc (str, optional): concrete class. Defaults to \"C25/30\".\n            reinf (str, optional): reinforcement lass. Defaults to \"B500B\".\n            at (float, optional): tensile reinforcement mechanical cover. Defaults to 0.05 m.\n            ac (float, optional): compressive reinforcement mechanical cover. Defaults to 0.05 m.\n        \"\"\"\n        self.b = b\n        self.h = h\n        self.conc = conc\n        self.reinf = reinf\n        self.at = at\n        self.ac = ac\n        self.d = self.h - self.at\n        self.fck = ec.ConcreteClasses[self.conc]['fck']\n        self.fyk = ec.ReinforcementClasses[self.reinf]['fyk']\n        self.gammac = gammac if gammac is not None else 1.5\n        self.gammas = gammas if gammas is not None else 1.15\n        self.fcd = self.fck/self.gammac\n        self.fyd = self.fyk/self.gammas\n        return\n\n    def calcShear(self, med: float, ved: float, cott: float = 2.5, iprint: bool=False) -&gt; Tuple[float, float, float]:\n        aslt = 0.0\n        aslc = 0.0\n        alpha = 0.0\n        epsst = 0.0\n        epssc = 0.0\n        asws = 0.0\n        vrdmax = 0.0\n\n        cotetas = np.arange(1.0, 2.5000000000000000000001, 0.1)\n        vrdmaxs = calc_vrdmax(self.b, self.d, self.fck, self.gammac, self.fyk, self.gammas, cotetas)\n        min_val = min(filter(lambda i: i &gt; ved, vrdmaxs))\n\n        asws = calc_asws(self.b, self.d, self.fck, self.gammac, self.fyk,self.gammas, ved)\n        return aslt, aslc, alpha, epsst, epssc, asws, vrdmax\n\n    def calcBending(self, med: float, delta: float = 1.0, iprint: bool=False) -&gt; Tuple[float, float, float, float, float]:\n        \"\"\"Calculates the reinforcement area in a rectangular concrete beam.\n\n        Args:\n            med (float): design bending moment in kNm.\n            delta (float, optional): redistribution ratio (0.7 to 1.0). Defaults to 1.0 (no redistribution).\n            iprint (bool, optional): prints results to stdout. Defaults to False.\n\n        Returns:\n            Tuple[float, float, float, float, float]: reinforcement area in cm2, strain in reinforcement, neutral axis depth.\n        \"\"\"\n\n        # Calculate med_max\n        alpha_c = self.ac/self.d\n        epscu2 = ec.ConcreteClasses[self.conc]['epscu2']\n\n        alpha_lim = 0.45 if self.fck &lt;= 50 else 0.35 # correct this values for fck &gt; 50\n        omega_max = alpha_lim/1.25\n        miu_max = omega_max*(1-0.5*omega_max)\n        med_max = miu_max*self.b*self.d*self.d*self.fck/self.gammac*1000.0\n\n        # Check if miu is less than miu-max and calculate reinforcement accordingly\n        if med &lt;= med_max:\n            # Calculate reinforcement for miu &lt; miu-max\n            aslt, epsst, alpha = calc_asl(self.b, self.d, med, self.fcd, self.fyd, iprint)\n            aslc = None\n            epssc = None\n        else:\n            # Calculate reinforcement for miu = miu-max\n            epsyd = self.fyd/ec.ReinforcementClasses[self.reinf]['Es']*1000\n            # epssc = (alpha_lim-alpha_c)/alpha_lim*epscu2\n            # if epssc &lt; epsyd:\n            #     alpha_lim = epscu2/(epscu2-epsyd)*alpha_c\n            #     omega_max = alpha_lim/1.25\n            #     miu_max = omega_max*(1-0.5*omega_max)\n            #     med_max = miu_max*self.b*self.d*self.d*self.fck/self.gammac*1000.0\n\n            aslt, epsst, alpha = calc_asl(self.b, self.d, med_max, self.fcd, self.fyd, iprint)\n            aslc = (med-med_max)/(self.d-self.ac)/self.fyd*10.0\n            aslt += aslc\n            epssc = (alpha-alpha_c)/alpha*epscu2\n\n\n        return aslt, aslc, alpha, epsst, epssc\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.RCBeam.__init__","title":"<code>__init__(b, h, at=0.05, ac=0.05, conc='C25/30', gammac=None, reinf='B500B', gammas=None)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>float</code> <p>bredth of the beam in m.</p> required <code>h</code> <code>float</code> <p>height of the beam in m.</p> required <code>conc</code> <code>str</code> <p>concrete class. Defaults to \"C25/30\".</p> <code>'C25/30'</code> <code>reinf</code> <code>str</code> <p>reinforcement lass. Defaults to \"B500B\".</p> <code>'B500B'</code> <code>at</code> <code>float</code> <p>tensile reinforcement mechanical cover. Defaults to 0.05 m.</p> <code>0.05</code> <code>ac</code> <code>float</code> <p>compressive reinforcement mechanical cover. Defaults to 0.05 m.</p> <code>0.05</code> Source code in <code>eurocodepy/ec2/uls/beam.py</code> <pre><code>def __init__(self, b: float, h: float, at: float = 0.05, ac: float = 0.05,\n            conc: str=\"C25/30\", gammac = None, reinf: str=\"B500B\", gammas = None) -&gt; None:\n    \"\"\"_summary_\n\n    Args:\n        b (float): bredth of the beam in m.\n        h (float): height of the beam in m.\n        conc (str, optional): concrete class. Defaults to \"C25/30\".\n        reinf (str, optional): reinforcement lass. Defaults to \"B500B\".\n        at (float, optional): tensile reinforcement mechanical cover. Defaults to 0.05 m.\n        ac (float, optional): compressive reinforcement mechanical cover. Defaults to 0.05 m.\n    \"\"\"\n    self.b = b\n    self.h = h\n    self.conc = conc\n    self.reinf = reinf\n    self.at = at\n    self.ac = ac\n    self.d = self.h - self.at\n    self.fck = ec.ConcreteClasses[self.conc]['fck']\n    self.fyk = ec.ReinforcementClasses[self.reinf]['fyk']\n    self.gammac = gammac if gammac is not None else 1.5\n    self.gammas = gammas if gammas is not None else 1.15\n    self.fcd = self.fck/self.gammac\n    self.fyd = self.fyk/self.gammas\n    return\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.RCBeam.calcBending","title":"<code>calcBending(med, delta=1.0, iprint=False)</code>","text":"<p>Calculates the reinforcement area in a rectangular concrete beam.</p> <p>Parameters:</p> Name Type Description Default <code>med</code> <code>float</code> <p>design bending moment in kNm.</p> required <code>delta</code> <code>float</code> <p>redistribution ratio (0.7 to 1.0). Defaults to 1.0 (no redistribution).</p> <code>1.0</code> <code>iprint</code> <code>bool</code> <p>prints results to stdout. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[float, float, float, float, float]</code> <p>Tuple[float, float, float, float, float]: reinforcement area in cm2, strain in reinforcement, neutral axis depth.</p> Source code in <code>eurocodepy/ec2/uls/beam.py</code> <pre><code>def calcBending(self, med: float, delta: float = 1.0, iprint: bool=False) -&gt; Tuple[float, float, float, float, float]:\n    \"\"\"Calculates the reinforcement area in a rectangular concrete beam.\n\n    Args:\n        med (float): design bending moment in kNm.\n        delta (float, optional): redistribution ratio (0.7 to 1.0). Defaults to 1.0 (no redistribution).\n        iprint (bool, optional): prints results to stdout. Defaults to False.\n\n    Returns:\n        Tuple[float, float, float, float, float]: reinforcement area in cm2, strain in reinforcement, neutral axis depth.\n    \"\"\"\n\n    # Calculate med_max\n    alpha_c = self.ac/self.d\n    epscu2 = ec.ConcreteClasses[self.conc]['epscu2']\n\n    alpha_lim = 0.45 if self.fck &lt;= 50 else 0.35 # correct this values for fck &gt; 50\n    omega_max = alpha_lim/1.25\n    miu_max = omega_max*(1-0.5*omega_max)\n    med_max = miu_max*self.b*self.d*self.d*self.fck/self.gammac*1000.0\n\n    # Check if miu is less than miu-max and calculate reinforcement accordingly\n    if med &lt;= med_max:\n        # Calculate reinforcement for miu &lt; miu-max\n        aslt, epsst, alpha = calc_asl(self.b, self.d, med, self.fcd, self.fyd, iprint)\n        aslc = None\n        epssc = None\n    else:\n        # Calculate reinforcement for miu = miu-max\n        epsyd = self.fyd/ec.ReinforcementClasses[self.reinf]['Es']*1000\n        # epssc = (alpha_lim-alpha_c)/alpha_lim*epscu2\n        # if epssc &lt; epsyd:\n        #     alpha_lim = epscu2/(epscu2-epsyd)*alpha_c\n        #     omega_max = alpha_lim/1.25\n        #     miu_max = omega_max*(1-0.5*omega_max)\n        #     med_max = miu_max*self.b*self.d*self.d*self.fck/self.gammac*1000.0\n\n        aslt, epsst, alpha = calc_asl(self.b, self.d, med_max, self.fcd, self.fyd, iprint)\n        aslc = (med-med_max)/(self.d-self.ac)/self.fyd*10.0\n        aslt += aslc\n        epssc = (alpha-alpha_c)/alpha*epscu2\n\n\n    return aslt, aslc, alpha, epsst, epssc\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.calc_asl","title":"<code>calc_asl(b, d, med, fcd=13.7, fyd=348.0, iprint=False)</code>","text":"<p>Calculates the reinforcement in a rectangular concrete beam.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>float</code> <p>bredth of the beam in m.</p> required <code>d</code> <code>float</code> <p>depth of the reinforced in beam in m.</p> required <code>med</code> <code>float</code> <p>bending moment in kNm.</p> required <code>fcd</code> <code>float</code> <p>concrete strength in MPa. Defaults to 20.0.</p> <code>13.7</code> <code>fyd</code> <code>float</code> <p>reinforcement strength in MPa. Defaults to 400.0.</p> <code>348.0</code> <code>iprint</code> <code>bool</code> <p>print results. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[float, float, float]</code> <p>Tuple[float, float, float, float]: reinforcement area in cm2, strain in reinforcement, neutral axis depth, omega.</p> Source code in <code>eurocodepy/ec2/uls/beam.py</code> <pre><code>def calc_asl(b: float, d: float, med: float, fcd: float=13.7, fyd: float=348.0, iprint: bool=False) -&gt; Tuple[float, float, float]:\n    \"\"\"Calculates the reinforcement in a rectangular concrete beam.\n\n    Args:\n        b (float): bredth of the beam in m.\n        d (float): depth of the reinforced in beam in m.\n        med (float): bending moment in kNm.\n        fcd (float, optional): concrete strength in MPa. Defaults to 20.0.\n        fyd (float, optional): reinforcement strength in MPa. Defaults to 400.0.\n        iprint (bool, optional): print results. Defaults to False.\n\n    Returns:\n        Tuple[float, float, float, float]: reinforcement area in cm2, strain in reinforcement, neutral axis depth, omega.\n    \"\"\"\n    mmed = med\n    bb = b\n    dd = d\n    miu = mmed/bb/d**2/fcd/1000.0\n    try:\n        omega = 1.0-math.sqrt(1-2*miu)\n    except:\n        omega = math.nan\n    alpha = 1.25*omega\n    ast = omega*b*d*fcd/fyd * 10000.0\n    epss = (1.0-alpha)*3.5/alpha\n    if iprint: \n        print(\"miu={:.3f} omega={:.3f} x/d={:.3f} eps-s={:.3f} As={:.2f} cm2\".format(miu, round(omega,3), alpha, epss, ast))\n    return ast, epss, alpha\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.calc_asws","title":"<code>calc_asws(bw, d, fck, g_c, fyk, g_s, cott, ved, alpha)</code>","text":"<p>Calculates the design shear reinforcement</p> <p>Parameters:</p> Name Type Description Default <code>bw</code> <code>float</code> <p>beam width</p> required <code>d</code> <code>float</code> <p>beam depth</p> required <code>fck</code> <code>float</code> <p>concrete compressive strength</p> required <code>g_c</code> <code>float</code> <p>concrete partial safety coefficient</p> required <code>fyk</code> <code>float</code> <p>steel strength</p> required <code>g_s</code> <code>float</code> <p>steel partial safety coefficient</p> required <code>cott</code> <code>float</code> <p>truss inclination (cot)</p> required <code>ved</code> <code>float</code> <p>design shear force</p> required <code>alpha</code> <code>float</code> <p>coefficient</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple[float, float]: (shear reinforcement (Asw/s), maximum shear force Vrd.max)</p> Source code in <code>eurocodepy/ec2/uls/beam.py</code> <pre><code>def calc_asws(bw: float, d: float, fck: float, g_c: float, fyk: float, g_s: float, cott: float, ved: float, alpha: float) -&gt; Tuple[float, float]:\n    \"\"\"Calculates the design shear reinforcement\n\n    Args:\n        bw (float): beam width\n        d (float): beam depth\n        fck (float): concrete compressive strength\n        g_c (float): concrete partial safety coefficient\n        fyk (float): steel strength\n        g_s (float): steel partial safety coefficient\n        cott (float): truss inclination (cot)\n        ved (float): design shear force\n        alpha (float): coefficient\n\n    Returns:\n        Tuple[float, float]: (shear reinforcement (Asw/s), maximum shear force Vrd.max)\n    \"\"\"\n    z = 0.9 * d\n    niu = 0.6*(1.0-fck/250)\n    vrd_max = bw * z * niu * fck / g_c * 1000.0 / (cott + 1.0/cott)\n\n    asw_s = ved / z / fyk * g_s / cott / 1000.0 if vrd_max &gt;= ved else math.nan\n    return asw_s, vrd_max\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.calc_mrd","title":"<code>calc_mrd(b, d, ast, fcd=20.0, fyd=400.0, iprint=False)</code>","text":"<p>Calculates the bending moment in a rectangular concrete beam.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>float</code> <p>bredth of the beam in m.</p> required <code>d</code> <code>float</code> <p>depth of the reinforced in beam in m.</p> required <code>ast</code> <code>float</code> <p>reinforcement area in cm2.</p> required <code>fcd</code> <code>float</code> <p>concrete strength in MPa. Defaults to 20.0.</p> <code>20.0</code> <code>fyd</code> <code>float</code> <p>reinforcement strength in MPa. Defaults to 400.0.</p> <code>400.0</code> <code>iprint</code> <code>bool</code> <p>print results. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[float, float, float]</code> <p>Tuple[float, float, float]: bending moment in kNm, strain in reinforcement, neutral axis depth.</p> Source code in <code>eurocodepy/ec2/uls/beam.py</code> <pre><code>def calc_mrd(b: float, d: float, ast: float, fcd: float=20.0, fyd: float=400.0, iprint: bool=False) -&gt; Tuple[float, float, float]:\n    \"\"\"Calculates the bending moment in a rectangular concrete beam.\n\n    Args:\n        b (float): bredth of the beam in m.\n        d (float): depth of the reinforced in beam in m.\n        ast (float): reinforcement area in cm2.\n        fcd (float, optional): concrete strength in MPa. Defaults to 20.0.\n        fyd (float, optional): reinforcement strength in MPa. Defaults to 400.0.\n        iprint (bool, optional): print results. Defaults to False.\n\n    Returns:\n        Tuple[float, float, float]: bending moment in kNm, strain in reinforcement, neutral axis depth.\n    \"\"\"\n    omega = ast*fyd/b/d/fcd/10000.0\n    miu = omega*(1-0.5*omega)\n    alpha = 1.25*omega\n    epss = (1.0-alpha)*3.5/alpha\n    mrd = miu*b*d*d*fcd*1000\n    if iprint: \n        print(\"med={:.1f} kNm; miu={:.3f}; omega={:.3f}\".format(mrd, round(miu,3), round(omega,3)))\n    return mrd, epss, alpha\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.calc_vrd","title":"<code>calc_vrd(bw, d, fck, g_c, fyk, g_s, cott, asw_s, alpha)</code>","text":"<p>Calculates the design shear strength Vrds and Vrd.max</p> <p>Parameters:</p> Name Type Description Default <code>bw</code> <code>float</code> <p>beam width</p> required <code>d</code> <code>float</code> <p>beam depth</p> required <code>fck</code> <code>float</code> <p>concrete compressive strength</p> required <code>g_c</code> <code>float</code> <p>concrete partial safety coefficient</p> required <code>fyk</code> <code>float</code> <p>steel strength</p> required <code>g_s</code> <code>float</code> <p>steel partial safety coefficient</p> required <code>cott</code> <code>float</code> <p>truss inclination (cot)</p> required <code>asw_s</code> <code>float</code> <p>steel transverse area (Asw/s)</p> required <code>alpha</code> <code>float</code> <p>coefficient</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>(shear reinforcement max(Asw/s), Vrd.max)</p> Source code in <code>eurocodepy/ec2/uls/beam.py</code> <pre><code>def calc_vrd(bw: float, d: float, fck: float, g_c: float, fyk: float, g_s: float, cott: float, asw_s: float, alpha: float) -&gt; float:\n    \"\"\"Calculates the design shear strength Vrds and Vrd.max\n\n    Args:\n        bw (float): beam width\n        d (float): beam depth\n        fck (float): concrete compressive strength\n        g_c (float): concrete partial safety coefficient\n        fyk (float): steel strength\n        g_s (float): steel partial safety coefficient\n        cott (float): truss inclination (cot)\n        asw_s (float): steel transverse area (Asw/s)\n        alpha (float): coefficient\n\n    Returns:\n        float: (shear reinforcement max(Asw/s), Vrd.max)\n    \"\"\"\n    z = 0.9 * d\n    vrd_s = asw_s * z * fyk / g_s * cott * 1000.0\n    niu = 0.6*(1.0-fck/250)\n    vrd_max = bw * z * niu * fck / g_c * 100.0 / (cott + 1.0/cott)\n    return max(vrd_s, vrd_max)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.calc_vrdc","title":"<code>calc_vrdc(bw, d, fck, g_c, rho_l)</code>","text":"<p>Shear strength without shear reinforcement</p> <p>Parameters:</p> Name Type Description Default <code>bw</code> <code>float</code> <p>beam width</p> required <code>d</code> <code>float</code> <p>beam depth</p> required <code>fck</code> <code>float</code> <p>concrete compressive strength</p> required <code>g_c</code> <code>float</code> <p>concrete partial safety coefficient</p> required <code>rho_l</code> <code>float</code> <p>longitudinal reinforcement ratio (As/bd)</p> required <p>Returns:</p> Type Description <code>Tuple[float, float, float]</code> <p>Tuple[float, float, float]: (vrd.min, vrd.c, vrd [min(vrd.mmin, vrd.c])</p> Source code in <code>eurocodepy/ec2/uls/beam.py</code> <pre><code>def calc_vrdc(bw: float, d: float, fck: float, g_c: float, rho_l: float) -&gt; Tuple[float, float, float]:\n    \"\"\"Shear strength without shear reinforcement\n\n    Args:\n        bw (float): beam width\n        d (float): beam depth\n        fck (float): concrete compressive strength\n        g_c (float): concrete partial safety coefficient\n        rho_l (float): longitudinal reinforcement ratio (As/bd)\n\n    Returns:\n        Tuple[float, float, float]: (vrd.min, vrd.c, vrd [min(vrd.mmin, vrd.c])\n    \"\"\"\n    k = min(2.0, 1.0+math.sqrt(0.2/d))\n    vrd_min = 35.0 * math.pow(k, 1.5) * math.sqrt(fck) * bw * d\n    vrd_c = 180.0 / g_c * k * (100.0*rho_l*fck)**(1.0/3.0) * bw * d\n    vrd = max (vrd_min, vrd_c)\n    return vrd_min, vrd_c, vrd\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.calc_vrdmax","title":"<code>calc_vrdmax(bw, d, fck, g_c, fyk, g_s, cott)</code>","text":"<p>Calculates the design shear strength Vrd.max</p> <p>Parameters:</p> Name Type Description Default <code>bw</code> <code>float</code> <p>beam width</p> required <code>d</code> <code>float</code> <p>beam depth</p> required <code>fck</code> <code>float</code> <p>concrete compressive strength</p> required <code>g_c</code> <code>float</code> <p>concrete partial safety coefficient</p> required <code>fyk</code> <code>float</code> <p>steel strength</p> required <code>g_s</code> <code>float</code> <p>steel partial safety coefficient</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Vrd.max</p> Source code in <code>eurocodepy/ec2/uls/beam.py</code> <pre><code>def calc_vrdmax(bw: float, d: float, fck: float, g_c: float, fyk: float, g_s: float, cott: float) -&gt; float:\n    \"\"\"Calculates the design shear strength Vrd.max\n\n    Args:\n        bw (float): beam width\n        d (float): beam depth\n        fck (float): concrete compressive strength\n        g_c (float): concrete partial safety coefficient\n        fyk (float): steel strength\n        g_s (float): steel partial safety coefficient\n\n    Returns:\n        float: Vrd.max\n    \"\"\"\n    return bw * 0.9 * d * 0.6*(1.0-fck/250) * fck / g_c * 100.0 / (cott + 1.0/cott)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/bend_circ/","title":"bend_circ","text":""},{"location":"reference/eurocodepy/ec2/uls/shear/","title":"shear","text":""},{"location":"reference/eurocodepy/ec2/uls/shear/#eurocodepy.ec2.uls.shear.calc_asws","title":"<code>calc_asws(bw, d, fck, g_c, fyk, g_s, cott, ved, alpha)</code>","text":"<p>Calculates the design shear reinforcement</p> <p>Parameters:</p> Name Type Description Default <code>bw</code> <code>float</code> <p>beam width</p> required <code>d</code> <code>float</code> <p>beam depth</p> required <code>fck</code> <code>float</code> <p>concrete compressive strength</p> required <code>g_c</code> <code>float</code> <p>concrete partial safety coefficient</p> required <code>fyk</code> <code>float</code> <p>steel strength</p> required <code>g_s</code> <code>float</code> <p>steel partial safety coefficient</p> required <code>cott</code> <code>float</code> <p>truss inclination (cot)</p> required <code>ved</code> <code>float</code> <p>design shear force</p> required <code>alpha</code> <code>float</code> <p>coefficient</p> required <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple[float, float]: (shear reinforcement (Asw/s), maximum shear force Vrd.max)</p> Source code in <code>eurocodepy/ec2/uls/shear.py</code> <pre><code>def calc_asws(bw: float, d: float, fck: float, g_c: float, fyk: float, g_s: float, cott: float, ved: float, alpha: float) -&gt; Tuple[float, float]:\n    \"\"\"Calculates the design shear reinforcement\n\n    Args:\n        bw (float): beam width\n        d (float): beam depth\n        fck (float): concrete compressive strength\n        g_c (float): concrete partial safety coefficient\n        fyk (float): steel strength\n        g_s (float): steel partial safety coefficient\n        cott (float): truss inclination (cot)\n        ved (float): design shear force\n        alpha (float): coefficient\n\n    Returns:\n        Tuple[float, float]: (shear reinforcement (Asw/s), maximum shear force Vrd.max)\n    \"\"\"\n    z = 0.9 * d\n    niu = 0.6*(1.0-fck/250)\n    vrd_max = bw * z * niu * fck / g_c * 1000.0 / (cott + 1.0/cott)\n\n    asw_s = ved / z / fyk * g_s / cott / 1000.0 if vrd_max &gt;= ved else math.nan\n    return asw_s, vrd_max\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/shear/#eurocodepy.ec2.uls.shear.calc_vrd","title":"<code>calc_vrd(bw, d, fck, g_c, fyk, g_s, cott, asw_s, alpha)</code>","text":"<p>Calculates the design shear strength Vrds and Vrd.max</p> <p>Parameters:</p> Name Type Description Default <code>bw</code> <code>float</code> <p>beam width</p> required <code>d</code> <code>float</code> <p>beam depth</p> required <code>fck</code> <code>float</code> <p>concrete compressive strength</p> required <code>g_c</code> <code>float</code> <p>concrete partial safety coefficient</p> required <code>fyk</code> <code>float</code> <p>steel strength</p> required <code>g_s</code> <code>float</code> <p>steel partial safety coefficient</p> required <code>cott</code> <code>float</code> <p>truss inclination (cot)</p> required <code>asw_s</code> <code>float</code> <p>steel transverse area (Asw/s)</p> required <code>alpha</code> <code>float</code> <p>coefficient</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>(shear reinforcement max(Asw/s), Vrd.max)</p> Source code in <code>eurocodepy/ec2/uls/shear.py</code> <pre><code>def calc_vrd(bw: float, d: float, fck: float, g_c: float, fyk: float, g_s: float, cott: float, asw_s: float, alpha: float) -&gt; float:\n    \"\"\"Calculates the design shear strength Vrds and Vrd.max\n\n    Args:\n        bw (float): beam width\n        d (float): beam depth\n        fck (float): concrete compressive strength\n        g_c (float): concrete partial safety coefficient\n        fyk (float): steel strength\n        g_s (float): steel partial safety coefficient\n        cott (float): truss inclination (cot)\n        asw_s (float): steel transverse area (Asw/s)\n        alpha (float): coefficient\n\n    Returns:\n        float: (shear reinforcement max(Asw/s), Vrd.max)\n    \"\"\"\n    z = 0.9 * d\n    vrd_s = asw_s * z * fyk / g_s * cott * 1000.0\n    niu = 0.6*(1.0-fck/250)\n    vrd_max = bw * z * niu * fck / g_c * 100.0 / (cott + 1.0/cott)\n    return max(vrd_s, vrd_max)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/shear/#eurocodepy.ec2.uls.shear.calc_vrdc","title":"<code>calc_vrdc(bw, d, fck, g_c, rho_l)</code>","text":"<p>Shear strength without shear reinforcement</p> <p>Parameters:</p> Name Type Description Default <code>bw</code> <code>float</code> <p>beam width</p> required <code>d</code> <code>float</code> <p>beam depth</p> required <code>fck</code> <code>float</code> <p>concrete compressive strength</p> required <code>g_c</code> <code>float</code> <p>concrete partial safety coefficient</p> required <code>rho_l</code> <code>float</code> <p>longitudinal reinforcement ratio (As/bd)</p> required <p>Returns:</p> Type Description <code>Tuple[float, float, float]</code> <p>Tuple[float, float, float]: (vrd.min, vrd.c, vrd [min(vrd.mmin, vrd.c])</p> Source code in <code>eurocodepy/ec2/uls/shear.py</code> <pre><code>def calc_vrdc(bw: float, d: float, fck: float, g_c: float, rho_l: float) -&gt; Tuple[float, float, float]:\n    \"\"\"Shear strength without shear reinforcement\n\n    Args:\n        bw (float): beam width\n        d (float): beam depth\n        fck (float): concrete compressive strength\n        g_c (float): concrete partial safety coefficient\n        rho_l (float): longitudinal reinforcement ratio (As/bd)\n\n    Returns:\n        Tuple[float, float, float]: (vrd.min, vrd.c, vrd [min(vrd.mmin, vrd.c])\n    \"\"\"\n    k = min(2.0, 1.0+math.sqrt(0.2/d))\n    vrd_min = 35.0 * math.pow(k, 1.5) * math.sqrt(fck) * bw * d\n    vrd_c = 180.0 / g_c * k * (100.0*rho_l*fck)**(1.0/3.0) * bw * d\n    vrd = max (vrd_min, vrd_c)\n    return vrd_min, vrd_c, vrd\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/shear/#eurocodepy.ec2.uls.shear.calc_vrdmax","title":"<code>calc_vrdmax(bw, d, fck, g_c, fyk, g_s, cott)</code>","text":"<p>Calculates the design shear strength Vrd.max</p> <p>Parameters:</p> Name Type Description Default <code>bw</code> <code>float</code> <p>beam width</p> required <code>d</code> <code>float</code> <p>beam depth</p> required <code>fck</code> <code>float</code> <p>concrete compressive strength</p> required <code>g_c</code> <code>float</code> <p>concrete partial safety coefficient</p> required <code>fyk</code> <code>float</code> <p>steel strength</p> required <code>g_s</code> <code>float</code> <p>steel partial safety coefficient</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Vrd.max</p> Source code in <code>eurocodepy/ec2/uls/shear.py</code> <pre><code>def calc_vrdmax(bw: float, d: float, fck: float, g_c: float, fyk: float, g_s: float, cott: float) -&gt; float:\n    \"\"\"Calculates the design shear strength Vrd.max\n\n    Args:\n        bw (float): beam width\n        d (float): beam depth\n        fck (float): concrete compressive strength\n        g_c (float): concrete partial safety coefficient\n        fyk (float): steel strength\n        g_s (float): steel partial safety coefficient\n\n    Returns:\n        float: Vrd.max\n    \"\"\"\n    return bw * 0.9 * d * 0.6*(1.0-fck/250) * fck / g_c * 100.0 / (cott + 1.0/cott)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/shell/","title":"shell","text":""},{"location":"reference/eurocodepy/ec2/uls/shell/#eurocodepy.ec2.uls.shell.calc_reinf_plane","title":"<code>calc_reinf_plane(n_xx, n_yy, n_xy)</code>","text":"<p>Calculate the reinforcement in a plane element.</p> <p>Parameters:</p> Name Type Description Default <code>n_xx</code> <code>float</code> <p>axial force in x direction</p> required <code>n_yy</code> <code>float</code> <p>axial force in y direction</p> required <code>n_xy</code> <code>float</code> <p>shear force in xy direction</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>the reinforecment in both diretions and concrete stresses</p> Source code in <code>eurocodepy/ec2/uls/shell.py</code> <pre><code>def calc_reinf_plane(n_xx: float, n_yy:float, n_xy: float)-&gt;list:\n    \"\"\"Calculate the reinforcement in a plane element.\n\n    Args:\n        n_xx (float): axial force in x direction\n        n_yy (float): axial force in y direction\n        n_xy (float): shear force in xy direction\n\n    Returns:\n        list: the reinforecment in both diretions and concrete stresses\n    \"\"\"\n    abs_n_xy = abs(n_xy)\n    n_xx_n_yy = n_xx * n_yy\n    n_xy_2 = n_xy * n_xy\n    if n_xx &gt;= -abs_n_xy and n_yy &gt;= -abs_n_xy:\n        theta = 1.0\n        asx = n_xx + abs_n_xy\n        asy = n_yy + abs_n_xy\n        asc = 2.0 * abs_n_xy\n    elif n_xx &lt; -abs_n_xy and n_xx &lt;= n_yy and n_xx_n_yy &lt;= n_xy_2:\n        theta = 0 if abs_n_xy &lt; 1.0e-12 else -n_xx / abs_n_xy\n        asx = 0.0\n        asy = n_yy + n_xy_2 / abs(n_xx)\n        asc = abs(n_xx) * (1.0 + (abs_n_xy/n_xx)**2)\n    elif n_yy &lt; -abs_n_xy and n_xx &gt;= n_yy and n_xx_n_yy &lt;= n_xy_2:\n        theta = -abs_n_xy / n_yy\n        asx = n_xx + n_xy_2 / abs(n_yy)\n        asy = 0.0\n        asc = abs(n_yy) * (1.0 + (abs_n_xy/n_yy)**2)\n    else:\n        cen = (n_xx + n_yy) * 0.5\n        rad = math.sqrt(n_xy_2+0.25*(n_xx-n_yy)**2)\n        theta = math.atan2(n_xx-n_yy, 2*n_xy) / 2.0\n        theta = 0 if theta == 0 else 1.0/math.tan(theta)\n        asx = 0.0\n        asy = 0.0\n        asc = abs(cen - rad)\n\n    return [asx, asy, asc, theta]\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/shell/#eurocodepy.ec2.uls.shell.calc_reinf_shell","title":"<code>calc_reinf_shell(n_xx, n_yy, n_xy, m_xx, m_yy, m_xy, rec, h)</code>","text":"<p>Calculate the forces to ccalculate the reinforcement in a shell element.</p> <p>Parameters:</p> Name Type Description Default <code>n_xx</code> <code>float</code> <p>axial force in x direction</p> required <code>n_yy</code> <code>float</code> <p>axial force in y direction</p> required <code>n_xy</code> <code>float</code> <p>shear force in xy direction</p> required <code>m_xx</code> <code>float</code> <p>moment in x direction (bending)</p> required <code>m_yy</code> <code>float</code> <p>moment in y direction (bending)</p> required <code>m_xy</code> <code>float</code> <p>moment in xy direction (torsion)</p> required <code>rec</code> <code>float</code> <p>cover to reinforcement</p> required <code>h</code> <code>float</code> <p>height of the shell</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.array: the reinforecment in both diretions in top and bottom layer and concrete stresses</p> Source code in <code>eurocodepy/ec2/uls/shell.py</code> <pre><code>def calc_reinf_shell(n_xx: float, n_yy: float, n_xy: float, m_xx: float, m_yy: float, m_xy: float,\n            rec: float, h: float) -&gt; np.ndarray:\n    \"\"\"Calculate the forces to ccalculate the reinforcement in a shell element.\n\n    Args:\n        n_xx (float): axial force in x direction\n        n_yy (float): axial force in y direction\n        n_xy (float): shear force in xy direction\n        m_xx (float): moment in x direction (bending)\n        m_yy (float): moment in y direction (bending)\n        m_xy (float): moment in xy direction (torsion)\n        rec (float): cover to reinforcement\n        h (float): height of the shell\n\n    Returns:\n        np.array: the reinforecment in both diretions in top and bottom layer and concrete stresses\n    \"\"\"\n\n    t = 2 * rec\n    z = h - t\n    if h - 4 * rec &lt; 0: return np.array([math.nan,math.nan,math.nan,math.nan,math.nan,math.nan])\n\n    n_t_xx = (0.5*n_xx + m_xx/z) / t\n    n_t_yy = (0.5*n_yy + m_yy/z) / t\n    n_t_xy = (0.5*n_xy - m_xy/z) / t\n\n    n_b_xx = (0.5*n_xx - m_xx/z) / t\n    n_b_yy = (0.5*n_yy - m_yy/z) / t\n    n_b_xy = (0.5*n_xy + m_xy/z) / t\n\n    as_vect = np.vectorize(cal_reinf_shell_plan, otypes=[np.ndarray])\n    as_total = as_vect(n_t_xx, n_t_yy, n_t_xy, n_b_xx, n_b_yy, n_b_xy)\n    return as_total\n</code></pre>"},{"location":"reference/eurocodepy/ec3/","title":"ec3","text":""},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.ProfileType","title":"<code>ProfileType = Enum('ProfileType', db.SteelProfiles)</code>  <code>module-attribute</code>","text":"<p>Eurocode 3 steel classes existing in the databse.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.Steel","title":"<code>Steel</code>","text":"<p>Eurocode 3 steel reinforcement properties. :param type_label: Steel type label (e.g., 'S235', 'S275', 'S355', 'S460') :raises ValueError: If the steel type is not found in the database.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>class Steel:\n    \"\"\"\n    Eurocode 3 steel reinforcement properties.\n    :param type_label: Steel type label (e.g., 'S235', 'S275', 'S355', 'S460')\n    :raises ValueError: If the steel type is not found in the database.\n    \"\"\"\n\n    def __init__(self, type_label: str = \"S275\"):        \n        if type_label not in db.ReinforcementGrades.keys():\n            raise ValueError(f\"Steel type '{type_label}' not found in database. Steel type must be one of {list(db.ReinforcementGrades.keys())}\")\n\n        reinf = db.ReinforcementGrades[type_label]\n        self.fyk = reinf[\"fyk\"] # Characteristic yield strength (MPa)\n        self.epsilon_uk = reinf[\"epsuk\"] # Ultimate strain (\u2030)\n        self.ftk = reinf[\"ftk\"] # Characteristic tensile strength (MPa)\n        self.Es = reinf[\"Es\"] # Modulus of elasticity (MPa)\n        self.ClassType = reinf[\"T\"] # 'A', 'B', or 'C'\n\n        gamma_s = db.ReinforcementParams[\"gamma_s\"]  # Partial safety factor\n        self.fyd = round(self.fyk / gamma_s, 1)  # Design yield strength (MPa)\n</code></pre>"},{"location":"reference/eurocodepy/ec5/","title":"ec5","text":""},{"location":"reference/eurocodepy/ec5/#eurocodepy.ec5.Glulam","title":"<code>Glulam</code>","text":"<p>               Bases: <code>Timber</code></p> <p>Eurocode 5 glulam properties. :param type_label: Glulam type label (e.g., 'GL24h', 'GL28c')</p> Source code in <code>eurocodepy/ec5/__init__.py</code> <pre><code>class Glulam(Timber):\n    \"\"\"\n    Eurocode 5 glulam properties.\n    :param type_label: Glulam type label (e.g., 'GL24h', 'GL28c')\n    \"\"\"\n\n    def __init__(self, type_label: str = \"GL24h\"):\n        grades_list = [item for item in db.TimberGrades.keys() if item.startswith(\"GL\")]\n\n        if not type_label.startswith(\"GL\"):\n            raise ValueError(f\"Glulam type '{type_label}' must start with 'GL'. Glulam type must be one of {grades_list}\")\n        if type_label not in grades_list:\n            raise ValueError(f\"Glulam type '{type_label}' not found in database. Glulam type must be one of {grades_list}\")\n\n        super().__init__(type_label)\n\n        self.fvrefk = db.TimberParams[\"fvrefk\"][self.type]\n        self.theta_twist = db.TimberParams[\"theta_twist\"][self.type]\n        self.kred = db.TimberParams[\"kred\"][self.type]\n</code></pre>"},{"location":"reference/eurocodepy/ec5/#eurocodepy.ec5.SolidTimber","title":"<code>SolidTimber</code>","text":"<p>               Bases: <code>Timber</code></p> <p>This class represents Eurocode 5 solid timber properties, which includes both softwood and hardwood types.</p> <p>Parameters:</p> Name Type Description Default <code>type_label</code> <code>str</code> <p>Timber grade label (e.g., 'C24', 'D30'). Defaults to 'C24'.</p> <code>'C24'</code> Source code in <code>eurocodepy/ec5/__init__.py</code> <pre><code>class SolidTimber(Timber):\n    \"\"\"This class represents Eurocode 5 solid timber properties, which includes both softwood and hardwood types.\n\n    Args:\n        type_label (str): Timber grade label (e.g., 'C24', 'D30'). Defaults to 'C24'.\n    \"\"\"\n\n    def __init__(self, type_label: str = \"C24\"):\n        grades_list = [item for item in db.TimberGrades.keys() if (item.startswith(\"C\") or item.startswith(\"D\"))]\n        if type_label not in grades_list:\n            raise ValueError(f\"Softwood type '{type_label}' not found in database. Softwood type must be one of {grades_list}\")\n\n        super().__init__(type_label)\n\n        self.fvrefk = db.TimberParams[\"fvrefk\"][self.type]\n        self.theta_twist = db.TimberParams[\"theta_twist\"][self.type]\n        self.kred = db.TimberParams[\"kred\"][self.type]\n</code></pre>"},{"location":"reference/eurocodepy/ec5/#eurocodepy.ec5.Timber","title":"<code>Timber</code>","text":"<p>Eurocode 5 timber properties.</p> Source code in <code>eurocodepy/ec5/__init__.py</code> <pre><code>class Timber:\n    \"\"\"\n    Eurocode 5 timber properties.\n    \"\"\"\n    def __init__(self, type_label: str = \"C24\"):\n\n        if type_label not in db.TimberGrades.keys():\n            raise ValueError(f\"Steel type '{type_label}' not found in database. Steel type must be one of {list(db.TimberGrades.keys())}\")\n\n        timber = db.TimberGrades[type_label]\n        self.fmk = timber[\"fmk\"]  # Characteristic strength in MPa\n        self.ft0k = timber[\"ft0k\"] # Characteristic strength in tension parallel to grain (MPa)\n        self.ft90k = timber[\"ft90k\"]  # Characteristic strength in tension perpendicular to grain (MPa)\n        self.fc0k = timber[\"fc0k\"]  # Characteristic strength in compression parallel to grain (MPa)\n        self.fc90k = timber[\"fc90k\"]  # Characteristic strength in compression perpendicular to grain (MPa)\n        self.fvk = timber[\"fvk\"]  # Characteristic shear strength (MPa)\n        self.E0mean = timber[\"E0mean\"]  # Mean modulus of elasticity in MPa\n        self.E0k = timber[\"E0k\"]  # Characteristic modulus of elasticity in MPa\n        self.E90k = timber[\"E90k\"]  # Characteristic modulus of elasticity perpendicular to grain (MPa)\n        self.Gmean = timber[\"Gmean\"]  # Mean shear modulus in MPa\n        self.rhok = timber[\"rhok\"] # Characteristic density in kg/m\u00b3\n        self.rhom = timber[\"rhom\"] # Mean density in kg/m\u00b3\n        self.type_label = type_label\n        self.type = timber[\"Type\"]\n\n        self.safety = db.TimberParams[\"safety\"][self.type]  # Partial safety factor\n        self.kmod = db.TimberParams[\"kmod\"][self.type]\n        self.kdef = db.TimberParams[\"kmod\"][self.type]\n        self.kh = db.TimberParams[\"kh\"][self.type]\n\n    def k_mod(self, service_class: ServiceClass = ServiceClass.SC1, load_duratiom: LoadDuration = LoadDuration.Medium) -&gt; float:\n        \"\"\" Returns the kmod value for serviceability limit state.\n\n        Args:\n            service_class (ServiceClass, optional): Service class (SC1, SC2, or SC3). Defaults to ServiceClass.SC1.\n            load_duratiom (LoadDuration, optional): Load duration (Perm, Long, Medium, Short, Inst). Defaults to LoadDuration.Medium.\n\n        Returns:\n            float: kmod value for the specified service class and load duration.\n        \"\"\"\n        return self.kmod[service_class.name][load_duratiom.value]\n\n    def k_def(self, service_class: ServiceClass = ServiceClass.SC1) -&gt; float:\n        \"\"\"Returns the kdef value for serviceability limit state.\n\n        Args:\n            service_class (ServiceClass, optional): Service class (SC1, SC2, or SC3). Defaults to ServiceClass.SC1.\n\n        Returns:\n            float: kmod value for the specified service class.\n        \"\"\"\n        return self.kdef[service_class.name]\n</code></pre>"},{"location":"reference/eurocodepy/ec5/#eurocodepy.ec5.Timber.k_def","title":"<code>k_def(service_class=ServiceClass.SC1)</code>","text":"<p>Returns the kdef value for serviceability limit state.</p> <p>Parameters:</p> Name Type Description Default <code>service_class</code> <code>ServiceClass</code> <p>Service class (SC1, SC2, or SC3). Defaults to ServiceClass.SC1.</p> <code>SC1</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>kmod value for the specified service class.</p> Source code in <code>eurocodepy/ec5/__init__.py</code> <pre><code>def k_def(self, service_class: ServiceClass = ServiceClass.SC1) -&gt; float:\n    \"\"\"Returns the kdef value for serviceability limit state.\n\n    Args:\n        service_class (ServiceClass, optional): Service class (SC1, SC2, or SC3). Defaults to ServiceClass.SC1.\n\n    Returns:\n        float: kmod value for the specified service class.\n    \"\"\"\n    return self.kdef[service_class.name]\n</code></pre>"},{"location":"reference/eurocodepy/ec5/#eurocodepy.ec5.Timber.k_mod","title":"<code>k_mod(service_class=ServiceClass.SC1, load_duratiom=LoadDuration.Medium)</code>","text":"<p>Returns the kmod value for serviceability limit state.</p> <p>Parameters:</p> Name Type Description Default <code>service_class</code> <code>ServiceClass</code> <p>Service class (SC1, SC2, or SC3). Defaults to ServiceClass.SC1.</p> <code>SC1</code> <code>load_duratiom</code> <code>LoadDuration</code> <p>Load duration (Perm, Long, Medium, Short, Inst). Defaults to LoadDuration.Medium.</p> <code>Medium</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>kmod value for the specified service class and load duration.</p> Source code in <code>eurocodepy/ec5/__init__.py</code> <pre><code>def k_mod(self, service_class: ServiceClass = ServiceClass.SC1, load_duratiom: LoadDuration = LoadDuration.Medium) -&gt; float:\n    \"\"\" Returns the kmod value for serviceability limit state.\n\n    Args:\n        service_class (ServiceClass, optional): Service class (SC1, SC2, or SC3). Defaults to ServiceClass.SC1.\n        load_duratiom (LoadDuration, optional): Load duration (Perm, Long, Medium, Short, Inst). Defaults to LoadDuration.Medium.\n\n    Returns:\n        float: kmod value for the specified service class and load duration.\n    \"\"\"\n    return self.kmod[service_class.name][load_duratiom.value]\n</code></pre>"},{"location":"reference/eurocodepy/ec5/sls/","title":"sls","text":""},{"location":"reference/eurocodepy/ec5/sls/deformation/","title":"deformation","text":""},{"location":"reference/eurocodepy/ec5/sls/vibration/","title":"vibration","text":""},{"location":"reference/eurocodepy/ec7/","title":"ec7","text":"<p>Eurocode 7 - Geotechnical design module This module provides functions and classes for geotechnical design according to Eurocode 7 (EN 1997-1:2004). It includes calculations for bearing capacity, earth pressures, and other geotechnical parameters.</p>"},{"location":"reference/eurocodepy/ec7/bearing_capacity/","title":"bearing_capacity","text":"<p>Soil Bearing Resistance Module</p> <p>This module provides functions to calculate the ultimate bearing capacity and factor of safety for shallow foundations based on classical geotechnical engineering methods such as Terzaghi's theory.</p> <p>Currently supported:</p> <ul> <li>Ultimate bearing capacity using EC7 method</li> <li>Ultimate bearing capacity for seismic loads using EC7 method</li> </ul>"},{"location":"reference/eurocodepy/ec7/bearing_capacity/#eurocodepy.ec7.bearing_capacity.bearing_resistance","title":"<code>bearing_resistance(phi, gamma, q, Bx, By, Hx, Hy, N, c=0, drained=True)</code>","text":"<p>Calculates the bearing capacity of a shallow foundation according with Eurocode 7 (EN 1997-1:2004)</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>float or array</code> <p>effective soil friction angle</p> required <code>gamma</code> <code>float or array</code> <p>unit weight of the soil</p> required <code>Bx</code> <code>float or array</code> <p>effective width of the foundation</p> required <code>By</code> <code>float or array</code> <p>effective length of the foundation</p> required <code>Hx</code> <code>float or array</code> <p>horizontal load in X direction on the foundation</p> required <code>Hy</code> <code>float or array</code> <p>horizontal load in Y direction on the foundation</p> required <code>N</code> <code>float or array</code> <p>vertical load on the foundation</p> required <code>c</code> <code>int or array</code> <p>effective cohesion. Defaults to 0.</p> <code>0</code> <code>drained</code> <code>bool</code> <p>drained or undrained conditions. if undrained c = cu. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>float or numpy.array: the bearing capacity of the foundation</p> Source code in <code>eurocodepy/ec7/bearing_capacity.py</code> <pre><code>def bearing_resistance(phi, gamma, q, Bx, By, Hx, Hy, N, c=0, drained=True):\n    \"\"\"Calculates the bearing capacity of a shallow foundation according with Eurocode 7 (EN 1997-1:2004)\n\n    Args:\n        phi (float or numpy.array): effective soil friction angle\n        gamma (float or numpy.array): unit weight of the soil\n        Bx (float or numpy.array): effective width of the foundation\n        By (float or numpy.array): effective length of the foundation\n        Hx (float or numpy.array): horizontal load in X direction on the foundation\n        Hy (float or numpy.array): horizontal load in Y direction on the foundation\n        N (float or numpy.array): vertical load on the foundation\n        c (int or numpy.array, optional): effective cohesion. Defaults to 0.\n        drained (bool, optional): drained or undrained conditions. if undrained c = cu. Defaults to True.\n\n    Returns:\n        float or numpy.array: the bearing capacity of the foundation \n    \"\"\"\n    bearing = 0.0\n    area = Bx*By\n\n    B = np.where(Bx &lt;= By, Bx, By)\n    L = np.where(Bx &lt;= By, By, Bx)\n    theta = np.where(Bx &lt;= By, np.arctan2(Hx, Hy), np.arctan2(Hy, Hx))\n\n    if drained:\n        mb = (2+B/L)/(1+B/L)\n        ml = (2+L/B)/(1+L/B)\n        m = ml*np.cos(theta)**2 + mb*np.sin(theta)**2\n        H = np.sqrt(Hx**2 + Hy**2)\n\n        tanphi = np.tan(phi)\n        sinphi = np.sin(phi)\n\n        Nq = np.exp(np.pi*tanphi)*np.tan(np.pi/4 + phi/2)**2\n        Nc = (Nq-1.0)/tanphi\n        Ng = 2.0*(Nq-1.0)*tanphi\n\n        sq = 1.0 + (B/L)*sinphi\n        sg = 1.0 - 0.3*(B/L)\n        sc = (sq*Nq-1.0)/(Nq-1.0)\n\n        aux = (1.0 - H / (N + area*c/tanphi))\n        iq = aux**m\n        ig = aux**(m+1)\n        ic = iq-(1.0-iq)/(Nc*tanphi)\n\n        bearing = c * Nc * sc * ic + q * Nq * sq * iq + 0.5 * gamma * B * Ng * sg * ig\n\n    else:\n        sc = 1.0 + 0.2*(B/L)\n        aux = H / (area*c)\n        aux = aux if aux &lt; 1.0 else 1.0\n        ic = 0.5 * (1.0 + np.sqrt(1.0 - aux))\n        bearing = (np.pi+2.0) * c * sc * ic + q \n\n    return bearing\n</code></pre>"},{"location":"reference/eurocodepy/ec7/bearing_capacity/#eurocodepy.ec7.bearing_capacity.seismic_bearing_resistance","title":"<code>seismic_bearing_resistance(phi, gamma, ag, avg_ahg, S, B, H, N, M, c=0.0, gamma_c=1.0, gamma_rd=1.5, soil_type='incoerente')</code>","text":"<p>Calculates the bearing capacity of a shallow foundation under seismic conditioonsd according with Eurocode 7 (EN 1997-5:2004)</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>float or ndarray</code> <p>effective soil friction angle</p> required <code>gamma</code> <code>float or ndarray</code> <p>unit weight of the soil</p> required <code>ag</code> <code>float or ndarray</code> <p>soil acceleration</p> required <code>avg_ahg</code> <code>float or ndarray</code> <p>ratio between the vertical and horizontal accelerations</p> required <code>B</code> <code>float or ndarray</code> <p>width of the foundation</p> required <code>H</code> <code>float or ndarray</code> <p>horizontal load in Y direction on the foundation</p> required <code>N</code> <code>float or ndarray</code> <p>vertical load on the foundation</p> required <code>M</code> <code>float or ndarray</code> <p>moment on the foundation</p> required <code>c</code> <code>float or ndarray</code> <p>effective cohesion. Defaults to 0.</p> <code>0.0</code> <code>gamma_c</code> <code>float or ndarray</code> <p>safety coefficient for coehesion. Defaults to 1.0</p> <code>1.0</code> <code>gamma_rd</code> <code>float or ndarray</code> <p>safety coefficient for bearing capacity. Defaults to 1.5</p> <code>1.5</code> <code>soil_type</code> <code>str</code> <p>type of soil.</p> <code>'incoerente'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: values of the bearing capacity ratio</p> Source code in <code>eurocodepy/ec7/bearing_capacity.py</code> <pre><code>def seismic_bearing_resistance(phi, gamma, ag, avg_ahg, S, B, H, N, M, c=0.0, gamma_c=1.0, gamma_rd=1.5, soil_type=\"incoerente\") -&gt; np.ndarray:\n    \"\"\"Calculates the bearing capacity of a shallow foundation under seismic conditioonsd according with Eurocode 7 (EN 1997-5:2004)\n\n    Args:\n        phi (float or numpy.ndarray): effective soil friction angle\n        gamma (float or numpy.ndarray): unit weight of the soil\n        ag (float or numpy.ndarray): soil acceleration\n        avg_ahg (float or numpy.ndarray): ratio between the vertical and horizontal accelerations\n        B (float or numpy.ndarray): width of the foundation\n        H (float or numpy.ndarray): horizontal load in Y direction on the foundation\n        N (float or numpy.ndarray): vertical load on the foundation\n        M (float or numpy.ndarray): moment on the foundation\n        c (float or numpy.ndarray, optional): effective cohesion. Defaults to 0.\n        gamma_c (float or numpy.ndarray, optional): safety coefficient for coehesion. Defaults to 1.0\n        gamma_rd (float or numpy.ndarray, optional): safety coefficient for bearing capacity. Defaults to 1.5\n        soil_type (str, optional): type of soil.\n\n    Returns:\n        np.ndarray: values of the bearing capacity ratio\n    \"\"\"\n\n    g = 9.80665\n    tanphi = np.tan(phi)\n    Nmax = np.array([0.0, 0.0])\n    F_ = 0.0\n\n    if soil_type == \"coerente\":\n        a = 0.7\n        b = 1.29\n        c = 2.14\n        d = 1.81\n        e = 0.21\n        f = 0.44\n        m = 0.21\n        k = 1.22\n        k_ = 1.0\n        ct = 2.0\n        cm = 2.0\n        c_m = 1.0\n        beta = 2.57\n        gamma = 1.87\n\n        F_ = gamma * ag * S * B / c\n        Nq = np.exp(np.pi*tanphi)*np.tan(np.pi/4 + phi/2)**2\n        Ng = 2.0*(Nq-1.0)*tanphi\n        Nmax = np.array([(np.pi+2.0) * c * B / gamma_c])\n\n    elif soil_type == \"incoerente\":\n        a = 0.92\n        b = 1.25\n        c = 0.92\n        d = 1.25\n        e = 0.41\n        f = 0.32\n        m = 0.96\n        k = 1.0\n        k_ = 0.39\n        ct = 1.14\n        cm = 1.01\n        c_m = 1.01\n        beta = 2.9\n        gamma = 2.8\n\n        F_ = ag / (g * tanphi)\n        Nq = np.exp(np.pi*tanphi)*np.tan(np.pi/4 + phi/2)**2\n        Ng = 2.0*(Nq-1.0)*tanphi\n        Nmax = np.array([   0.5 * gamma * g * (1.0 + avg_ahg * ag / g) * B**2 * Ng,\n                            0.5 * gamma * g * (1.0 - avg_ahg * ag / g) * B**2 * Ng])\n\n    ratio = np.array([])\n    for n in Nmax:\n        N_ = gamma_rd * N / n\n        V_ = gamma_rd * H / n\n        M_ = gamma_rd * M / n\n\n        if (N_ &lt; 0.0 or \n            ((soil_type == \"incoerente\" and N_ &gt;= (1.0 - m*F_)**k_) or (soil_type == \"coerente\" and N_ &gt;= 1.0))):\n            ratio.append(-1)\n            continue\n\n        val1 = (1.0 - e*F_)**ct * (beta*V_)**ct\n        val2 = N_**a * (( 1.0-m*F_**k)**k_ - N_)**b\n        val3 = (1.0-f*F_)**c_m*(gamma*M_)**cm\n        val4 = N_**a * (( 1.0-m*F_**k)**k_ - N_)**d\n\n        ratio.append(val1/val2 + val3/val4 -  1.0)\n\n    return np.where(ratio &lt; 0.0, True, False)\n</code></pre>"},{"location":"reference/eurocodepy/ec7/earth_pressures/","title":"earth_pressures","text":""},{"location":"reference/eurocodepy/ec7/earth_pressures/#eurocodepy.ec7.earth_pressures.coulomb_coefficient","title":"<code>coulomb_coefficient(phi, delta, theta, betha)</code>","text":"<p>Calculate Coulomb coefficients for earth pressures.</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>float</code> <p>friction angle of the soil (radians).</p> required <code>delta</code> <code>float</code> <p>friction angle of the wall (radians).</p> required <code>theta</code> <code>float</code> <p>slope angle of the backfill (radians).</p> required <code>betha</code> <code>float</code> <p>slope angle of the wall (radians).</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Active/passive earth pressure coefficients (Ka, Kp).</p> Source code in <code>eurocodepy/ec7/earth_pressures.py</code> <pre><code>def coulomb_coefficient(phi, delta, theta, betha):\n    \"\"\"Calculate Coulomb coefficients for earth pressures.\n\n    Args:\n        phi (float): friction angle of the soil (radians).\n        delta (float): friction angle of the wall (radians).\n        theta (float): slope angle of the backfill (radians).\n        betha (float): slope angle of the wall (radians).\n\n    Returns:\n        list: Active/passive earth pressure coefficients (Ka, Kp).\n    \"\"\"\n    a1 = np.cos(phi-theta)**2/(np.cos(theta)**2*np.cos(delta+theta)*\n            (1+np.sqrt((np.sin(phi+delta)*np.sin(phi-betha))/(np.cos(betha-theta*np.cos(delta+theta)))))**2)\n    a2 = np.cos(phi+theta)**2/(np.cos(theta)**2*np.cos(delta-theta)*\n            (1-np.sqrt((np.sin(phi+delta)*np.sin(phi+betha))/(np.cos(betha-theta*np.cos(delta-theta)))))**2)\n    return [a1, a2]\n</code></pre>"},{"location":"reference/eurocodepy/ec7/earth_pressures/#eurocodepy.ec7.earth_pressures.earthquake_coefficient","title":"<code>earthquake_coefficient(phi, delta, theta, betha, kh, kv)</code>","text":"<p>Calculate earthquake coefficients for earth pressures.</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>float</code> <p>friction angle of the soil (radians).</p> required <code>delta</code> <code>float</code> <p>friction angle of the wall (radians).</p> required <code>theta</code> <code>float</code> <p>slope angle of the backfill (radians).</p> required <code>betha</code> <code>float</code> <p>slope angle of the wall (radians).</p> required <code>kh</code> <code>float</code> <p>horizontal seismic coefficient.</p> required <code>kv</code> <code>float</code> <p>vertical seismic coefficient.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Active/passive earthquake coefficients (kas1, kps1, kas2, kps2).</p> Source code in <code>eurocodepy/ec7/earth_pressures.py</code> <pre><code>def earthquake_coefficient(phi, delta, theta, betha, kh, kv):\n    \"\"\"Calculate earthquake coefficients for earth pressures.\n\n    Args:\n        phi (float): friction angle of the soil (radians).\n        delta (float): friction angle of the wall (radians).\n        theta (float): slope angle of the backfill (radians).\n        betha (float): slope angle of the wall (radians).\n        kh (float): horizontal seismic coefficient.\n        kv (float): vertical seismic coefficient.\n\n    Returns:\n        list: Active/passive earthquake coefficients (kas1, kps1, kas2, kps2).\n    \"\"\"\n    psi = np.pi/2 - theta\n\n    eps = np.arctan(kh/(1+kv))\n    a1 = np.sin(psi+phi-eps)**2\n    a2 = np.cos(eps)*np.sin(psi)**2*np.sin(psi-eps-delta)\n    a3 = 1.0 if betha &gt; phi-eps else (1+np.sqrt((np.sin(phi+delta)*np.sin(phi-betha-eps))/(np.sin(psi-eps-delta)*np.sin(psi+betha))))**2\n    kas1 = a1/(a2*a3)\n    a1 = np.sin(psi+phi-eps)**2\n    a2 = np.cos(eps)*np.sin(psi)**2*np.sin(psi+eps)\n    a3 = 1.0 if betha &gt; phi-eps else (1+np.sqrt((np.sin(phi+delta)*np.sin(phi-betha-eps))/(np.sin(psi+eps)*np.sin(psi+betha))))**2\n    kps1 = a1/(a2*a3) \n\n    eps = np.arctan(kh/(1-kv))\n    a1 = np.sin(psi+phi-eps)**2\n    a2 = np.cos(eps)*np.sin(psi)**2*np.sin(psi-eps-delta)\n    a3 = 1.0 if betha &gt; phi-eps else (1+np.sqrt((np.sin(phi+delta)*np.sin(phi-betha-eps))/(np.sin(psi-eps-delta)*np.sin(psi+betha))))**2\n    kas2 = a1/(a2*a3)\n    a1 = np.sin(psi+phi-eps)**2\n    a2 = np.cos(eps)*np.sin(psi)**2*np.sin(psi+eps)\n    a3 = 1.0 if betha &gt; phi-eps else (1+np.sqrt((np.sin(phi+delta)*np.sin(phi-betha-eps))/(np.sin(psi+eps)*np.sin(psi+betha))))**2\n    kps2 = a1/(a2*a3) \n\n    return [kas1, kps1, kas2, kps2]\n</code></pre>"},{"location":"reference/eurocodepy/ec7/earth_pressures/#eurocodepy.ec7.earth_pressures.ec7_coefficient","title":"<code>ec7_coefficient(phi, delta, theta, betha)</code>","text":"<p>Calculate EC7 coefficients for earth pressures.</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>float</code> <p>friction angle of the soil (radians).</p> required <code>delta</code> <code>float</code> <p>friction angle of the wall (radians).</p> required <code>theta</code> <code>float</code> <p>slope angle of the backfill (radians).</p> required <code>betha</code> <code>float</code> <p>slope angle of the wall (radians).</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Active/passive earth pressure coefficients (Ka, Kp, Kaq, Kpq, Kac, Kpc).</p> Source code in <code>eurocodepy/ec7/earth_pressures.py</code> <pre><code>def ec7_coefficient(phi, delta, theta, betha):\n    \"\"\"Calculate EC7 coefficients for earth pressures.\n\n    Args:\n        phi (float): friction angle of the soil (radians).\n        delta (float): friction angle of the wall (radians).\n        theta (float): slope angle of the backfill (radians).\n        betha (float): slope angle of the wall (radians).\n\n    Returns:\n        list: Active/passive earth pressure coefficients (Ka, Kp, Kaq, Kpq, Kac, Kpc).\n    \"\"\"\n    amt = np.arccos(np.sin(betha)/np.sin(phi))+phi-betha\n    amw = np.arccos(np.sin(delta)/np.sin(phi))+phi+delta\n    av = amt/2+betha-amw/2-theta\n    akn = ((1-np.sin(phi)*np.sin(amw-phi))/(1+np.sin(phi)*np.sin(amt-phi)))*np.exp(-2*av*np.tan(phi))\n    pmt = np.arccos(-np.sin(betha)/np.sin(phi))-phi-betha\n    pmw = np.arccos(np.sin(delta)/np.sin(phi))-phi-delta\n    pv = pmt/2+betha-pmw/2-theta\n    pkn = ((1+np.sin(phi)*np.sin(pmw+phi))/(1-np.sin(phi)*np.sin(pmt+phi)))*np.exp(2*pv*np.tan(phi))\n    aux = np.cos(betha)*np.cos(betha-theta)\n    kag = akn*aux\n    kpg = pkn*aux\n    aux = np.cos(betha)**2\n    kaq = akn*aux\n    kpq = pkn*aux\n    kac = (akn-1.0)/np.tan(-phi)\n    kpc = (pkn-1.0)/np.tan(phi)\n    return [kag, kpg, kaq, kpq, kac, kpc]\n</code></pre>"},{"location":"reference/eurocodepy/ec7/earth_pressures/#eurocodepy.ec7.earth_pressures.inrest_coefficient","title":"<code>inrest_coefficient(phi, betha, OCR=1.0)</code>","text":"<p>Calculate coefficients for earth pressures at rest.</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>float</code> <p>friction angle of the soil (radians).</p> required <code>betha</code> <code>floast</code> <p>slope angle of the backfill (radians).</p> required <code>OCR</code> <code>float</code> <p>OCR for clays. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>list</code> <p>In rest earth pressure coefficients at rest (Ka, Kp).</p> Source code in <code>eurocodepy/ec7/earth_pressures.py</code> <pre><code>def inrest_coefficient(phi, betha, OCR=1.0):\n    \"\"\"Calculate coefficients for earth pressures at rest.\n\n    Args:\n        phi (float): friction angle of the soil (radians).\n        betha (floast): slope angle of the backfill (radians).\n        OCR (float, optional): OCR for clays. Defaults to 1.0.\n\n    Returns:\n        list: In rest earth pressure coefficients at rest (Ka, Kp).\n    \"\"\"\n    a = (1-np.sin(phi))*np.sqrt(OCR)*(1+np.sin(betha))\n    return [a, a]\n</code></pre>"},{"location":"reference/eurocodepy/ec7/earth_pressures/#eurocodepy.ec7.earth_pressures.pressure_coefficients","title":"<code>pressure_coefficients(phi, delta, theta, beta, method='ec7', seismic=None)</code>","text":"<p>Calculate earth pressure coefficients based on the specified method.</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>float</code> <p>friction angle of the soil (radians).</p> required <code>delta</code> <code>float</code> <p>friction angle of the wall (radians).</p> required <code>theta</code> <code>float</code> <p>slope angle of the backfill (radians).</p> required <code>betha</code> <code>float</code> <p>slope angle of the wall (radians).</p> required <code>method</code> <code>str</code> <p>calculation method for earth pressures. Defaults to \"ec7\".</p> <code>'ec7'</code> <code>seismic</code> <code>_type_</code> <p>Seismic horizontal/vertical seismic coefficients. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Method not found.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>pressure coefficients (Ka, Kp, Kaq, Kpq, dkas1, dkps1, dkas2, dkps2).</p> <ul> <li>Ka: Active earth pressure coefficient.</li> </ul> <ul> <li>Kp: Passive earth pressure coefficient.</li> </ul> <ul> <li>Kaq: Active earth pressure coefficient at rest.</li> </ul> <ul> <li>Kpq: Passive earth pressure coefficient at rest.</li> </ul> <ul> <li>dkas1: Difference in active earth pressure coefficient for seismic case 1.</li> </ul> <ul> <li>dkps1: Difference in passive earth pressure coefficient for seismic case 1.</li> </ul> <ul> <li>dkas2: Difference in active earth pressure coefficient for seismic case 2.</li> </ul> <ul> <li>dkps2: Difference in passive earth pressure coefficient for seismic case 2.</li> </ul> Source code in <code>eurocodepy/ec7/earth_pressures.py</code> <pre><code>def pressure_coefficients(phi, delta, theta, beta, method=\"ec7\", seismic=None):\n    \"\"\"Calculate earth pressure coefficients based on the specified method.\n\n    Args:\n        phi (float): friction angle of the soil (radians).\n        delta (float): friction angle of the wall (radians).\n        theta (float): slope angle of the backfill (radians).\n        betha (float): slope angle of the wall (radians).\n        method (str, optional): calculation method for earth pressures. Defaults to \"ec7\".\n        seismic (_type_, optional): Seismic horizontal/vertical seismic coefficients. Defaults to None.\n\n    Raises:\n        ValueError: Method not found.\n\n    Returns:\n        tuple: pressure coefficients (Ka, Kp, Kaq, Kpq, dkas1, dkps1, dkas2, dkps2).\n        - Ka: Active earth pressure coefficient.\n        - Kp: Passive earth pressure coefficient.\n        - Kaq: Active earth pressure coefficient at rest.\n        - Kpq: Passive earth pressure coefficient at rest.\n        - dkas1: Difference in active earth pressure coefficient for seismic case 1.\n        - dkps1: Difference in passive earth pressure coefficient for seismic case 1.\n        - dkas2: Difference in active earth pressure coefficient for seismic case 2.\n        - dkps2: Difference in passive earth pressure coefficient for seismic case 2.\n    \"\"\"\n    method = method.lower()\n    if method == \"ec7\":\n        Ka, Kp, Kaq, Kpq, Kac, Kpc = ec7_coefficient(phi, delta, theta, beta)\n    elif method == \"rankine\":\n        Ka, Kp = rankine_coefficient(phi, beta)\n        Kaq = Ka\n        Kpq = Kp\n    elif method == \"coulomb\":\n        Ka, Kp = coulomb_coefficient(phi, delta, theta, beta)\n        Kaq = Ka\n        Kpq = Kp\n    elif method == \"inrest\":\n        Ka, Kp = inrest_coefficient(phi, beta)\n        Kaq = Ka\n        Kpq = Kp\n    else:\n        raise ValueError(\"Method not found\")\n\n    kas1 = 0.0\n    kas2 = 0.0\n    kps1 = 0.0\n    kps2 = 0.0\n    dkas1 = 0.0\n    dkas2 = 0.0\n    dkps1 = 0.0\n    dkps2 = 0.0\n    if seismic is not None:\n        kas1, kps1, kas2, kps2 = earthquake_coefficient(phi, delta, theta, beta, seismic.kh, seismic.kv)\n        dkas1 = (1.0 + seismic.kv) * kas1 - Ka\n        dkas2 = (1.0 - seismic.kv) * kas2 - Ka\n        dkps1 = Kp - (1.0 + seismic.kv) * kps1\n        dkps2 = Kp - (1.0 - seismic.kv) * kps2\n\n    return Ka, Kp, Kaq, Kpq, dkas1, dkps1, dkas2, dkps2\n</code></pre>"},{"location":"reference/eurocodepy/ec7/earth_pressures/#eurocodepy.ec7.earth_pressures.rankine_coefficient","title":"<code>rankine_coefficient(phi, betha)</code>","text":"<p>Calculate Rankine coefficients for earth pressures.</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>float</code> <p>Friction angle of the soil (radians).</p> required <code>betha</code> <code>float</code> <p>slope angle of the backfill (radians).</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>Active/Passive earth pressure coefficients at rest (Ka, Kp).</p> Source code in <code>eurocodepy/ec7/earth_pressures.py</code> <pre><code>def rankine_coefficient(phi, betha):\n    \"\"\"Calculate Rankine coefficients for earth pressures.\n\n    Args:\n        phi (float): Friction angle of the soil (radians).\n        betha (float): slope angle of the backfill (radians).\n\n    Returns:\n        list: Active/Passive earth pressure coefficients at rest (Ka, Kp).\n    \"\"\"\n    a1 = (np.cos(betha)-np.sqrt((np.cos(betha))**2-(np.cos(phi))**2)) #*np.cos(betha)\n    a2 = (np.cos(betha)+np.sqrt((np.cos(betha))**2-(np.cos(phi))**2))\n    return [a1/a2, a2/a1]\n</code></pre>"},{"location":"reference/eurocodepy/ec7/retaining_wall/","title":"retaining_wall","text":"<p>Concrete Retaining Wall Design Module using Eurocode 7</p> <p>This module provides functions to design and verify reinforced concrete cantilever retaining walls in accordance with the European standard EN 1997-1:2004 (Eurocode 7 - Geotechnical design - Part 1: General rules).</p> <p>Main Features:</p> <ul> <li>Calculation of earth pressures using Rankine, Coulomb, and EC7 methods</li> <li>Overturning, sliding, and bearing capacity checks</li> <li>Reinforcement design for stem and base slab</li> <li>Stability verification under various load cases</li> </ul> <p>References:</p> <ul> <li>EN 1997-1:2004 - Eurocode 7: Geotechnical design \u2013 Part 1: General rules</li> <li>EN 1992-1-1:2004 - Eurocode 2: Design of concrete structures</li> </ul>"},{"location":"reference/eurocodepy/ec7/retaining_wall/#eurocodepy.ec7.retaining_wall.set_seismic","title":"<code>set_seismic(code, soil, imp_coef, spec, zone)</code>","text":"<p>Sets the parameters for the seismic action 1 and 2</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>country (EU, PT)</p> required <code>soil</code> <code>str</code> <p>type of soil (A, B, C, D, E)</p> required <code>imp_coef</code> <code>str</code> <p>importance coeficient (i, ii, iii, iv)</p> required <code>spec1</code> <code>str</code> <p>spectrum name (for PT: PT-1, PT-2, PT-A)                         (for EU: CEN-1, CECN-2)</p> required <code>zone1</code> <code>str</code> <p>seismic zone 1 (for PT: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6)                         (for EU: .1g, .2g ...)</p> required Source code in <code>eurocodepy/ec7/retaining_wall.py</code> <pre><code>def set_seismic(code: str, soil: str, imp_coef: str, spec: str, zone: str):\n    \"\"\"Sets the parameters for the seismic action 1 and 2\n\n    Args:\n        code (str): country (EU, PT)\n        soil (str): type of soil (A, B, C, D, E)\n        imp_coef (str): importance coeficient (i, ii, iii, iv)\n        spec1 (str): spectrum name (for PT: PT-1, PT-2, PT-A)\n                                    (for EU: CEN-1, CECN-2)\n        zone1 (str): seismic zone 1 (for PT: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6)\n                                    (for EU: .1g, .2g ...)\n    \"\"\"\n\n    ag = db[\"Loads\"][\"Seismic\"][\"Locale\"][code][\"a_gR\"][spec][zone]\n    smax = db[\"Loads\"][\"Seismic\"][\"Locale\"][code][\"Spectrum\"][spec][soil][\"S_max\"]\n    impcoef = db[\"Loads\"][\"Seismic\"][\"Locale\"][code][\"ImportanceCoef\"][spec][imp_coef]\n    agvagh = db[\"Loads\"][\"Seismic\"][\"Locale\"][code][\"avg_ahg\"][spec]\n\n    return SeismicParameters(spec, ag, smax, impcoef, agvagh)\n</code></pre>"},{"location":"reference/eurocodepy/ec8/","title":"ec8","text":""},{"location":"reference/eurocodepy/ec8/spectrum/","title":"spectrum","text":""},{"location":"reference/eurocodepy/ec8/spectrum/#eurocodepy.ec8.spectrum.calc_spectrum","title":"<code>calc_spectrum(T, a_g, S, q, TB, TC, TD, beta=0.2)</code>","text":"<p>Calculates the spectrum value for a given period, T</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>float</code> <p>period (s)</p> required <code>a_g</code> <code>float</code> <p>acceleration (m/s2)</p> required <code>S</code> <code>float</code> <p>soil amplification factor</p> required <code>q</code> <code>float</code> <p>behaviour factor</p> required <code>TB</code> <code>float</code> <p>spectrum parameter</p> required <code>TC</code> <code>float</code> <p>spectrum parameter</p> required <code>TD</code> <code>float</code> <p>spectrum parameter</p> required <code>beta</code> <code>float</code> <p>the limiting value of the spectrum. Defaults to 0.2.</p> <code>0.2</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the spectrum value</p> Source code in <code>eurocodepy/ec8/spectrum.py</code> <pre><code>def calc_spectrum(T: float, a_g: float, S: float, q: float, TB: float, TC: float, TD: float, beta: float=0.2) -&gt; float:\n    \"\"\"Calculates the spectrum value for a given period, T\n\n    Args:\n        T (float): period (s)\n        a_g (float): acceleration (m/s2)\n        S (float): soil amplification factor\n        q (float): behaviour factor\n        TB (float): spectrum parameter\n        TC (float): spectrum parameter\n        TD (float): spectrum parameter\n        beta (float, optional): the limiting value of the spectrum. Defaults to 0.2.\n\n    Returns:\n        float: the spectrum value\n    \"\"\"\n    ag_S = a_g * S\n\n    if T &lt; TB:\n        spec = ag_S * (2.0/3.0 + T / TB * (2.5 / q - 2.0/3.0))\n    elif T &lt; TC:\n        spec = ag_S * 2.5 / q\n    elif T &lt; TD:\n        spec = max(ag_S * 2.5 / q * (TC)/T, beta * ag_S)\n    else:\n        spec = max(ag_S * 2.5 / q * (TC*TD)/T**2, beta * ag_S)\n\n    return spec\n</code></pre>"},{"location":"reference/eurocodepy/ec8/spectrum/#eurocodepy.ec8.spectrum.draw_spectrum_ec8","title":"<code>draw_spectrum_ec8(spectrum, save=False, filename=None, show=True)</code>","text":"<p>Draw the spectrum using matplotlib</p> <p>Parameters:</p> Name Type Description Default <code>spectrum</code> <code>DataFrame</code> <p>a pandas DataFrame with the spectrum data (columns: period, value)</p> required Source code in <code>eurocodepy/ec8/spectrum.py</code> <pre><code>def draw_spectrum_ec8(spectrum: pd.DataFrame, save: bool = False, filename: str = None, show: bool = True):\n    \"\"\"Draw the spectrum using matplotlib\n\n    Args:\n        spectrum (pd.DataFrame): a pandas DataFrame with the spectrum data (columns: period, value)\n    \"\"\"\n    # plot the spectrum\n    plt.plot(spectrum['period'].to_numpy(), spectrum['value'].to_numpy())\n    s = spectrum.attrs['name'] + ':    S=' + str(round(spectrum.attrs['S'],3)) + ' a_g=' + str(round(spectrum.attrs['a_g'], 3)) + ' q=' + str(spectrum.attrs['q'])\n    plt.title(s)\n    plt.xlabel('Period (s)')\n    plt.ylabel('Spectrum value (m/s2)')\n    if save:\n        if filename is None:\n            filename = s + '.png'\n        plt.savefig(filename, dpi=300, bbox_inches='tight')\n    if show:\n        plt.show()\n</code></pre>"},{"location":"reference/eurocodepy/ec8/spectrum/#eurocodepy.ec8.spectrum.get_spec_params","title":"<code>get_spec_params(locale, code, class_imp, soil, zone)</code>","text":"<p>Get the spectrum parameters</p> <p>Parameters:</p> Name Type Description Default <code>locale</code> <code>str</code> <p>country code (EU, PT)</p> required <code>code</code> <code>str</code> <pre><code>CEN-1, CEN-2: standard Eurocode spectrums (EU)\nPT1, PT2, PTA: Portuguese National Annex spectrums (PT)\n(PT1 and PT2, for continent and Madeira, PTA for Azores)\n</code></pre> required <code>class_imp</code> <code>str</code> <p>importance class  (i, ii, iii, iv)</p> required <code>soil</code> <code>str</code> <p>soil type (A, B, C, D, E)</p> required <code>zone</code> <code>str</code> <p>(1_1, 1_2, 1_3, 1_4, 1_5, 1_6) for \"PT-1\"         (2.1, 2.2, 2.3, 2.4, 2.5) for \"PT-2\" and \"PT-A\"         (.1g, .2g, .3g, .4g, .5g, .6g, .7g, .8g, .9g, 1_0g) for \"CEN-1\" and \"CEN-2\"</p> required <p>Raises:     ValueError: if locale is not available     ValueError: if code is not available     ValueError: if class_imp is not available</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>soil amplification factor, acceleration, T_B, T_C, T_D</p> Source code in <code>eurocodepy/ec8/spectrum.py</code> <pre><code>def get_spec_params(locale:str, code: str, class_imp: str, soil: str, zone: str) -&gt; list:\n    \"\"\"Get the spectrum parameters\n\n    Args:\n        locale (str): country code (EU, PT)\n        code (str): \n                CEN-1, CEN-2: standard Eurocode spectrums (EU)\n                PT1, PT2, PTA: Portuguese National Annex spectrums (PT)\n                (PT1 and PT2, for continent and Madeira, PTA for Azores)\n        class_imp (str): importance class  (i, ii, iii, iv)\n        soil (str): soil type (A, B, C, D, E)\n        zone (str): (1_1, 1_2, 1_3, 1_4, 1_5, 1_6) for \"PT-1\"\n                    (2.1, 2.2, 2.3, 2.4, 2.5) for \"PT-2\" and \"PT-A\"\n                    (.1g, .2g, .3g, .4g, .5g, .6g, .7g, .8g, .9g, 1_0g) for \"CEN-1\" and \"CEN-2\"\n    Raises:\n        ValueError: if locale is not available\n        ValueError: if code is not available\n        ValueError: if class_imp is not available\n\n    Returns:\n        list: soil amplification factor, acceleration, T_B, T_C, T_D\n    \"\"\"\n    local = db.SeismicLoads[\"Locale\"][locale]\n\n    if code not in local[\"Types\"]:\n        raise ValueError(f\"Code {code} not available for locale {locale}\")\n\n    class_imp = str.lower(class_imp)\n    if class_imp not in local[\"ImportanceClass\"].keys():\n        raise ValueError(f\"Class {class_imp} not available for locale {locale}\")\n\n    if zone not in local[\"a_gR\"][code].keys():\n        raise ValueError(f\"Zone {zone} not available for locale {locale}\")\n\n    soil = str.upper(soil)\n    if soil not in local[\"SoilType\"].keys():\n        raise ValueError(f\"Soil {soil} not available for code {code}\")\n\n    importance_coef = local[\"ImportanceCoef\"][code][class_imp]\n    a_gR = local[\"a_gR\"][code][zone]\n    a_g = a_gR * importance_coef\n\n    TB = local[\"Spectrum\"][code][soil][\"T_B\"]\n    TC = local[\"Spectrum\"][code][soil][\"T_C\"]\n    TD = local[\"Spectrum\"][code][soil][\"T_D\"]\n    Smax = local[\"Spectrum\"][code][soil][\"S_max\"]\n    Smin = local[\"Spectrum\"][code][soil][\"S_min\"]\n    ag1 = local[\"Spectrum\"][code][soil][\"a_g1\"]\n    ag2 = local[\"Spectrum\"][code][soil][\"a_g2\"]\n    if a_g &lt;= ag1:\n        S = Smax\n    elif a_g &gt;= ag2:\n        S = Smin\n    else:\n        S = Smax - (Smax - Smin) * (a_g - ag1) / (ag2 - ag1)\n    return S, a_g, TB, TC, TD\n</code></pre>"},{"location":"reference/eurocodepy/ec8/spectrum/#eurocodepy.ec8.spectrum.get_spectrum_ec8","title":"<code>get_spectrum_ec8(locale, code, imp_class, soil, zone, behaviour)</code>","text":"<p>Generate the spectrum DataFrame for the given parameters</p> <p>Parameters:</p> Name Type Description Default <code>locale</code> <code>str</code> <p>country code (EU, PT)</p> required <code>code</code> <code>str</code> <p>the code of the spectrum (CEN-1, CEN-2, PT-1, PT-2, PT-A)</p> required <code>imp_class</code> <code>str</code> <p>importance class (I, II, III, IV)</p> required <code>soil</code> <code>str</code> <p>type of soil (A, B, C, D, E)</p> required <code>zone</code> <code>str</code> <p>seismic zone </p> required <code>behaviour</code> <code>float</code> <p>behaviour factor</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: the spectrum DataFrame</p> Source code in <code>eurocodepy/ec8/spectrum.py</code> <pre><code>def get_spectrum_ec8(locale: str, code: str, imp_class: str, soil: str, zone:str, behaviour: float) -&gt; pd.DataFrame:\n    \"\"\"Generate the spectrum DataFrame for the given parameters\n\n    Args:\n        locale (str): country code (EU, PT)\n        code (str): the code of the spectrum (CEN-1, CEN-2, PT-1, PT-2, PT-A)\n        imp_class (str): importance class (I, II, III, IV)\n        soil (str): type of soil (A, B, C, D, E)\n        zone (str): seismic zone \n        behaviour (float): behaviour factor\n\n    Returns:\n        pd.DataFrame: the spectrum DataFrame\n    \"\"\"\n    txt = code + '_' + imp_class + '_' + soil + '_' + str.replace(zone,'_','.') + '_' + str(behaviour)\n\n    S, a_g, TB, TC, TD = get_spec_params(locale, code, imp_class, soil, zone)\n\n    periods = np.linspace(0.0, TB, 10, endpoint=False)\n    periods = np.append(periods, np.linspace(TB, TC, 10, endpoint=False))\n    periods = np.append(periods, np.linspace(TC, TD, 10, endpoint=False))\n    periods = np.append(periods, np.linspace(TD, 10, 30))\n\n    value = [calc_spectrum(T, a_g, S, behaviour, TB, TC, TD, 0.2) for T in periods]\n    data = {'period': periods,\n            'value': value}\n\n    spec = pd.DataFrame(data)\n    spec.attrs['name'] = txt\n    spec.attrs['S'] = S\n    spec.attrs['a_g'] = a_g\n    spec.attrs['q'] = str(behaviour)\n\n    return spec\n</code></pre>"},{"location":"reference/eurocodepy/ec8/spectrum/#eurocodepy.ec8.spectrum.get_spectrum_parameters","title":"<code>get_spectrum_parameters(code, coef_imp, soil, zone)</code>","text":"<p>Get the spectrum parameters</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>code to be used (CEN-1, CEN-2, PT-1, PT-2, PT-A)     CEN-1, CEN-2: standard Eurocode spectrums     PT-1, PT-2, PT-A: Portuguese National Annex spectrums         (PT-1 and PT-2, for continent and Madeira, PT-A for Azores)</p> required <code>coef_imp</code> <code>str</code> <p>importance coefficient (i, ii, iii, iv)</p> required <code>soil</code> <code>str</code> <p>soil type (A, B, C, D, E)</p> required <code>zone</code> <code>str</code> <p>zone (1_1, 1_2, 1_3, 1_4, 1_5, 1_6, 2.1, 2.2, 2.3, 2.4, 2.5, .1g, .2g, .3g, .4g, .5g, .6g, .7g, .8g, .9g, 1_0g)</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>soil amplification factor, acceleration, T_B, T_C, T_D</p> Source code in <code>eurocodepy/ec8/spectrum.py</code> <pre><code>def get_spectrum_parameters(code: str, coef_imp: str, soil: str, zone: str) -&gt; list:\n    \"\"\"Get the spectrum parameters\n\n    Args:\n        code (str): code to be used (CEN-1, CEN-2, PT-1, PT-2, PT-A)\n                CEN-1, CEN-2: standard Eurocode spectrums\n                PT-1, PT-2, PT-A: Portuguese National Annex spectrums\n                    (PT-1 and PT-2, for continent and Madeira, PT-A for Azores)\n        coef_imp (str): importance coefficient (i, ii, iii, iv)\n        soil (str): soil type (A, B, C, D, E)\n        zone (str): zone (1_1, 1_2, 1_3, 1_4, 1_5, 1_6, 2.1, 2.2, 2.3, 2.4, 2.5, .1g, .2g, .3g, .4g, .5g, .6g, .7g, .8g, .9g, 1_0g)\n\n    Returns:\n        list: soil amplification factor, acceleration, T_B, T_C, T_D\n    \"\"\"\n    # accelarations\n    a_gR = {'1_1': 2.5, '1_2': 2.0, '1_3': 1_5, '1_4': 1_0, '1_5': 0.6, '1_6': 0.35, \n            '2.1': 2.5, '2.2': 2.0, '2.3': 1.7, '2.4': 1.1, '2.5': 0.8,\n            '.1g': 0.980665, '.2g': 1.96133, '.3g':  2.941995, '.4g': 3.92266, '.5g': 4.903325, \n            '.6g': 5.88399, '.7g': 6.864655, '.8g': 7.84532, '.9g': 8.825985, '1_0g': 9.80665}\n\n    index1 = ['i', 'ii', 'iii', 'iv']\n    gama_f = {'CEN-1': [0.8, 1.0, 1.2, 1.4], \n            'CEN-2': [0.8, 1.0, 1.2, 1.4], \n            'PT-1': [0.65, 1.0, 1.45, 1.95], \n            'PT-2': [0.75, 1.0, 1.25, 1.5], \n            'PT-A': [0.85, 1.0, 1.15, 1.35]}\n    coefs = pd.DataFrame(gama_f, index=index1)\n\n    coef_imp = str.lower(coef_imp)\n    a_g = a_gR[zone] * coefs.at[coef_imp, code]\n\n    soil = str.upper(soil)\n    index = ['A', 'B', 'C', 'D', 'E']\n    code = str.upper(code)\n    if code == 'CEN-1':\n        data = {'S_max': [1.0 , 1.2, 1.15, 1.35, 1.4],\n                'T_B': [0.15, 0.15, 0.2, 0.2, 0.15],\n                'T_C': [0.4, 0.5, 0.6, 0.8, 0.5],\n                'T_D': [2.0, 2.0, 2.0, 2.0, 2.0]\n                }\n    elif code == 'CEN-2':\n        data = {'S_max': [1.0 , 1.35, 1.5, 1.8, 1.6],\n                'T_B': [0.05, 0.05, 0.1, 0.1, 0.05],\n                'T_C': [0.25, 0.25, 0.25, 0.3, 0.25],\n                'T_D': [1.2, 1.2, 1.2, 1.2, 1.2]\n                }\n    elif code == 'PT-2'or code == 'PT-A':\n        data = {'S_max': [1.0 , 1.35, 1.60, 2.0, 1.8],\n                'T_B': [0.1, 0.1, 0.1, 0.1, 0.1],\n                'T_C': [0.25, 0.25, 0.25, 0.3, 0.25],\n                'T_D': [2.0, 2.0, 2.0, 2.0, 2.0]\n                }\n    elif code == 'PT-1' :\n        data = {'S_max': [1.0 , 1.35, 1.60, 2.0, 1.8],\n                'T_B': [0.1, 0.1, 0.1, 0.1, 0.1],\n                'T_C': [0.6, 0.6, 0.6, 0.8, 0.6],\n                'T_D': [2.0, 2.0, 2.0, 2.0, 2.0]\n                }\n    values = pd.DataFrame(data, index=index)\n\n    Smax = values.at[soil, 'S_max']\n\n    if code == 'CEN-1' or code == 'CEN-2':\n        S = Smax\n    else: \n        if a_g &lt;= 1.0:\n            S = Smax \n        elif a_g &gt;= 4.0:\n            S = 1.0\n        else:\n            S = Smax-(Smax-1.0)*(a_g-1.0)/3.0\n\n    TB = values.at[soil, 'T_B']\n    TC = values.at[soil, 'T_C']\n    TD = values.at[soil,'T_D']\n\n    return S, a_g, TB, TC, TD\n</code></pre>"},{"location":"reference/eurocodepy/ec8/spectrum/#eurocodepy.ec8.spectrum.get_spectrum_user","title":"<code>get_spectrum_user(a_g, S, q, TB, TC, TD, beta=0.2)</code>","text":"<p>generate the spectrum DataFrame for the given parameters</p> <p>Parameters:</p> Name Type Description Default <code>a_g</code> <code>float</code> <p>acceleration (m/s2)</p> required <code>S</code> <code>float</code> <p>soil amplification factor</p> required <code>q</code> <code>float</code> <p>behaviour factor</p> required <code>TB</code> <code>float</code> <p>spectrum parameter</p> required <code>TC</code> <code>float</code> <p>spectrum parameter</p> required <code>TD</code> <code>float</code> <p>spectrum parameter</p> required <code>beta</code> <code>float</code> <p>the limiting value of the spectrum. Defaults to 0.2.</p> <code>0.2</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: description</p> Source code in <code>eurocodepy/ec8/spectrum.py</code> <pre><code>def get_spectrum_user(a_g: float, S: float, q: float, TB: float, TC: float, TD: float, beta: float=0.2) -&gt; pd.DataFrame:\n    \"\"\"generate the spectrum DataFrame for the given parameters\n\n    Args:\n        a_g (float): acceleration (m/s2)\n        S (float): soil amplification factor\n        q (float): behaviour factor\n        TB (float): spectrum parameter\n        TC (float): spectrum parameter\n        TD (float): spectrum parameter\n        beta (float, optional): the limiting value of the spectrum. Defaults to 0.2.\n\n    Returns:\n        pd.DataFrame: _description_\n    \"\"\"\n    txt = 'TB_' + str(TB) + '_TC_' + str(TC) + '_TD_' + str(TD) + '_b_' + str(beta)\n\n    periods = np.linspace(0.0, TB, 10, endpoint=False)\n    periods = np.append(periods, np.linspace(TB, TC, 10, endpoint=False))\n    periods = np.append(periods, np.linspace(TC, TD, 10, endpoint=False))\n    periods = np.append(periods, np.linspace(TD, 10, 30))\n\n    value = [calc_spectrum(T, a_g, S, q, TB, TC, TD, beta) for T in periods]\n    data = {'period': periods,\n            'value': value}\n\n    spec = pd.DataFrame(data)\n    spec.attrs['name'] = txt\n    spec.attrs['S'] = S\n    spec.attrs['a_g'] = round(a_g, 5)\n    spec.attrs['q'] = q\n\n    return spec\n</code></pre>"},{"location":"reference/eurocodepy/ec8/spectrum/#eurocodepy.ec8.spectrum.write_spectrum_ec8","title":"<code>write_spectrum_ec8(spectrum, filename=None, separator=',')</code>","text":"<p>Generate a text file with the spectrum data</p> <p>Parameters:</p> Name Type Description Default <code>spectrum</code> <code>DataFrame</code> <p>a pandas DataFrame with the spectrum data (columns: period, value)</p> required <code>separator</code> <code>str</code> <p>a string with the separator to be used in the text file</p> <code>','</code> Source code in <code>eurocodepy/ec8/spectrum.py</code> <pre><code>def write_spectrum_ec8(spectrum: pd.DataFrame, filename=None, separator: str = ','):\n    \"\"\"Generate a text file with the spectrum data\n\n    Args:\n        spectrum (pd.DataFrame): a pandas DataFrame with the spectrum data (columns: period, value)\n        separator (str): a string with the separator to be used in the text file\n    \"\"\"\n    # separator was defined as ' ' (space) for SAP2000 compatibility. any other can be used\n    if filename is None:\n        filename = 'spectrum_' + spectrum.attrs['name'] + '.csv'\n\n    spectrum.to_csv(filename, index=False, sep=separator)\n</code></pre>"},{"location":"reference/eurocodepy/utils/","title":"utils","text":""},{"location":"reference/eurocodepy/utils/dict_tools/","title":"dict_tools","text":""},{"location":"reference/eurocodepy/utils/plotly_templates/","title":"plotly_templates","text":""},{"location":"reference/eurocodepy/utils/section_properties/","title":"section_properties","text":""},{"location":"reference/eurocodepy/utils/section_properties/#eurocodepy.utils.section_properties.calc_neutral_axis_cracked_T","title":"<code>calc_neutral_axis_cracked_T(h, b, bw, hf, A_s, A_sc, A_p, ds, dsc, dp, alpha_E_s, alpha_E_p, M, P, display=False)</code>","text":"<p>Calculates the neutral axis of a cracked T-section.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Total height of the section.</p> required <code>bw</code> <code>float</code> <p>Web width of the section.</p> required <code>bf</code> <code>float</code> <p>Flange width of the section.</p> required <code>hf</code> <code>float</code> <p>Flange height of the section.</p> required <code>A_s</code> <code>float[]</code> <p>Area of the tensioned reinforcement.</p> required <code>A_sc</code> <code>float[]</code> <p>Area of the compressed reinforcement.</p> required <code>A_p</code> <code>float[]</code> <p>Area of the prestressing tendon.</p> required <code>ds</code> <code>float[]</code> <p>Distance to the tensioned reinforcement from the top.</p> required <code>dsc</code> <code>float[]</code> <p>Distance to the compressed reinforcement from the top.</p> required <code>dp</code> <code>float[]</code> <p>Distance to the prestressing tendon from the top.</p> required <code>alpha_Es</code> <code>float</code> <p>Equivalence factor of the passive steel.</p> required <code>alpha_Ep</code> <code>float</code> <p>Equivalence factor of the prestressed steel.</p> required <code>M</code> <code>float</code> <p>Bending moment.</p> required <code>P</code> <code>float</code> <p>Prestressing normal force.</p> required <code>display</code> <code>bool</code> <p>If True, displays the calculated results. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the neutral axis depth of a cracked T section.</p> Source code in <code>eurocodepy/utils/section_properties.py</code> <pre><code>def calc_neutral_axis_cracked_T(h, b, bw, hf, A_s, A_sc, A_p, ds, dsc, dp, alpha_E_s, alpha_E_p, M, P, display=False) -&gt; float:\n    \"\"\"\n    Calculates the neutral axis of a cracked T-section.\n\n    Args:\n        h (float): Total height of the section.\n        bw (float): Web width of the section.\n        bf (float): Flange width of the section.\n        hf (float): Flange height of the section.\n        A_s (float[]): Area of the tensioned reinforcement.\n        A_sc (float[]): Area of the compressed reinforcement.\n        A_p (float[]): Area of the prestressing tendon.\n        ds (float[]): Distance to the tensioned reinforcement from the top.\n        dsc (float[]): Distance to the compressed reinforcement from the top.\n        dp (float[]): Distance to the prestressing tendon from the top.\n        alpha_Es (float): Equivalence factor of the passive steel.\n        alpha_Ep (float): Equivalence factor of the prestressed steel.\n        M (float): Bending moment.\n        P (float): Prestressing normal force.\n        display (bool, optional): If True, displays the calculated results. Defaults to False.\n\n    Returns:\n        float: the neutral axis depth of a cracked T section.\n    \"\"\"\n\n    ds_ref = np.max(ds)\n    dp_ref = np.sum(dp * A_p) / np.sum(A_p) if np.abs(np.sum(A_p)) &gt; 0 else dp[0]\n    es = -M / P - (ds_ref - dp_ref)  # Excentricidade\n\n    # Calcular os coeficientes da equa\u00e7\u00e3o c\u00fabica\n    a1 = -3 * np.sum(ds + es)\n    a2 = (-6 / bw) * (hf * (b - bw) * np.sum((ds + es - 0.5 * hf)) + (alpha_E_s - 1) * np.sum(A_sc * (ds + es - dsc)) +\n                    alpha_E_p * np.sum(A_p * (ds + es - dp)) + alpha_E_s * np.sum(A_s * es))\n    a3 = (6 / bw) * (0.5 * hf**2 * (b - bw) * np.sum((ds + es - 2/3 * hf)) +\n                    (alpha_E_s - 1) * A_sc * np.sum(dsc * (ds + es - dsc)) +\n                    alpha_E_p * np.sum(A_p * dp * (ds + es - dp)) + alpha_E_s * np.sum(A_s * ds * es))\n\n    a1 = np.sum(a1)\n    a2 = np.sum(a2)\n    a3 = np.sum(a3)\n    # Encontrar as ra\u00edzes\n    roots = np.roots([1, a1, a2, a3])  # np.roots resolve equa\u00e7\u00f5es polinomiais\n\n    if display:\n        # Exibir as solu\u00e7\u00f5es\n        # print(f\"\\n\")\n        # print(\"Coeficientes da equa\u00e7\u00e3o c\u00fabica:\", (a1, a2, a3))\n        # print(\"Ra\u00edzes da equa\u00e7\u00e3o c\u00fabica:\", roots)\n        pass\n\n    # Plotar a fun\u00e7\u00e3o para visualiza\u00e7\u00e3o\n    import matplotlib.pyplot as plt\n\n    # x_vals = np.linspace(-1, h+1, 1000)\n    # y_vals = cubic_equation(x_vals, a1, a2, a3)\n\n    # plt.figure(figsize=(8, 5))\n    # plt.plot(x_vals, y_vals, label=\"Equa\u00e7\u00e3o C\u00fabica\")\n    # plt.axhline(0, color='k', linestyle='--')\n    # plt.axvline(roots[0], color='g', linestyle=':', label=f\"Raiz 1: {roots[0]:.3f}\")\n    # if len(roots) &gt; 1:\n    #     plt.axvline(roots[1], color='b', linestyle=':', label=f\"Raiz 2: {roots[1]:.3f}\")\n    # if len(roots) &gt; 2:\n    #     plt.axvline(roots[2], color='orange', linestyle=':', label=f\"Raiz 3: {roots[2]:.3f}\")\n    # plt.axvline(0, color='r', linestyle=':', label=f\"Top\")\n    # plt.axvline(h, color='r', linestyle=':', label=f\"Bottom\")\n\n    # plt.xlabel(\"x\")\n    # plt.ylabel(\"f(x)\")\n    # plt.title(\"Solu\u00e7\u00e3o da Equa\u00e7\u00e3o C\u00fabica\")\n    # plt.legend()\n    # plt.grid(True)\n    # plt.show()\n\n    # Filtrar apenas ra\u00edzes reais e dentro do intervalo (0, h)\n    real_roots = [x.real for x in roots if np.isreal(x) and 0 &lt; x.real &lt; h]\n\n    # Retorna a raiz v\u00e1lida ou None se n\u00e3o houver solu\u00e7\u00e3o dentro do intervalo\n    return real_roots[0] if real_roots else np.nan\n</code></pre>"},{"location":"reference/eurocodepy/utils/section_properties/#eurocodepy.utils.section_properties.calc_section_T","title":"<code>calc_section_T(h, bw, bf, hf, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=False, label='SEC\u00c7\u00c3O EM T')</code>","text":"<p>Calculates the area, center of gravity, bending modulus and moment of inertia of a T-section.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Total height of the section.</p> required <code>bw</code> <code>float</code> <p>Web width of the section.</p> required <code>bf</code> <code>float</code> <p>Flange width of the section.</p> required <code>hf</code> <code>float</code> <p>Flange height of the section.</p> required <code>A_s</code> <code>float[]</code> <p>Area of the tensioned reinforcement.</p> required <code>A_sc</code> <code>float[]</code> <p>Area of the compressed reinforcement.</p> required <code>A_p</code> <code>float[]</code> <p>Area of the prestressing tendon.</p> required <code>ds</code> <code>float[]</code> <p>Distance to the tensioned reinforcement from the top.</p> required <code>dsc</code> <code>float[]</code> <p>Distance to the compressed reinforcement from the top.</p> required <code>dp</code> <code>float[]</code> <p>Distance to the prestressing tendon from the top.</p> required <code>alpha_Es</code> <code>float</code> <p>Equivalence factor of the passive steel.</p> required <code>alpha_Ep</code> <code>float</code> <p>Equivalence factor of the prestressed steel.</p> required <code>M</code> <code>float</code> <p>Bending moment.</p> required <code>P</code> <code>float</code> <p>Prestressing normal force.</p> required <code>display</code> <code>bool</code> <p>If True, displays the calculated results. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing two dictionaries, representing the properties of the uncracked and cracked sections respectively. Each dictionary contains the area, center of gravity, and moment of inertia. (prop_un, prop_cr)</p> Source code in <code>eurocodepy/utils/section_properties.py</code> <pre><code>def calc_section_T(h, bw, bf, hf, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=False, label=\"SEC\u00c7\u00c3O EM T\") -&gt; tuple:\n    \"\"\"\n    Calculates the area, center of gravity, bending modulus and moment of inertia of a T-section.\n\n    Args:\n        h (float): Total height of the section.\n        bw (float): Web width of the section.\n        bf (float): Flange width of the section.\n        hf (float): Flange height of the section.\n        A_s (float[]): Area of the tensioned reinforcement.\n        A_sc (float[]): Area of the compressed reinforcement.\n        A_p (float[]): Area of the prestressing tendon.\n        ds (float[]): Distance to the tensioned reinforcement from the top.\n        dsc (float[]): Distance to the compressed reinforcement from the top.\n        dp (float[]): Distance to the prestressing tendon from the top.\n        alpha_Es (float): Equivalence factor of the passive steel.\n        alpha_Ep (float): Equivalence factor of the prestressed steel.\n        M (float): Bending moment.\n        P (float): Prestressing normal force.\n        display (bool, optional): If True, displays the calculated results. Defaults to False.\n\n    Returns:\n        tuple: A tuple containing two dictionaries, representing the properties of the uncracked\n            and cracked sections respectively. Each dictionary contains the area, center of\n            gravity, and moment of inertia.\n            (prop_un, prop_cr)\n    \"\"\"\n    if display:\n        print(f\"\\n{label}\")\n        print(f\"   Altura total: {h:.3f}\")\n        print(f\"   Largura da alma: {bw:.3f}\")\n        print(f\"   Largura do banzo: {bf:.3f}\")\n        print(f\"   Altura do banzo: {hf:.3f}\")\n        print(f\"   \u00c1rea da armadura tracionada: {np.sum(A_s):.6f}\")\n        print(f\"   \u00c1rea da armadura comprimida: {np.sum(A_sc):.6f}\")\n        print(f\"   \u00c1rea do cabo de pr\u00e9-esfor\u00e7o: {np.sum(A_p):.6f}\")\n        print(f\"   Dist\u00e2ncia da armadura tracionada: {np.sum(ds):.3f}\")\n        print(f\"   Dist\u00e2ncia da armadura comprimida: {np.sum(dsc):.3f}\")\n        print(f\"   Dist\u00e2ncia do cabo de pr\u00e9-esfor\u00e7o: {np.sum(dp):.3f}\")\n        print(f\"   Fator de equival\u00eancia do a\u00e7o: {alpha_Es:.1f}\")\n        print(f\"   Fator de equival\u00eancia do pr\u00e9-esfor\u00e7o: {alpha_Ep:.1f}\")\n        print(f\"   Momento fletor: {M:.1f}\")\n        print(f\"   For\u00e7a normal de pr\u00e9-esfor\u00e7o: {P:.1f}\")\n    prop_un = calc_section_T_uncrack(h, bw, bf, hf, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=display)\n    prop_cr = calc_section_T_crack(h, bw, bf, hf, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=display)\n    return prop_un, prop_cr\n</code></pre>"},{"location":"reference/eurocodepy/utils/section_properties/#eurocodepy.utils.section_properties.calc_section_T_crack","title":"<code>calc_section_T_crack(h, bw, bf, hf, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=False)</code>","text":"<p>Calculates the area, center of gravity, bending modulus and moment of inertia of a cracked T-section.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Total height of the section.</p> required <code>bw</code> <code>float</code> <p>Web width of the section.</p> required <code>bf</code> <code>float</code> <p>Flange width of the section.</p> required <code>hf</code> <code>float</code> <p>Flange height of the section.</p> required <code>A_s</code> <code>float[]</code> <p>Area of the tensioned reinforcement.</p> required <code>A_sc</code> <code>float[]</code> <p>Area of the compressed reinforcement.</p> required <code>A_p</code> <code>float[]</code> <p>Area of the prestressing tendon.</p> required <code>ds</code> <code>float[]</code> <p>Distance to the tensioned reinforcement from the top.</p> required <code>dsc</code> <code>float[]</code> <p>Distance to the compressed reinforcement from the top.</p> required <code>dp</code> <code>float[]</code> <p>Distance to the prestressing tendon from the top.</p> required <code>alpha_Es</code> <code>float</code> <p>Equivalence factor of the passive steel.</p> required <code>alpha_Ep</code> <code>float</code> <p>Equivalence factor of the prestressed steel.</p> required <code>M</code> <code>float</code> <p>Bending moment.</p> required <code>P</code> <code>float</code> <p>Prestressing normal force.</p> required <code>display</code> <code>bool</code> <p>If True, displays the calculated results. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>the properties of the cracked section. The dictionary contains the area, center of gravity, and moment of inertia.</p> Source code in <code>eurocodepy/utils/section_properties.py</code> <pre><code>def calc_section_T_crack(h, bw, bf, hf, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display = False):\n    \"\"\"\n    Calculates the area, center of gravity, bending modulus and moment of inertia of a cracked T-section.\n\n    Args:\n        h (float): Total height of the section.\n        bw (float): Web width of the section.\n        bf (float): Flange width of the section.\n        hf (float): Flange height of the section.\n        A_s (float[]): Area of the tensioned reinforcement.\n        A_sc (float[]): Area of the compressed reinforcement.\n        A_p (float[]): Area of the prestressing tendon.\n        ds (float[]): Distance to the tensioned reinforcement from the top.\n        dsc (float[]): Distance to the compressed reinforcement from the top.\n        dp (float[]): Distance to the prestressing tendon from the top.\n        alpha_Es (float): Equivalence factor of the passive steel.\n        alpha_Ep (float): Equivalence factor of the prestressed steel.\n        M (float): Bending moment.\n        P (float): Prestressing normal force.\n        display (bool, optional): If True, displays the calculated results. Defaults to False.\n\n    Returns:\n        dict: the properties of the cracked section. The dictionary contains the area, center of\n            gravity, and moment of inertia.\n    \"\"\"\n\n    # if np.sum(A_s) == 0 and np.sum(A_sc) == 0 and np.sum(A_p) == 0:\n    #     return {\"Area\": 0.0, \"Inertia\": 0.0, \"zGi\": 0.0, \"zGs\": 0.0, \"Wi\": 0.0, \"Ws\": 0.0, \"NeutralAxis\": 0.0, \"e_p\": 0.0}\n\n    xi = calc_neutral_axis_cracked_T(h, bf, bw, hf, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=display)\n\n    # C\u00e1lculo da \u00e1rea da sec\u00e7\u00e3o fendilhada\n    Aun = xi * bw + hf * (bf - bw) + (alpha_Es - 1) * np.sum(A_sc) + alpha_Es * np.sum(A_s) + alpha_Ep * np.sum(A_p)\n\n    # C\u00e1lculo do centro de gravidade\n    zgs = (0.5 * xi*xi * bw + 0.5 * hf**2 * (bf - bw) + (alpha_Es - 1) * np.sum(dsc * A_sc) +\n              alpha_Es * np.sum(ds * A_s) + alpha_Ep * np.sum(dp * A_p)) / Aun\n    zg = h - zgs\n\n    if zgs &lt; hf:\n        # Se o centro de gravidade estiver dentro da banzo, a sec\u00e7\u00e3o \u00e9 como retangular com bw = bf\n        return calc_section_T_crack(h, bw, bw, 0.0, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=display)\n\n    # C\u00e1lculo do momento de in\u00e9rcia da sec\u00e7\u00e3o fendilhada\n    Iun = np.float64( \n           ((bf - bw) * hf**3) / 12 + (bf - bw) * hf * (zgs - hf / 2)**2 + \n           (bw * xi**3) / 12 + (bw * xi) * (zgs - xi / 2)**2 + \n           (alpha_Es - 1)  * np.sum(A_sc * (dsc - zgs)**2) + \n           alpha_Es * np.sum(A_s * (ds - zgs)**2) + \n           alpha_Ep * np.sum(A_p * (dp - zgs)**2))\n\n    e_p = np.round(dp - zgs, 4)\n    Ws = Iun/zgs\n    Wi = Iun/zg\n    sigma_cs = np.round(-P/Aun - (M - P * e_p) / Ws, 1)\n    sigma_p = np.round(alpha_Ep * (-P/Aun + (M - P * e_p) / Iun * e_p), 1)\n    sigma_sc = np.round(alpha_Es * (-P/Aun + (M - P * e_p) / Iun * (dsc - zgs)), 1)\n    sigma_st = np.round(alpha_Es * (-P/Aun + (M - P * e_p) / Iun * (ds - zgs)), 1)\n\n    if display:\n        print(\"Propriedades da sec\u00e7\u00e3o fendilhada\")\n        print(f\"   \u00c1rea: {Aun:.4f}\")\n        print(f\"   Momento de in\u00e9rcia: {Iun:.6f}\")\n        print(f\"   Centro de gravidade (inf): {zg:.4f}\")\n        print(f\"   Centro de gravidade (sup): {zgs:.4f}\")\n        print(f\"   M\u00f3dulo de flex\u00e3o (sup): {Ws:.6f}\")\n        print(f\"   M\u00f3dulo de flex\u00e3o (inf): {Wi:.6f}\")\n        print(f\"   Profundidade do eixo neutro: {xi:.4f}\")\n        print(f\"   Excentricidade (P): {e_p}\")\n        print(f\"   Sigma_cs: {sigma_cs}\")\n        print(f\"   Sigma_sc: {sigma_sc}\")\n        print(f\"   Sigma_st: {sigma_st}\")\n        print(f\"   Sigma_p: {sigma_p}\")\n\n    return {\"Area\": Aun, \"Inertia\": Iun, \"zGi\": zg, \"zGs\": zgs, \"Wi\": Wi, \"Ws\": Ws, \"NeutralAxis\": xi, \"e_p\": e_p}\n</code></pre>"},{"location":"reference/eurocodepy/utils/section_properties/#eurocodepy.utils.section_properties.calc_section_T_uncrack","title":"<code>calc_section_T_uncrack(h, bw, bf, hf, As, Asc, Ap, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=False)</code>","text":"<p>Calculates the area, center of gravity, bending modulus and moment of inertia of a cracked T-section.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Total height of the section.</p> required <code>bw</code> <code>float</code> <p>Web width of the section.</p> required <code>bf</code> <code>float</code> <p>Flange width of the section.</p> required <code>hf</code> <code>float</code> <p>Flange height of the section.</p> required <code>A_s</code> <code>float[]</code> <p>Area of the tensioned reinforcement.</p> required <code>A_sc</code> <code>float[]</code> <p>Area of the compressed reinforcement.</p> required <code>A_p</code> <code>float[]</code> <p>Area of the prestressing tendon.</p> required <code>ds</code> <code>float[]</code> <p>Distance to the tensioned reinforcement from the top.</p> required <code>dsc</code> <code>float[]</code> <p>Distance to the compressed reinforcement from the top.</p> required <code>dp</code> <code>float[]</code> <p>Distance to the prestressing tendon from the top.</p> required <code>alpha_Es</code> <code>float</code> <p>Equivalence factor of the passive steel.</p> required <code>alpha_Ep</code> <code>float</code> <p>Equivalence factor of the prestressed steel.</p> required <code>M</code> <code>float</code> <p>Bending moment.</p> required <code>P</code> <code>float</code> <p>Prestressing normal force.</p> required <code>display</code> <code>bool</code> <p>If True, displays the calculated results. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>the properties of the uncracked section. The dictionary contains the area, center of gravity, and moment of inertia.</p> Source code in <code>eurocodepy/utils/section_properties.py</code> <pre><code>def calc_section_T_uncrack(h, bw, bf, hf, As, Asc, Ap, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=False):\n    \"\"\"\n    Calculates the area, center of gravity, bending modulus and moment of inertia of a cracked T-section.\n\n    Args:\n        h (float): Total height of the section.\n        bw (float): Web width of the section.\n        bf (float): Flange width of the section.\n        hf (float): Flange height of the section.\n        A_s (float[]): Area of the tensioned reinforcement.\n        A_sc (float[]): Area of the compressed reinforcement.\n        A_p (float[]): Area of the prestressing tendon.\n        ds (float[]): Distance to the tensioned reinforcement from the top.\n        dsc (float[]): Distance to the compressed reinforcement from the top.\n        dp (float[]): Distance to the prestressing tendon from the top.\n        alpha_Es (float): Equivalence factor of the passive steel.\n        alpha_Ep (float): Equivalence factor of the prestressed steel.\n        M (float): Bending moment.\n        P (float): Prestressing normal force.\n        display (bool, optional): If True, displays the calculated results. Defaults to False.\n\n    Returns:\n        dict: the properties of the uncracked section. The dictionary contains the area, center of\n            gravity, and moment of inertia.\n    \"\"\"\n\n    # C\u00e1lculo da \u00e1rea equivalente em bet\u00e3o\n    Aun = h * bw + hf * (bf - bw) + (alpha_Es - 1) * (np.sum(As) + np.sum(Asc)) + (alpha_Ep - 1) * np.sum(Ap)\n\n    # C\u00e1lculo do centro de gravidade\n    zgs = (0.5 * h**2 * bw + 0.5 * hf**2 * (bf - bw) + \n           (alpha_Es - 1) * (np.sum(ds * As) + np.sum(dsc * Asc)) + \n           (alpha_Ep - 1) * np.sum(dp * Ap)) / Aun\n    zg = h - zgs\n\n    # C\u00e1lculo da in\u00e9rcia n\u00e3o fendilhada\n    Iun = np.float64(\n        (bw * h**3)/12 + (bw * h * (0.5 * h - zgs)**2) + \n        ((bf - bw) * hf**3)/12 + (hf * (bf - bw) * (0.5 * hf - zgs)**2) + \n        (alpha_Es - 1) * (np.sum(Asc * (dsc - zgs)**2) + np.sum(As * (ds - zgs)**2)) + \n        (alpha_Ep - 1) * (np.sum(Ap * (dp - zgs)**2)))\n\n    root_un = zgs + P / Aun / (M - P * np.sum(dp - zgs)) * Iun \n\n    e_p = np.round(dp - zgs, 4)\n    Ws = Iun/zgs\n    Wi = Iun/zg\n    sigma_cs = np.round(-P/Aun - (M - P * e_p) / Ws, 1)\n    sigma_ci = np.round(-P/Aun + (M - P * e_p) / Wi, 1)\n    sigma_p = np.round(alpha_Ep * (-P/Aun + (M - P * e_p) / Iun * e_p), 1)\n    sigma_sc = np.round(alpha_Es * (-P/Aun + (M - P * e_p) / Iun * (dsc - zgs)), 1)\n    sigma_st = np.round(alpha_Es * (-P/Aun + (M - P * e_p) / Iun * (ds - zgs)), 1)\n\n    if display:\n        print(\"Propriedades da sec\u00e7\u00e3o n\u00e3o fendilhada\")\n        print(f\"   \u00c1rea: {Aun:.4f}\")\n        print(f\"   Momento de in\u00e9rcia: {Iun:.6f}\")\n        print(f\"   Centro de gravidade (inf): {zg:.4f}\")\n        print(f\"   Centro de gravidade (sup): {zgs:.4f}\")\n        print(f\"   M\u00f3dulo de flex\u00e3o (sup): {Ws:.6f}\")\n        print(f\"   M\u00f3dulo de flex\u00e3o (inf): {Wi:.6f}\")\n        print(f\"   Profundidade do eixo neutro: {root_un:.4f}\")\n        print(f\"   Excentricidade (P): {e_p}\")\n        print(f\"   Sigma_cs: {sigma_cs}\")\n        print(f\"   Sigma_ci: {sigma_ci}\")\n        print(f\"   Sigma_sc: {sigma_sc}\")\n        print(f\"   Sigma_st: {sigma_st}\")\n        print(f\"   Sigma_p: {sigma_p}\")\n\n    return {\"Area\": Aun, \"Inertia\": Iun, \"zGi\": zg, \"zGs\": zgs, \"Wi\": Wi, \"Ws\": Ws, \"NeutralAxis\": root_un, \"e_p\": e_p}\n</code></pre>"},{"location":"reference/eurocodepy/utils/section_properties/#eurocodepy.utils.section_properties.calc_section_rectangular","title":"<code>calc_section_rectangular(h, b, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=False, label='SEC\u00c7\u00c3O RETANGULAR')</code>","text":"<p>Calculates the area, center of gravity, and moment of inertia of a rectangular section.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Section height.</p> required <code>b</code> <code>float</code> <p>Section width.</p> required <code>A_s</code> <code>float</code> <p>Area of tensioned reinforcement.</p> required <code>A_sc</code> <code>float</code> <p>Area of compressed reinforcement.</p> required <code>A_p</code> <code>float</code> <p>Area of prestressing tendon.</p> required <code>ds</code> <code>float</code> <p>Distance to tensioned reinforcement.</p> required <code>dsc</code> <code>float</code> <p>Distance to compressed reinforcement.</p> required <code>dp</code> <code>float</code> <p>Distance to prestressing tendon.</p> required <code>alpha_Es</code> <code>float</code> <p>Equivalence factor of passive steel.</p> required <code>alpha_Ep</code> <code>float</code> <p>Equivalence factor of prestressed steel.</p> required <code>M</code> <code>float</code> <p>Bending moment.</p> required <code>P</code> <code>float</code> <p>Prestressing normal force.</p> required <code>display</code> <code>bool</code> <p>If True, displays the results. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing two dictionaries, representing the properties of the uncracked and cracked sections respectively. Each dictionary contains the area, center of gravity, and moment of inertia. (prop_un, prop_cr)</p> Source code in <code>eurocodepy/utils/section_properties.py</code> <pre><code>def calc_section_rectangular(h, b, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display = False, label=\"SEC\u00c7\u00c3O RETANGULAR\"):\n    \"\"\"\n    Calculates the area, center of gravity, and moment of inertia of a rectangular section.\n\n    Args:\n        h (float): Section height.\n        b (float): Section width.\n        A_s (float): Area of tensioned reinforcement.\n        A_sc (float): Area of compressed reinforcement.\n        A_p (float): Area of prestressing tendon.\n        ds (float): Distance to tensioned reinforcement.\n        dsc (float): Distance to compressed reinforcement.\n        dp (float): Distance to prestressing tendon.\n        alpha_Es (float): Equivalence factor of passive steel.\n        alpha_Ep (float): Equivalence factor of prestressed steel.\n        M (float): Bending moment.\n        P (float): Prestressing normal force.\n        display (bool, optional): If True, displays the results. Defaults to False.\n\n    Returns:\n        tuple: A tuple containing two dictionaries, representing the properties of the uncracked\n            and cracked sections respectively. Each dictionary contains the area, center of\n            gravity, and moment of inertia.\n            (prop_un, prop_cr)\n    \"\"\"\n\n    if display:\n        print(f\"\\n{label}\")\n        print(f\"   Altura: {h:.3f}\")\n        print(f\"   Largura: {b:.3f}\")\n        print(f\"   \u00c1rea da armadura tracionada: {np.sum(A_s):.6f}\")\n        print(f\"   \u00c1rea da armadura comprimida: {np.sum(A_sc):.6f}\")\n        print(f\"   \u00c1rea do cabo de pr\u00e9-esfor\u00e7o: {np.sum(A_p):.6f}\")\n        print(f\"   Dist\u00e2ncia da armadura tracionada: {np.sum(ds):.3f}\")\n        print(f\"   Dist\u00e2ncia da armadura comprimida: {np.sum(dsc):.3f}\")\n        print(f\"   Dist\u00e2ncia do cabo de pr\u00e9-esfor\u00e7o: {np.sum(dp):.3f}\")\n        print(f\"   Fator de equival\u00eancia do a\u00e7o: {alpha_Es:.1f}\")\n        print(f\"   Fator de equival\u00eancia do pr\u00e9-esfor\u00e7o: {alpha_Ep:.1f}\")\n        print(f\"   Momento fletor: {M:.1f}\")\n        print(f\"   For\u00e7a normal de pr\u00e9-esfor\u00e7o: {P:.1f}\")\n    prop_un = calc_section_T_uncrack(h, b, b, 0, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=display)\n    prop_cr = calc_section_T_crack(h, b, b, 0, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=display)\n    return prop_un, prop_cr\n</code></pre>"},{"location":"reference/eurocodepy/utils/section_properties/#eurocodepy.utils.section_properties.solve_cubic","title":"<code>solve_cubic(a1, a2, a3, h)</code>","text":"<p>Resolve a equa\u00e7\u00e3o c\u00fabica x\u00b3 + a1x\u00b2 + a2x + a3 = 0 e seleciona a raiz real dentro do intervalo (0, h).</p> <p>Par\u00e2metros: a1, a2, a3 - Coeficientes da equa\u00e7\u00e3o c\u00fabica h - Altura m\u00e1xima permitida para x</p> <p>Retorna: x_real - A raiz v\u00e1lida dentro do intervalo (0, h)</p> Source code in <code>eurocodepy/utils/section_properties.py</code> <pre><code>def solve_cubic(a1, a2, a3, h):\n    \"\"\"\n    Resolve a equa\u00e7\u00e3o c\u00fabica x\u00b3 + a1*x\u00b2 + a2*x + a3 = 0\n    e seleciona a raiz real dentro do intervalo (0, h).\n\n    Par\u00e2metros:\n    a1, a2, a3 - Coeficientes da equa\u00e7\u00e3o c\u00fabica\n    h - Altura m\u00e1xima permitida para x\n\n    Retorna:\n    x_real - A raiz v\u00e1lida dentro do intervalo (0, h)\n    \"\"\"\n    # Resolver a equa\u00e7\u00e3o c\u00fabica\n    roots = np.roots([1, a1, a2, a3])  # np.roots resolve equa\u00e7\u00f5es polinomiais\n\n    # Filtrar apenas ra\u00edzes reais e dentro do intervalo (0, h)\n    real_roots = [x.real for x in roots if np.isreal(x) and 0 &lt; x.real &lt; h]\n\n    # Retorna a raiz v\u00e1lida ou None se n\u00e3o houver solu\u00e7\u00e3o dentro do intervalo\n    return real_roots[0] if real_roots else np.nan\n</code></pre>"},{"location":"reference/eurocodepy/utils/stress/","title":"stress","text":""},{"location":"reference/eurocodepy/utils/stress/#eurocodepy.utils.stress.FailureCriteria","title":"<code>FailureCriteria</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for failure criteria</p> Source code in <code>eurocodepy/utils/stress.py</code> <pre><code>class FailureCriteria(Enum):\n     \"\"\"Enum for failure criteria\"\"\"\n     MOHR_COULOMB = \"Mohr-Coulomb\"\n     MOHR_CIRCLE = \"Mohr Circle\"\n     MAX_SHEAR = \"Max Shear Stress\"\n     MAX_PRINCIPAL = \"Max Principal Stress\"\n     MIN_PRINCIPAL = \"Min Principal Stress\"\n     ELLIPTIC = \"Elliptic\"\n     HENCKY = \"Hencky\"\n     RANKINE = \"Rankine\"\n     VON_MISES = \"Von Mises\"\n     TREFFTZ = \"Trefftz\"\n     CONCRETE = \"Concrete\"\n</code></pre>"},{"location":"reference/eurocodepy/utils/stress/#eurocodepy.utils.stress.Invariant","title":"<code>Invariant</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for stress invariants</p> Source code in <code>eurocodepy/utils/stress.py</code> <pre><code>class Invariant(Enum):\n     \"\"\"Enum for stress invariants\"\"\"\n     I1 = \"I1\"\n     J2 = \"J2\"\n     J3 = \"J3\"\n     MEAN_STRESS = \"Mean Stress\"\n     EQV_STRESS = \"Equivalent Stress\"\n     LODE_R = \"Lode R\"\n     LODE_Z = \"Lode Z\"\n     LODE_THETA = \"Lode Theta\"\n     COS3T = \"Cos(3Theta)\"\n     TRIAXIALITY = \"Triaxiality\"\n</code></pre>"},{"location":"reference/eurocodepy/utils/stress/#eurocodepy.utils.stress.invariants","title":"<code>invariants(sigxx, sigyy, sigzz, sigxy, sigyz, sigzx)</code>","text":"<p>Calculates the stress invariants Author. Paulo Cachim (2022)</p> <p>Parameters:</p> Name Type Description Default <code>sigxx</code> <code>float</code> <p>stress xx</p> required <code>sigyy</code> <code>float</code> <p>stress yy</p> required <code>sigzz</code> <code>float</code> <p>stress zz</p> required <code>sigxy</code> <code>float</code> <p>stress xy</p> required <code>sigyz</code> <code>float</code> <p>stress yz</p> required <code>sigzx</code> <code>float</code> <p>stress zx</p> required <p>Returns:</p> Type Description <code>list</code> <p>stress invariants (list): I1, J2, J3, mean_stress, eqv_stress,            lode_r, lode_z, lode_theta, cos3t, triaxiality</p> Source code in <code>eurocodepy/utils/stress.py</code> <pre><code>def invariants(sigxx: float, sigyy: float, sigzz: float, \n                         sigxy: float, sigyz: float, sigzx: float) -&gt; list:\n     \"\"\"Calculates the stress invariants\n     Author. Paulo Cachim (2022)\n\n     Args:\n          sigxx (float): stress xx\n          sigyy (float): stress yy\n          sigzz (float): stress zz\n          sigxy (float): stress xy\n          sigyz (float): stress yz\n          sigzx (float): stress zx\n\n     Returns:\n          stress invariants (list): I1, J2, J3, mean_stress, eqv_stress, \n                         lode_r, lode_z, lode_theta, cos3t, triaxiality\n     \"\"\"\n     #stresses = [0.0,0.0,0.0,0.0,0.0,0.0]\n\n     # load the stresses into our matrix and compute the \n     # deviatoric and isotropic stress matricies\n     sigma = np.array([[sigxx,sigxy,sigzx],\n                         [sigxy,sigyy,sigyz],\n                         [sigzx,sigyz,sigzz]])\n     sigma_iso = (np.trace(sigma)*np.eye(3))/3.0\n     sigma_dev = sigma - sigma_iso\n\n     # # compute max shear stress\n     # maxshear = (max(eigvals)-min(eigvals))/2.0\n\n     # compute the stress invariants\n     I1 = np.trace(sigma)\n     J2 = 0.5*np.trace(np.dot(sigma_dev,sigma_dev))\n     J3 = 0.333333333333333333*np.trace(np.dot(sigma_dev,np.dot(sigma_dev,sigma_dev)))\n\n     # compute other common stress measures\n     mean_stress = I1/3.0\n     eqv_stress  = math.sqrt(3.0*J2)\n\n     # compute lode coordinates\n     lode_r = math.sqrt(2.0*J2)\n     lode_z = I1/math.sqrt(3.0)\n\n     stresses = 3.0*math.sqrt(6.0)*np.linalg.det(sigma_dev/lode_r)\n     if stresses &lt; -1: stresses = -1\n     if stresses &gt; 1: stresses = 1\n     lode_theta = 1.0/3.0*math.asin(stresses)\n     cos3t = 2.5980762114*J3/(J2**1.5)\n\n     # compute the stress triaxiality\n     triaxiality = mean_stress/eqv_stress\n\n     return I1, J2, J3, mean_stress, eqv_stress, lode_r, lode_z, lode_theta, cos3t, triaxiality\n</code></pre>"},{"location":"reference/eurocodepy/utils/stress/#eurocodepy.utils.stress.principal_vectors","title":"<code>principal_vectors(sigxx, sigyy, sigzz, sigxy, sigyz, sigzx)</code>","text":"<p>Calculates the princcipal vectors (size proportional to principal stresses) Author. Paulo Cachim (2022)</p> <p>Parameters:</p> Name Type Description Default <code>sigxx</code> <code>float</code> <p>stress xx</p> required <code>sigyy</code> <code>float</code> <p>stress yy</p> required <code>sigzz</code> <code>float</code> <p>stress zz</p> required <code>sigxy</code> <code>float</code> <p>stress xy</p> required <code>sigyz</code> <code>float</code> <p>stress yz</p> required <code>sigzx</code> <code>float</code> <p>stress zx</p> required <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>an array of the principal vectors</p> Source code in <code>eurocodepy/utils/stress.py</code> <pre><code>def principal_vectors(sigxx: float, sigyy: float, sigzz: float, \n               sigxy: float, sigyz: float, sigzx: float) -&gt; np.ndarray:\n     \"\"\"Calculates the princcipal vectors (size proportional to principal stresses)\n     Author. Paulo Cachim (2022)\n\n     Args:\n          sigxx (float): stress xx\n          sigyy (float): stress yy\n          sigzz (float): stress zz\n          sigxy (float): stress xy\n          sigyz (float): stress yz\n          sigzx (float): stress zx\n\n     Returns:\n          ndarray: an array of the principal vectors\n     \"\"\"\n\n     values, vectors = np.linalg.eigh(np.array([[sigxx,sigxy,sigzx],\n                         [sigxy,sigyy,sigyz],\n                         [sigzx,sigyz,sigzz]]))\n\n     v = vectors * np.array([values[0]*vectors[0], \n                    values[1]*vectors[1], \n                    values[2]*vectors[2]])\n     return v\n</code></pre>"},{"location":"reference/eurocodepy/utils/stress/#eurocodepy.utils.stress.principals","title":"<code>principals(sigxx, sigyy, sigzz, sigxy, sigyz, sigzx)</code>","text":"<p>Calculate the principal stresses and the normalized principal directions Author. Paulo Cachim (2022)</p> <p>Parameters:</p> Name Type Description Default <code>sigxx</code> <code>float</code> <p>stress xx</p> required <code>sigyy</code> <code>float</code> <p>stress yy</p> required <code>sigzz</code> <code>float</code> <p>stress zz</p> required <code>sigxy</code> <code>float</code> <p>stress xy</p> required <code>sigyz</code> <code>float</code> <p>stress yz</p> required <code>sigzx</code> <code>float</code> <p>stress zx</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>ndarray, ndarray: the principal stresses and the normalized principal directions</p> Source code in <code>eurocodepy/utils/stress.py</code> <pre><code>def principals(sigxx: float, sigyy: float, sigzz: float, \n               sigxy: float, sigyz: float, sigzx: float) -&gt; np.ndarray:\n     \"\"\"Calculate the principal stresses and the normalized principal directions\n     Author. Paulo Cachim (2022)\n\n     Args:\n          sigxx (float): stress xx\n          sigyy (float): stress yy\n          sigzz (float): stress zz\n          sigxy (float): stress xy\n          sigyz (float): stress yz\n          sigzx (float): stress zx\n\n     Returns:\n          ndarray, ndarray: the principal stresses and the normalized principal directions\n     \"\"\"\n     return np.linalg.eigh(np.array([[sigxx,sigxy,sigzx],\n                         [sigxy,sigyy,sigyz],\n                         [sigzx,sigyz,sigzz]]))\n</code></pre>"}]}