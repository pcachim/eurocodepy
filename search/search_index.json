{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This site contains the project documentation for the eurocodepy project that is a python package for using Eurocodes.</p> <p>IMPORTANT: This documentation is a work in progress and is not complete yet (and don't know if it will ever be...).s</p>"},{"location":"#projet-overview","title":"Projet overview","text":"<p>Eurocodepy is a Python package that provides functions to work with structural Eurocodes. It includes material properties, load combinations, and other utilities for structural engineering calculations.</p> <p>Material data is stored in a JSON file. Current materials in the database are:</p> <ul> <li>concrete (C20 to C90)</li> <li>timber (C, D, GL)</li> <li>reinforcement (B400, B500, A400, A500)</li> <li>structural steel (S235, S275, S355, S450)</li> <li>prestressing steel (Y1770, Y1860, ...)</li> <li>bolts (4.6 to 10.9)</li> </ul> <p>Available european steel profiles are:</p> <ul> <li>IPE</li> <li>HEA, HEB, HEM</li> <li>CHS, RHS, SHS</li> </ul> <p>There are also some functions to work with material properties:</p> <ul> <li>creep_coef</li> <li>shrink_strain</li> </ul> <p>The existing functions are listed in the page 'Reference'.</p>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<p>This documentation is divided into several sections to help you navigate through the project:</p> <ul> <li>Home</li> <li>Tutorials</li> <li>Modules</li> <li>Reference</li> <li>License</li> </ul>"},{"location":"#support","title":"Support","text":"<p>If you need any help you can contact the developer via email.</p> <p>Github: http://github.com/pcachim/eurocodepy</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>I want to thank my plants for providing me with an amount of oxygen each day. Also, I want to thank the sun for providing more than half of their nourishment free of charge.</p>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at [INSERT EMAIL ADDRESS]. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project contributors who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p>"},{"location":"STYLE_GUIDE/","title":"Python Style Guide","text":"<p>This document outlines the guidelines for writing Python code for our project. Following these guidelines helps ensure that the code is consistent and easy to read.</p>"},{"location":"STYLE_GUIDE/#code-formatting","title":"Code Formatting","text":"<ul> <li>Use 4 spaces for indentation.</li> <li>Use a space after the # for inline comments.</li> <li>Use blank lines to separate logical sections of code.</li> </ul> <pre><code>if x &gt; 0:\n    print('x is positive')\nelse:\n    print('x is non-positive')\n\n# This is an inline comment.\n\ndef function_name(parameter):\n    # Code inside function.\n</code></pre>"},{"location":"STYLE_GUIDE/#naming-conventions","title":"Naming Conventions","text":""},{"location":"STYLE_GUIDE/#variables","title":"Variables","text":"<ul> <li>Use descriptive names that accurately reflect the purpose of the variable.</li> <li>Use snake_case for variable names.</li> </ul> <pre><code>number_of_items = 5\ntotal_price = 10.50\n</code></pre>"},{"location":"STYLE_GUIDE/#functions","title":"Functions","text":"<ul> <li>Use descriptive names that accurately reflect the purpose of the function.</li> <li>Use snake_case for function names.</li> </ul> <pre><code>def calculate_total_price(quantity, price):\n    return quantity * price\n````\n\n### Classes\n\n- Use PascalCase for class names.\n\n```python\nclass User:\n    # ...\n````\n\n### File Names\n\n- Use snake_case for file names.\n\n```text\nmain_script.py\nuser_profile.py\n</code></pre>"},{"location":"STYLE_GUIDE/#comments","title":"Comments","text":"<ul> <li>Use comments to explain non-obvious or complex code.</li> <li>Use complete sentences and proper grammar.</li> <li>Begin comments with a capital letter.</li> <li>Use one space after the # for inline comments.</li> <li>Use multi-line comments for longer explanations.</li> </ul> <pre><code># Add the value to the list.\nmy_list.append(value)\n\n\"\"\"\nThis function takes two parameters:\n- name: a string representing the name of the user\n- age: an integer representing the age of the user\n\nIt returns a greeting message.\n\"\"\"\ndef greet(name, age):\n    # ...\n</code></pre>"},{"location":"STYLE_GUIDE/#miscellaneous","title":"Miscellaneous","text":"<ul> <li>Use double quotes for strings.</li> <li>Use parentheses for tuple packing and unpacking.</li> <li>Always use is or is not to compare with None.</li> <li>Use a blank line before and after a return statement.</li> <li>Use None instead of '' or [] for default values of function arguments.</li> </ul> <p>```python message = \"Hello, world!\" print(message)</p> <p>a, b, c = (1, 2, 3)</p> <p>if x is None:     # ...</p> <p>def my_function(arg1, arg2=None):     # ...</p> <p>def my_other_function(arg1, arg2=[]):     # This is bad.</p> <p>def my_good_function(arg1, arg2=None):     if arg2 is None:         arg2 = []     # ... ````</p>"},{"location":"STYLE_GUIDE/#resources","title":"Resources","text":"<p>PEP 8 -- Style Guide for Python Code\\ Google Python Style Guide\\ Python Code Style: A Guide to Writing Readable Code</p>"},{"location":"copyright/","title":"Contributing Guidelines and Copyright Notice","text":""},{"location":"copyright/#contributing-guidelines","title":"Contributing Guidelines","text":"<p>We welcome contributions from everyone. Please read these guidelines before submitting a pull request or issue.</p>"},{"location":"copyright/#code-of-conduct","title":"Code of Conduct","text":"<p>We expect all contributors to adhere to our Code of Conduct. Please read it before contributing.</p>"},{"location":"copyright/#issues","title":"Issues","text":"<p>If you find a bug or have a feature request, please submit an issue on our GitHub issue tracker. Please check the existing issues to make sure your issue hasn't already been reported.</p> <p>When submitting an issue, please provide as much detail as possible, including steps to reproduce the issue if applicable.</p>"},{"location":"copyright/#pull-requests","title":"Pull Requests","text":"<p>We welcome pull requests from everyone. Please ensure that your PR adheres to the following guidelines:</p> <ol> <li>Before submitting a PR, please create an issue first and wait for approval from a project maintainer.</li> <li>Your code should follow our style guide.</li> <li>Write tests for any new functionality.</li> <li>Ensure that all tests pass before submitting your pull request.</li> <li>Include documentation for any new functionality you've added.</li> <li>Make sure your code has no linter errors or warnings.</li> <li>Be sure to explain what your changes do and why they are necessary.</li> </ol>"},{"location":"copyright/#getting-started","title":"Getting Started","text":"<p>To get started with contributing, take a look at the issues on our GitHub issue tracker. If you have any questions or need any help, please don't hesitate to reach out to us on Slack.</p> <p>Thank you for contributing to our project!</p>"},{"location":"copyright/#copyright-notice","title":"Copyright Notice","text":"<p>Copyright (c) 2025 Paulo Cachim</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"explanation/","title":"Background","text":"<p>This part of the project documentation focuses on an understanding-oriented approach. You'll get a chance to read about the background of the project, as well as reasoning about how it was implemented.</p> <p>Note: Expand this section by considering the following points:</p> <ul> <li>Give context and background on your library</li> <li>Explain why you created it</li> <li>Provide multiple examples and approaches of how     to work with it</li> <li>Help the reader make connections</li> <li>Avoid writing instructions or technical descriptions     here</li> </ul>"},{"location":"how-to-guides/","title":"How-to guides","text":"<p>This section of the documentation provides practical guides on how to use the eurocodepy package to solve specific problems or perform common tasks. It is designed to help users quickly find solutions to their needs without having to delve into the full reference documentation.</p>"},{"location":"how-to-guides/#table-of-contents","title":"Table of Contents","text":"<ul> <li>To be completed...</li> </ul>"},{"location":"tutorials/","title":"Tutorials","text":"<p>This section of the documentation provides practical guides on how to use the eurocodepy package to solve specific problems or perform common tasks. It is designed to help users quickly find solutions to their needs without having to delve into the full reference documentation.</p>"},{"location":"tutorials/#tutorial-1","title":"Tutorial 1","text":"<p>Tutorial 1</p>"},{"location":"tutorials/#tutorial-2","title":"Tutorial 2","text":"<p>Tutorial 2</p>"},{"location":"modules/ec1/","title":"Eurocode 1 module: <code>ec1</code>","text":""},{"location":"modules/ec1/#overview","title":"Overview","text":"<p>The <code>ec1</code> module of the eurocodepy package provides tools for the analysis and design of structures subjected to actions as defined in Eurocode 1 (EN 1991). It is intended for engineers who need to calculate loads such as self-weight, imposed loads, wind, snow, and thermal actions in accordance with Eurocode 1 standards.</p>"},{"location":"modules/ec1/#features","title":"Features","text":"<ul> <li>Load Calculations   Functions to calculate self-weight, imposed loads, wind loads, snow loads, and thermal actions for buildings and civil engineering works.</li> <li>Parameter Flexibility   Input parameters include geometry, location, exposure, and usage category.</li> </ul>"},{"location":"modules/ec1/#typical-usage","title":"Typical Usage","text":"<pre><code>from eurocodepy.ec1 import wind_load, snow_load, imposed_load\n\n# Calculate wind load\nwind = wind_load(height=15, exposure='B', location='coastal')\n\n# Calculate snow load\nsnow = snow_load(altitude=500, location='mountain')\n\n# Calculate imposed load for office\nimposed = imposed_load(category='B', area=50)\n</code></pre>"},{"location":"modules/ec1/#compliance","title":"Compliance","text":"<p>All calculations and checks are based on the requirements and recommendations of Eurocode 1 (EN 1991). The module is updated to reflect changes and amendments to the code.</p>"},{"location":"modules/ec1/#further-reading","title":"Further Reading","text":"<ul> <li>Eurocode 1: Actions on structures (EN 1991)</li> </ul>"},{"location":"modules/ec2/","title":"Eurocode 2 module: <code>ec2</code>","text":""},{"location":"modules/ec2/#overview","title":"Overview","text":"<p>The <code>ec2</code> module of the eurocodepy package provides a toolkit for the analysis and design of reinforced concrete structures in accordance with Eurocode 2 (EN 1992-1-1). It is intended for engineers and researchers who require reliable and efficient tools for structural calculations, checks, and code compliance.</p>"},{"location":"modules/ec2/#features","title":"Features","text":"<ul> <li>Section Analysis   Calculate section properties for rectangular, T, and other common concrete sections.</li> <li>Material Models   Access and use concrete and reinforcement grades as per Eurocode 2.</li> <li>Crack Control   Functions for crack width calculation, reinforcement ratio, and crack spacing.</li> <li>Serviceability Limit States (SLS)   Tools for deflection, crack width, and stress checks.</li> <li>Ultimate Limit States (ULS)   Flexural, shear, and axial capacity checks for reinforced concrete members.</li> <li>Utilities   Helper functions for geometric and mechanical properties, modular ratios, and more.</li> </ul>"},{"location":"modules/ec2/#typical-usage","title":"Typical Usage","text":"<pre><code>from eurocodepy.ec2 import Concrete, Reinforcement, crack_opening, sr_max\n\n# Define materials\nconc = Concrete('C30/37')\nreinf = Reinforcement('B500B')\n\n# Section and reinforcement data\nb = 300      # mm\nh = 500      # mm\nphi = 16     # mm\nAs = 4 * 201 # mm\u00b2 (4 bars of 16 mm)\nc = 25       # mm (cover)\n\n# Calculate effective reinforcement ratio, crack spacing, and crack width\nAc_eff = b * 100  # Example effective area in tension [mm\u00b2]\nrho_p_eff = As / Ac_eff\ns_r_max = sr_max(c, phi, rho_p_eff)\n# ... further calculations for crack width, etc.\n</code></pre>"},{"location":"modules/ec2/#compliance","title":"Compliance","text":"<p>All calculations and checks are based on the requirements and recommendations of Eurocode 2 (EN 1992-1-1).</p>"},{"location":"modules/ec2/#further-reading","title":"Further Reading","text":"<ul> <li>Eurocode 2: Design of concrete structures (EN 1992-1-1)</li> <li>eurocodepy Documentation</li> </ul>"},{"location":"modules/ec3/","title":"Eurocode 3 module: <code>ec3</code>","text":""},{"location":"modules/ec3/#overview","title":"Overview","text":"<p>The <code>ec3</code> module of the eurocodepy package provides a toolkit for the analysis and design of steel structures in accordance with Eurocode 3 (EN 1993-1-1). It is intended for engineers and researchers who require reliable and efficient tools for structural calculations, checks, and code compliance for steel members and connections.</p>"},{"location":"modules/ec3/#features","title":"Features","text":"<ul> <li>Section Analysis   Calculate section properties for common steel profiles (I, H, channel, angle, etc.).</li> <li>Material Models   Access and use steel grades and material properties as per Eurocode 3.</li> <li>Member Checks   Functions for cross-section classification, axial, bending, shear, and combined checks.</li> <li>Buckling and Stability   Tools for flexural, lateral-torsional, and local buckling checks.</li> <li>Connection Design   Utilities for bolted and welded connection design and verification.</li> <li>Serviceability Limit States (SLS)   Deflection and vibration checks for steel members.</li> <li>Utilities   Helper functions for geometric and mechanical properties, slenderness, and more.</li> </ul>"},{"location":"modules/ec3/#typical-usage","title":"Typical Usage","text":"<pre><code>from eurocodepy.ec3 import Steel, Section, member_buckling_check, cross_section_class\n\n# Define material and section\nsteel = Steel('S355')\nsection = Section('IPE300')\n\n# Section properties\narea = section.area\nIy = section.Iy\n\n# Cross-section classification\ncls = cross_section_class(section, steel)\n\n# Member buckling check\nN_Ed = 500e3  # Applied axial force [N]\nL = 6.0       # Member length [m]\nbuckling_ok = member_buckling_check(section, steel, N_Ed, L)\n</code></pre>"},{"location":"modules/ec3/#compliance","title":"Compliance","text":"<p>All calculations and checks are based on the requirements and recommendations of Eurocode 3 (EN 1993-1-1).</p>"},{"location":"modules/ec3/#further-reading","title":"Further Reading","text":"<ul> <li>Eurocode 3: Design of steel structures (EN 1993-1-1)</li> <li>eurocodepy Documentation</li> </ul>"},{"location":"modules/ec5/","title":"Eurocode 5 Module: <code>ec5</code>","text":""},{"location":"modules/ec5/#overview","title":"Overview","text":"<p>The <code>ec5</code> module of the eurocodepy package provides tools for the analysis and design of timber structures in accordance with Eurocode 5 (EN 1995-1-1). It is intended for engineers and researchers who require reliable and efficient tools for structural calculations, checks, and code compliance for timber members and assemblies.</p>"},{"location":"modules/ec5/#features","title":"Features","text":"<ul> <li>Material Models   Access characteristic and mean properties for solid timber (softwood, hardwood), glulam, and other timber products.</li> <li>Service Classes and Load Duration   Enumerations and functions for risk class, service class, and load duration as per Eurocode 5.</li> <li>Strength and Stiffness Parameters   Retrieve characteristic strengths, moduli of elasticity, shear moduli, and densities for a wide range of timber grades.</li> <li>Modification and Partial Factors   Functions for kmod, kdef, and other modification and safety factors.</li> <li>Extensible Classes   Base and specialized classes for Solid Timber, Glulam, CLT, LVL, and Wood-Based Panels.</li> </ul>"},{"location":"modules/ec5/#typical-usage","title":"Typical Usage","text":"<pre><code>from eurocodepy.ec5.materials import Timber, SolidTimber, Glulam, ServiceClass, LoadDuration\n\n# Create a solid timber object (e.g., C24)\ntimber = SolidTimber('C24')\n\n# Access characteristic bending strength\nfmk = timber.fmk\n\n# Get kmod for Service Class 1 and Medium load duration\nkmod = timber.k_mod(service_class=ServiceClass.SC1, load_duratiom=LoadDuration.Medium)\n\n# Create a glulam object (e.g., GL24h)\nglulam = Glulam('GL24h')\nE0mean = glulam.E0mean\n</code></pre>"},{"location":"modules/ec5/#compliance","title":"Compliance","text":"<p>All calculations and checks are based on the requirements and recommendations of Eurocode 5 (EN 1995-1-1). The module is updated to reflect changes and amendments to the code.</p>"},{"location":"modules/ec5/#further-reading","title":"Further Reading","text":"<ul> <li>Eurocode 5: Design of timber structures (EN 1995-1-1)</li> </ul>"},{"location":"modules/ec7/","title":"Eurocode 7 Module: <code>ec7</code>","text":""},{"location":"modules/ec7/#overview","title":"Overview","text":"<p>The <code>ec7</code> module of the eurocodepy package is a toolkit designed to assist engineers and geotechnical professionals in calculating and analyzing earth pressure coefficients and soil bearing capacity based on Eurocode 7 (EN 1997) standards.</p>"},{"location":"modules/ec7/#features","title":"Features","text":"<ul> <li> <p>Active Earth Pressure Analysis   Perform active earth pressure calculations according to Eurocode 7.   Input parameters include soil properties, wall geometry, and external loads.   Output results include the magnitude and distribution of active earth pressure on the retaining structure.</p> </li> <li> <p>Soil Bearing Capacity Analysis   Calculate soil bearing capacity based on Eurocode 7 guidelines.   Input parameters include soil properties, foundation geometry, and relevant loadings.   Output results include the ultimate and allowable bearing capacities for shallow foundations.</p> </li> </ul>"},{"location":"modules/ec7/#typical-usage","title":"Typical Usage","text":"<pre><code>from eurocodepy.ec7 import pressure_coefficients, bearing_resistance\n\n# Example for Active Earth Pressure\nactive_pressure_calculator = ActiveEarthPressure()\nactive_pressure_calculator.set_soil_properties(...)\nactive_pressure_calculator.set_wall_geometry(...)\nactive_pressure_calculator.set_external_loads(...)\nactive_pressure_calculator.calculate_active_pressure()\nresults = active_pressure_calculator.get_results()\n\n# Example for Soil Bearing Capacity\nbearing_capacity_calculator = SoilBearingCapacity()\nbearing_capacity_calculator.set_soil_properties(...)\nbearing_capacity_calculator.set_foundation_geometry(...)\nbearing_capacity_calculator.set_loadings(...)\nbearing_capacity_calculator.calculate_bearing_capacity()\nresults = bearing_capacity_calculator.get_results()\n</code></pre>"},{"location":"modules/ec7/#compliance","title":"Compliance","text":"<p>All calculations and checks are based on the requirements and recommendations of Eurocode 7 (EN 1997). The module is updated to reflect changes and amendments to the code.</p>"},{"location":"modules/ec7/#further-reading","title":"Further Reading","text":"<ul> <li>Eurocode 7: Geotechnical design (EN 1997)</li> <li>[eurocodepy Documentation](../index</li> </ul>"},{"location":"modules/ec8/","title":"Eurocode 8 module: <code>ec8</code>","text":""},{"location":"modules/ec8/#overview","title":"Overview","text":"<p>The <code>ec8</code> module of the eurocodepy package provides tools for seismic analysis and design in accordance with Eurocode 8 (EN 1998-1). It enables engineers and researchers to generate design response spectra, retrieve national annex parameters, and visualize or export spectra for use in structural analysis.</p>"},{"location":"modules/ec8/#features","title":"Features","text":"<ul> <li>Design Spectrum Generation   Compute elastic response spectra for different countries, codes, soil types, seismic zones, and importance classes.</li> <li>National Annex Support   Includes standard Eurocode and Portuguese National Annex parameters.</li> <li>Parameter Retrieval   Functions to obtain soil amplification, reference acceleration, and spectrum shape parameters.</li> <li>Custom/User-Defined Spectra   Generate spectra for user-specified parameters.</li> <li>Visualization and Export   Plot spectra using matplotlib and export to CSV for use in structural software.</li> </ul>"},{"location":"modules/ec8/#typical-usage","title":"Typical Usage","text":"<pre><code>from eurocodepy.ec8.spectrum import get_spectrum_ec8, draw_spectrum_ec8\n\n# Generate a spectrum for Portugal, standard code, importance class II, soil C, zone 1_2, q=3.0\nspec = get_spectrum_ec8(\n    locale='PT',\n    code='PT-1',\n    imp_class='II',\n    soil='C',\n    zone='1_2',\n    behaviour=3.0\n)\n\n# Plot the spectrum\ndraw_spectrum_ec8(spec, show=True)\n\n# Export the spectrum to CSV\nfrom eurocodepy.ec8.spectrum import write_spectrum_ec8\nwrite_spectrum_ec8(spec, filename='spectrum_PT1_II_C_1_2.csv')\n</code></pre>"},{"location":"modules/ec8/#compliance","title":"Compliance","text":"<p>All calculations and checks are based on the requirements and recommendations of Eurocode 8 (EN 1998-1), including support for national annexes.</p>"},{"location":"modules/ec8/#further-reading","title":"Further Reading","text":"<ul> <li>Eurocode 8: Design of structures for earthquake resistance (EN 1998-1)</li> </ul>"},{"location":"modules/utils/","title":"Utilities module: <code>utils</code>","text":""},{"location":"modules/utils/#overview","title":"Overview","text":"<p>The <code>utils</code> module of the eurocodepy package provides a set of helper functions and classes to support geometric, mechanical, and mathematical operations commonly needed in structural engineering calculations. These utilities are used throughout the package to simplify section property calculations, conversions, and general-purpose tasks.</p>"},{"location":"modules/utils/#features","title":"Features","text":"<ul> <li>Section Geometry Calculations   Functions for calculating properties of rectangular and T, section shapes, cracked and uncracked.</li> <li>Principal stresses   Tools for conversioncalculation of principal stress vectors and values and stress invariants.</li> <li>General Helpers   Functions for modular ratio, centroid, and other common engineering calculations.</li> </ul>"},{"location":"modules/utils/#typical-usage","title":"Typical Usage","text":"<pre><code>from eurocodepy.utils import calc_section_rectangular, sqrt_sum_of_squares\n\n# Calculate properties of a rectangular section\nb = 300  # mm\nh = 500  # mm\nsection = calc_section_rectangular(b, h)\nprint(\"Area:\", section['area'])\nprint(\"Moment of inertia:\", section['Iy'])\n\n# Calculate the square root of the sum of squares of a list\nvalues = [3, 4, 12]\nresult = sqrt_sum_of_squares(values)\nprint(\"sqrt(sum of squares):\", result)\n</code></pre>"},{"location":"modules/utils/#further-reading","title":"Further reading","text":"<ul> <li>eurocodepy Documentation</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>eurocodepy<ul> <li>dbase</li> <li>ec1<ul> <li>combos</li> <li>snow</li> <li>wind<ul> <li>pressure</li> </ul> </li> </ul> </li> <li>ec2<ul> <li>fire<ul> <li>fire_base</li> </ul> </li> <li>materials</li> <li>sls<ul> <li>crack</li> <li>creep</li> <li>shrinkage</li> </ul> </li> <li>uls<ul> <li>beam</li> <li>bend_circ</li> <li>shear</li> <li>shell</li> </ul> </li> </ul> </li> <li>ec3<ul> <li>uls</li> </ul> </li> <li>ec5<ul> <li>materials</li> <li>sls<ul> <li>deformation</li> <li>vibration</li> </ul> </li> </ul> </li> <li>ec7<ul> <li>bearing_capacity</li> <li>earth_pressures</li> <li>materials</li> </ul> </li> <li>ec8<ul> <li>spectrum</li> </ul> </li> <li>params</li> <li>utils<ul> <li>dict_tools</li> <li>plotly_templates</li> <li>section_properties</li> <li>stress</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/eurocodepy/","title":"eurocodepy","text":"<p>Provide several functions to help designers working with Eurocodes.</p> <p>The package provides modules for different Eurocodes and utilities, such as:</p> <ul> <li><code>dbase</code>: access to the database of materials, loads, sections, etc.</li> <li><code>utils</code>: utility functions for calculations, stress, and section properties.</li> <li><code>ec1</code>: utility functions for ec1 calculations.</li> <li><code>ec2</code>: utility functions for ec2 calculations.</li> <li><code>ec3</code>: utility functions for ec3 calculations.</li> <li><code>ec5</code>: utility functions for ec5 calculations.</li> <li><code>ec7</code>: utility functions for ec7 calculations.</li> <li><code>ec8</code>: utility functions for ec8 calculations.</li> </ul>"},{"location":"reference/eurocodepy/#eurocodepy.__version__","title":"<code>__version__ = '2025.6.8'</code>  <code>module-attribute</code>","text":"<p>Version of EurocodePy package.</p>"},{"location":"reference/eurocodepy/#eurocodepy.print_version","title":"<code>print_version = \"This is 'EurocodePy' version \" + __version__</code>  <code>module-attribute</code>","text":"<p>Prints the version of EurocodePy package.</p>"},{"location":"reference/eurocodepy/#eurocodepy.get_national_params","title":"<code>get_national_params(local=locale.PT, concelho='Lisboa')</code>","text":"<p>Get Portuguese data for municipalities.</p> <p>Parameters:</p> Name Type Description Default <code>local</code> <code>locale</code> <p>Locale to use for national parameters.</p> <code>PT</code> <code>concelho</code> <code>str</code> <p>Municipality name. Defaults to \"Lisboa\".</p> <code>'Lisboa'</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>object</code> <p>the data</p> Source code in <code>eurocodepy/__init__.py</code> <pre><code>def get_national_params(local: locale = locale.PT, concelho: str = \"Lisboa\") -&gt; object:\n    \"\"\"Get Portuguese data for municipalities.\n\n    Args:\n        local (locale, optional): Locale to use for national parameters.\n        Defaults to locale.PT.\n        concelho (str, optional): Municipality name. Defaults to \"Lisboa\".\n\n    Returns:\n        dict: the data\n\n    \"\"\"\n    pt_data = locale[local.name]\n    row = pt_data[pt_data[\"Concelho\"] == concelho]\n    # Convert to dict if found\n    if not row.empty:\n        result = row.iloc[0].to_dict()\n        print(result)  # noqa: T201\n    else:\n        result = None\n        print(\"Concelho not found.\")  # noqa: T201\n    return result\n</code></pre>"},{"location":"reference/eurocodepy/dbase/","title":"dbase","text":""},{"location":"reference/eurocodepy/dbase/#eurocodepy.dbase.dict2obj","title":"<code>dict2obj(dict1)</code>","text":"<p>Convert a dictionary to a custom object using json.loads and object_hook.</p> <p>Parameters:</p> Name Type Description Default <code>dict1</code> <code>dict</code> <p>The input dictionary.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A custom object representing the dictionary.</p> Source code in <code>eurocodepy/dbase.py</code> <pre><code>def dict2obj(dict1: dict) -&gt; str:\n    \"\"\"Convert a dictionary to a custom object using json.loads and object_hook.\n\n    Args:\n        dict1: The input dictionary.\n\n    Returns:\n        A custom object representing the dictionary.\n\n    \"\"\"\n\n    class Obj:\n        \"\"\"Custom object class used as the object_hook.\"\"\"\n\n        def __init__(self, dict1: dict) -&gt; None:\n            \"\"\"Update the object's __dict__ with the dictionary.\"\"\"\n            self.__dict__.update(dict1)\n\n    return json.loads(json.dumps(dict1), object_hook=Obj)\n</code></pre>"},{"location":"reference/eurocodepy/dbase/#eurocodepy.dbase.wind_get_params","title":"<code>wind_get_params(code='PT', zone='ZonaA', terrain='II')</code>","text":"<p>Return the wind parameters for the specified code.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing (vb0, zmin, z0), where vb0 is the base wind velocity,</p> <code>tuple</code> <p>zmin is the minimum height, and z0 is the terrain roughness length.</p> Source code in <code>eurocodepy/dbase.py</code> <pre><code>def wind_get_params(code: str = \"PT\", zone: str = \"ZonaA\",\n                    terrain: str = \"II\") -&gt; tuple:\n    \"\"\"Return the wind parameters for the specified code.\n\n    Returns:\n        tuple: A tuple containing (vb0, zmin, z0), where vb0 is the base wind velocity,\n        zmin is the minimum height, and z0 is the terrain roughness length.\n\n    \"\"\"\n    wind = WindLoads[\"locale\"][code]\n    vb0 = wind[\"base_velocity\"][zone][\"vb0\"]\n    z0 = wind[\"terrain\"][terrain][\"z0\"]\n    zmin = wind[\"terrain\"][terrain][\"zmin\"]\n    return vb0, zmin, z0\n</code></pre>"},{"location":"reference/eurocodepy/params/","title":"params","text":""},{"location":"reference/eurocodepy/params/#eurocodepy.params.seismic_get_params","title":"<code>seismic_get_params(code, seismic_type, soil_type, importance_class)</code>","text":"<p>Get the seismic spectrum parameters.</p> <p>This function retrieves the seismic spectrum parameters from the SeismicLoads database based on the provided parameters. It returns a dictionary containing the spectrum parameters, including the importance coefficient. The parameters are case-insensitive for soil type and importance class, but the seismic type should be provided in uppercase. The function is designed to work with different localization codes, such as \"PT\" for Portugal or \"EU\" for standard CEN. The seismic types can include \"PT1\", \"PT2\", \"PTA\" for Portugal, or \"CEN-1\", \"CEN-2\" for CEN standards. This function is useful for engineers and designers who need to apply seismic loads according to Eurocode standards.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Localization code (e.g., \"PT\" for Portugal, \"EU\" for standard CEN).</p> required <code>seismic_type</code> <code>str</code> <p>type of seismic action (e.g., \"PT1\", \"PT2\", \"PTA\", \"CEN-1\", \"CEN-2\").</p> required <code>soil_type</code> <code>str</code> <p>soil type (e.g., \"A\", \"B\", \"C\", \"D\", \"E\" for different soil conditions).</p> required <code>importance_class</code> <code>str</code> <p>importance class (e.g., \"i\", \"ii\", \"iii\", \"iv\").</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>spectrum parameters for the specified code, seismic type, soil type, and importance class.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the code, seismic type, soil type, or importance class is invalid.</p> Source code in <code>eurocodepy/params.py</code> <pre><code>def seismic_get_params(code, seismic_type, soil_type, importance_class) -&gt; dict:\n    \"\"\"Get the seismic spectrum parameters.\n\n    This function retrieves the seismic spectrum parameters from the SeismicLoads\n    database based on the provided parameters. It returns a dictionary containing\n    the spectrum parameters, including the importance coefficient. The parameters\n    are case-insensitive for soil type and importance class, but the seismic type\n    should be provided in uppercase. The function is designed to work with different\n    localization codes, such as \"PT\" for Portugal or \"EU\" for standard CEN. The\n    seismic types can include \"PT1\", \"PT2\", \"PTA\" for Portugal, or \"CEN-1\", \"CEN-2\"\n    for CEN standards. This function is useful for engineers and designers who need\n    to apply seismic loads according to Eurocode standards.\n\n    Args:\n        code (str): Localization code (e.g., \"PT\" for Portugal, \"EU\" for standard\n            CEN).\n        seismic_type (str): type of seismic action (e.g., \"PT1\", \"PT2\", \"PTA\",\n            \"CEN-1\", \"CEN-2\").\n        soil_type (str): soil type (e.g., \"A\", \"B\", \"C\", \"D\", \"E\" for different\n            soil conditions).\n        importance_class (str): importance class (e.g., \"i\", \"ii\", \"iii\", \"iv\").\n\n    Returns:\n        dict: spectrum parameters for the specified code, seismic type, soil type,\n            and importance class.\n\n    Raises:\n        ValueError: If the code, seismic type, soil type, or importance class is\n            invalid.\n\n    \"\"\"\n    code = str.upper(code)\n    seismic_type = str.upper(seismic_type)\n    soil_type = str.upper(soil_type)\n    importance_class = str.lower(importance_class)\n    if code not in SeismicLoads[\"Locale\"]:\n        msg = f\"Invalid code: {code}. Available codes: {list(SeismicLoads['Locale'].keys())}\"\n        raise ValueError(msg)\n    if seismic_type not in SeismicLoads[\"Locale\"][code][\"Spectrum\"]:\n        msg = f\"Invalid seismic type: {seismic_type}. Available types: {list(SeismicLoads['Locale'][code]['Spectrum'].keys())}\"\n        raise ValueError(msg)\n    if soil_type not in SeismicLoads[\"Locale\"][code][\"Spectrum\"][seismic_type]:\n        msg = f\"Invalid soil type: {soil_type}. Available types: {list(SeismicLoads['Locale'][code]['Spectrum'][seismic_type].keys())}\"\n        raise ValueError(msg)\n    if importance_class not in SeismicLoads[\"Locale\"][code][\"ImportanceClass\"]:\n        msg = f\"Invalid importance class: {importance_class}. Available classes: {list(SeismicLoads['Locale'][code]['ImportanceCoef'].keys())}\"\n        raise ValueError(msg)\n\n    # Retrieve the spectrum parameters\n    spectrum = SeismicLoads[\"Locale\"][code][\"Spectrum\"][seismic_type][str.upper(soil_type)]\n    spectrum[\"ImportanceCoef\"] = SeismicLoads[\"Locale\"][code][\"ImportanceCoef\"][seismic_type][importance_class]\n    return spectrum\n</code></pre>"},{"location":"reference/eurocodepy/params/#eurocodepy.params.wind_get_params","title":"<code>wind_get_params(code='PT', zone='ZonaA', terrain='II')</code>","text":"<p>Get the wind load parameters for a given code, zone, and terrain.</p> <p>This function retrieves the wind load parameters from the WindLoads database based on the provided parameters. It returns a tuple containing the base velocity, minimum height, roughness length, and roughness length for terrain II. The parameters are case-insensitive for the zone and terrain, but the code should be provided in uppercase. The function is designed to work with different localization codes, such as \"PT\" for Portugal or \"EU\" for standard CEN. The zones can include \"ZonaA\", \"ZonaB\", etc., and the terrain types can include \"I\", \"II\", \"III\", etc. This function is useful for engineers and designers who need to apply wind loads according to Eurocode standards.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Localization code. Defaults to \"PT\".</p> <code>'PT'</code> <code>zone</code> <code>str</code> <p>Wind zone. Defaults to \"ZonaA\" for Portugal.</p> <code>'ZonaA'</code> <code>terrain</code> <code>str</code> <p>terrain type. Defaults to \"II\".</p> <code>'II'</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>wind load parameters for the specified code, zone, and terrain.</p> <code>tuple</code> <p>The tuple contains: - vb0 (float): base velocity for the specified zone. - zmin (float): minimum height for the specified terrain. - z0 (float): roughness length for the specified terrain. - z0II (float): roughness length for terrain II.</p> Source code in <code>eurocodepy/params.py</code> <pre><code>def wind_get_params(code: str = \"PT\", zone: str=\"ZonaA\", terrain: str = \"II\") -&gt; tuple:\n    \"\"\"Get the wind load parameters for a given code, zone, and terrain.\n\n    This function retrieves the wind load parameters from the WindLoads database based on the provided parameters.\n    It returns a tuple containing the base velocity, minimum height, roughness length, and roughness length for terrain II.\n    The parameters are case-insensitive for the zone and terrain, but the code should be provided in uppercase.\n    The function is designed to work with different localization codes, such as \"PT\" for Portugal or \"EU\" for standard CEN.\n    The zones can include \"ZonaA\", \"ZonaB\", etc., and the terrain types can include \"I\", \"II\", \"III\", etc.\n    This function is useful for engineers and designers who need to apply wind loads according to Eurocode standards.\n\n    Args:\n        code (str, optional): Localization code. Defaults to \"PT\".\n        zone (str, optional): Wind zone. Defaults to \"ZonaA\" for Portugal.\n        terrain (str, optional): terrain type. Defaults to \"II\".\n\n    Returns:\n        tuple: wind load parameters for the specified code, zone, and terrain.\n        The tuple contains:\n            - vb0 (float): base velocity for the specified zone.\n            - zmin (float): minimum height for the specified terrain.\n            - z0 (float): roughness length for the specified terrain.\n            - z0II (float): roughness length for terrain II.\n\n    \"\"\"\n    terrain = str.upper(terrain)\n    code = str.upper(code)\n\n    wind = WindLoads[\"locale\"][code]\n    vb0 = wind[\"base_velocity\"][zone][\"vb0\"]\n    z0 = wind[\"terrain\"][terrain][\"z0\"]\n    z0II = wind[\"terrain\"][\"II\"][\"z0\"]\n    zmin = wind[\"terrain\"][terrain][\"zmin\"]\n    return vb0, zmin, z0, z0II\n</code></pre>"},{"location":"reference/eurocodepy/ec1/","title":"ec1","text":""},{"location":"reference/eurocodepy/ec1/combos/","title":"combos","text":"<p>Module for Eurocode Load Combinations and Load Types.</p>"},{"location":"reference/eurocodepy/ec1/combos/#eurocodepy.ec1.combos.CombinationType","title":"<code>CombinationType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for different types of load combinations as per Eurocode standards.</p> Source code in <code>eurocodepy/ec1/combos.py</code> <pre><code>class CombinationType(Enum):\n    \"\"\"Enum for different types of load combinations as per Eurocode standards.\"\"\"\n\n    ULS = \"ULS\"  # Ultimate Limit State\n    SLS_K = \"SLS-K\"  # Serviceability Limit State\n    SLS_FR = \"SLS-FR\"  # Serviceability Limit State\n    SLS_QP = \"SLS-QP\"  # Serviceability Limit State\n    FLS = \"FLS\"  # Fatigue Limit State\n    ALS = \"ALS\"  # Accidental Limit State\n\n    def __str__(self) -&gt; str:  # noqa: D105\n        return self.value\n\n    @classmethod\n    def from_string(cls, value: str) -&gt; \"CombinationType\":\n        \"\"\"Convert a string to a CombinationType enum member.\n\n        Args:\n            value (str): The string representation of the combination type.\n\n        Returns:\n            CombinationType: The corresponding enum member.\n\n        Raises:\n            ValueError: If the string does not match any enum member.\n\n        \"\"\"\n        try:\n            return cls(value)\n        except ValueError:\n            msg = f\"Invalid combination type: {value}\"\n            raise ValueError(msg) from None\n</code></pre>"},{"location":"reference/eurocodepy/ec1/combos/#eurocodepy.ec1.combos.CombinationType.from_string","title":"<code>from_string(value)</code>  <code>classmethod</code>","text":"<p>Convert a string to a CombinationType enum member.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The string representation of the combination type.</p> required <p>Returns:</p> Name Type Description <code>CombinationType</code> <code>CombinationType</code> <p>The corresponding enum member.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string does not match any enum member.</p> Source code in <code>eurocodepy/ec1/combos.py</code> <pre><code>@classmethod\ndef from_string(cls, value: str) -&gt; \"CombinationType\":\n    \"\"\"Convert a string to a CombinationType enum member.\n\n    Args:\n        value (str): The string representation of the combination type.\n\n    Returns:\n        CombinationType: The corresponding enum member.\n\n    Raises:\n        ValueError: If the string does not match any enum member.\n\n    \"\"\"\n    try:\n        return cls(value)\n    except ValueError:\n        msg = f\"Invalid combination type: {value}\"\n        raise ValueError(msg) from None\n</code></pre>"},{"location":"reference/eurocodepy/ec1/combos/#eurocodepy.ec1.combos.Load","title":"<code>Load</code>  <code>dataclass</code>","text":"<p>Class representing a load with its properties.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the load.</p> <code>load_type</code> <code>LoadType</code> <p>Type of the load.</p> <code>gamma_fav</code> <code>float</code> <p>Favorable load factor.</p> <code>gamma_unf</code> <code>float</code> <p>Unfavorable load factor.</p> <code>psi0</code> <code>float</code> <p>Coefficient for quasi-permanent loads.</p> <code>psi1</code> <code>float</code> <p>Coefficient for frequent loads.</p> <code>psi2</code> <code>float</code> <p>Coefficient for characteristic loads.</p> <code>incombo</code> <code>bool</code> <p>Indicates if the load is included in combos (default is True).</p> Source code in <code>eurocodepy/ec1/combos.py</code> <pre><code>@dataclass\nclass Load:\n    \"\"\"Class representing a load with its properties.\n\n    Attributes:\n        name (str): Name of the load.\n        load_type (LoadType): Type of the load.\n        gamma_fav (float): Favorable load factor.\n        gamma_unf (float): Unfavorable load factor.\n        psi0 (float): Coefficient for quasi-permanent loads.\n        psi1 (float): Coefficient for frequent loads.\n        psi2 (float): Coefficient for characteristic loads.\n        incombo (bool): Indicates if the load is included in combos (default is True).\n\n    \"\"\"\n\n    name: str\n    load_type: LoadType\n    gamma_fav: float\n    gamma_unf: float\n    psi0: float\n    psi1: float\n    psi2: float\n    incombo: bool = True\n</code></pre>"},{"location":"reference/eurocodepy/ec1/combos/#eurocodepy.ec1.combos.LoadCollection","title":"<code>LoadCollection</code>","text":"<p>               Bases: <code>UserDict</code></p> <p>Collection of loads that can be added, removed, and queried.</p> <p>This class extends UserDict to manage a collection of Load objects. It allows adding, removing, and finding loads by type, as well as calculating load combinations for ULS and SLS. It also provides methods to get ULS and SLS load combinations based on the loads in the collection. It is initialized with an empty dictionary to store Load objects.</p> <p>Parameters:</p> Name Type Description Default <code>UserDict</code> <code>Load</code> <p>Load objects collection.</p> required Source code in <code>eurocodepy/ec1/combos.py</code> <pre><code>class LoadCollection(UserDict):\n    \"\"\"Collection of loads that can be added, removed, and queried.\n\n    This class extends UserDict to manage a collection of Load objects.\n    It allows adding, removing, and finding loads by type, as well as calculating\n    load combinations for ULS and SLS.\n    It also provides methods to get ULS and SLS load combinations based on the loads\n    in the collection.\n    It is initialized with an empty dictionary to store Load objects.\n\n    Args:\n        UserDict (Load): Load objects collection.\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:  # noqa: D107\n        super().__init__()\n        self.packs = []\n\n    def add(self, load: Load) -&gt; None:\n        \"\"\"Add a Load instance to the collection.\n\n        Args:\n            load (Load): The Load instance to add.\n\n        Raises:\n            TypeError: If the provided object is not a Load instance.\n            ValueError: If a load with the same name already exists.\n\n        \"\"\"\n        if not isinstance(load, Load):\n            msg = \"Only Load instances can be added.\"\n            raise TypeError(msg)\n        if load.name in self.data:\n            msg = f\"A load with name '{load.name}' already exists.\"\n            raise ValueError(msg)\n        self.data[load.name] = load\n\n    def remove(self, name: str) -&gt; None:\n        \"\"\"Remove a load from the collection by its name.\n\n        Args:\n            name (str): The name of the load to remove.\n\n        Raises:\n            ValueError: If no load is found with the given name.\n\n        \"\"\"\n        if name not in self.data:\n            msg = f\"No load found with name '_{name}'.\"\n            raise ValueError(msg)\n        del self.data[name]\n\n    def find_by_type(self, load_type: LoadType) -&gt; list[Load]:\n        \"\"\"Find all loads of a specific type.\n\n        Args:\n            load_type (LoadType): The type of load to find.\n\n        Returns:\n            list[Load]: List of load names that match the specified type.\n\n        \"\"\"\n        return [name for name, load in self.data.items() if load.load_type == load_type]\n\n    def __repr__(self) -&gt; str:  # noqa: D105\n        return f\"LoadCollection({self.data})\"\n\n    def get_ULS_combos(self) -&gt; dict:  # noqa: C901, N802, PLR0912\n        \"\"\"Calculate ULS load combinations based on the loads in the collection.\n\n        Returns:\n            list[LoadCombination]: List of ULS load combinations.\n\n        \"\"\"\n        perm_loads = self.find_by_type(LoadType.PERMANENT)\n        live_loads = self.find_by_type(LoadType.LIVE)\n        other_loads = self.find_by_type(LoadType.OTHER)\n        snow_loads = self.find_by_type(LoadType.SNOW)\n        earthquake_loads = self.find_by_type(LoadType.EARTHQUAKE)\n        wind_loads = self.find_by_type(LoadType.WIND)\n        temperature_loads = self.find_by_type(LoadType.TEMPERATURE)\n        wind_temp = list(product(wind_loads, temperature_loads))\n\n        combinations = {}\n\n        # Variable loads combinations\n        for item in wind_temp:\n            variable_loads = list(chain(live_loads, item, snow_loads, other_loads))\n\n            for j, name in enumerate(variable_loads):  # noqa: B007\n                combo = LoadCombination(\n                    name=\"ULS: \",\n                    combotype=CombinationType.ULS,\n                    factors={})\n\n                for _name in perm_loads:\n                    perm_load = self.data[_name]\n                    factor = round(perm_load.gamma_unf, 3)\n                    if abs(factor) &lt; COMBO_TOLERANCE:\n                        continue\n                    combo.name += f\"+{factor:.2f}_{_name}\"\n                    combo.factors[_name] = (perm_load, factor)\n\n                for i, _name in enumerate(variable_loads):\n                    load = self.data[_name]\n                    factor = load.gamma_unf if i == j else load.gamma_unf * load.psi0\n                    if abs(factor) &lt; COMBO_TOLERANCE:\n                        continue\n                    combo.name += f\"+{factor:.2f}_{_name}\"\n                    combo.factors[load.name] = (load, round(factor, 3))\n\n                if combo.name not in combinations:\n                    combinations[combo.name] = combo\n\n        # Seismic loads combinations\n        for item in wind_temp:\n            variable_loads = list(chain(live_loads, item, snow_loads, other_loads))\n\n            for loadname in earthquake_loads:\n                combo = LoadCombination(\n                    name=\"ULS-E: \",\n                    combotype=CombinationType.ULS,\n                    factors={})\n\n                for name in perm_loads:\n                    perm_load = self.data[name]\n                    factor = 1.0\n                    combo.name += f\"+{factor:.2f}_{name}\"\n                    combo.factors[name] = (perm_load, factor)\n\n                for name in variable_loads:\n                    load = self.data[name]\n                    factor = load.psi2\n                    if abs(factor) &lt; COMBO_TOLERANCE:\n                        continue\n                    combo.name += f\"+{factor:.2f}_{name}\"\n                    combo.factors[load.name] = (load, round(factor, 3))\n\n                load = self.data[loadname]\n                combo.name += f\"+{load.gamma_unf:.2f}_{loadname}\"\n                combo.factors[loadname] = (load, load.gamma_unf)\n\n                if combo.name not in combinations:\n                    combinations[combo.name] = combo\n\n        return combinations\n\n    def get_SLS_combos(self) -&gt; dict:  # noqa: C901, N802, PLR0912, PLR0915\n        \"\"\"Calculate ULS load combinations based on the loads in the collection.\n\n        Returns:\n            list[LoadCombination]: List of ULS load combinations.\n\n        \"\"\"\n        perm_loads = self.find_by_type(LoadType.PERMANENT)\n        live_loads = self.find_by_type(LoadType.LIVE)\n        other_loads = self.find_by_type(LoadType.OTHER)\n        snow_loads = self.find_by_type(LoadType.SNOW)\n        wind_loads = self.find_by_type(LoadType.WIND)\n        temperature_loads = self.find_by_type(LoadType.TEMPERATURE)\n        wind_temp = list(product(wind_loads, temperature_loads))\n\n        combinations = {}\n\n        # Characteristic loads combinations\n        for item in wind_temp:\n            variable_loads = list(chain(live_loads, item, snow_loads, other_loads))\n\n            for j in range(len(variable_loads)):\n                combo = LoadCombination(\n                    name=\"SLS-K: \",\n                    combotype=CombinationType.SLS_K,\n                    factors={})\n\n                for _name in perm_loads:\n                    perm_load = self.data[_name]\n                    factor = 1.0\n                    if abs(factor) &lt; COMBO_TOLERANCE:\n                        continue\n                    combo.name += f\"+{factor:.2f}_{_name}\"\n                    combo.factors[_name] = (perm_load, factor)\n\n                for i, _name in enumerate(variable_loads):\n                    load = self.data[_name]\n                    factor = 1.0 if i == j else load.psi0\n                    if abs(factor) &lt; COMBO_TOLERANCE:\n                        continue\n                    combo.name += f\"+{factor:.2f}_{_name}\"\n                    combo.factors[load.name] = (load, round(factor, 3))\n\n            if combo.name not in combinations:\n                combinations[combo.name] = combo\n\n        # Frequent loads combinations\n        for item in wind_temp:\n            variable_loads = list(chain(live_loads, item, snow_loads, other_loads))\n\n            for j, __name in enumerate(variable_loads):\n                combo = LoadCombination(\n                    name=\"SLS-FR: \",\n                    combotype=CombinationType.SLS_FR,\n                    factors={})\n\n                for _name in perm_loads:\n                    perm_load = self.data[_name]\n                    factor = 1.0\n                    if abs(factor) &lt; COMBO_TOLERANCE:\n                        continue\n                    combo.name += f\"+{factor:.2f}_{_name}\"\n                    combo.factors[_name] = (perm_load, factor)\n\n                for i, _name in enumerate(variable_loads):\n                    load = self.data[_name]\n                    factor = load.psi1 if i == j else load.psi2\n                    if abs(factor) &lt; COMBO_TOLERANCE:\n                        continue\n                    combo.name += f\"+{factor:.2f}_{_name}\"\n                    combo.factors[load.name] = (load, round(factor, 3))\n\n            if combo.name not in combinations:\n                combinations[combo.name] = combo\n\n        # Quasi-permanent loads combinations\n        for item in wind_temp:\n            variable_loads = list(chain(live_loads, item, snow_loads, other_loads))\n\n            for __name in variable_loads:\n                combo = LoadCombination(\n                    name=\"SLS-QP: \",\n                    combotype=CombinationType.SLS_QP,\n                    factors={})\n\n                for _name in perm_loads:\n                    perm_load = self.data[_name]\n                    factor = 1.0\n                    if abs(factor) &lt; COMBO_TOLERANCE:\n                        continue\n                    combo.name += f\"+{factor:.2f}_{_name}\"\n                    combo.factors[_name] = (perm_load, factor)\n\n                for _name in variable_loads:\n                    load = self.data[_name]\n                    factor = load.psi2\n                    if abs(factor) &lt; COMBO_TOLERANCE:\n                        continue\n                    combo.name += f\"+{factor:.2f}_{_name}\"\n                    combo.factors[load.name] = (load, round(factor, 3))\n\n            if combo.name not in combinations:\n                combinations[combo.name] = combo\n\n        return combinations\n</code></pre>"},{"location":"reference/eurocodepy/ec1/combos/#eurocodepy.ec1.combos.LoadCollection.add","title":"<code>add(load)</code>","text":"<p>Add a Load instance to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>load</code> <code>Load</code> <p>The Load instance to add.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the provided object is not a Load instance.</p> <code>ValueError</code> <p>If a load with the same name already exists.</p> Source code in <code>eurocodepy/ec1/combos.py</code> <pre><code>def add(self, load: Load) -&gt; None:\n    \"\"\"Add a Load instance to the collection.\n\n    Args:\n        load (Load): The Load instance to add.\n\n    Raises:\n        TypeError: If the provided object is not a Load instance.\n        ValueError: If a load with the same name already exists.\n\n    \"\"\"\n    if not isinstance(load, Load):\n        msg = \"Only Load instances can be added.\"\n        raise TypeError(msg)\n    if load.name in self.data:\n        msg = f\"A load with name '{load.name}' already exists.\"\n        raise ValueError(msg)\n    self.data[load.name] = load\n</code></pre>"},{"location":"reference/eurocodepy/ec1/combos/#eurocodepy.ec1.combos.LoadCollection.find_by_type","title":"<code>find_by_type(load_type)</code>","text":"<p>Find all loads of a specific type.</p> <p>Parameters:</p> Name Type Description Default <code>load_type</code> <code>LoadType</code> <p>The type of load to find.</p> required <p>Returns:</p> Type Description <code>list[Load]</code> <p>list[Load]: List of load names that match the specified type.</p> Source code in <code>eurocodepy/ec1/combos.py</code> <pre><code>def find_by_type(self, load_type: LoadType) -&gt; list[Load]:\n    \"\"\"Find all loads of a specific type.\n\n    Args:\n        load_type (LoadType): The type of load to find.\n\n    Returns:\n        list[Load]: List of load names that match the specified type.\n\n    \"\"\"\n    return [name for name, load in self.data.items() if load.load_type == load_type]\n</code></pre>"},{"location":"reference/eurocodepy/ec1/combos/#eurocodepy.ec1.combos.LoadCollection.get_SLS_combos","title":"<code>get_SLS_combos()</code>","text":"<p>Calculate ULS load combinations based on the loads in the collection.</p> <p>Returns:</p> Type Description <code>dict</code> <p>list[LoadCombination]: List of ULS load combinations.</p> Source code in <code>eurocodepy/ec1/combos.py</code> <pre><code>def get_SLS_combos(self) -&gt; dict:  # noqa: C901, N802, PLR0912, PLR0915\n    \"\"\"Calculate ULS load combinations based on the loads in the collection.\n\n    Returns:\n        list[LoadCombination]: List of ULS load combinations.\n\n    \"\"\"\n    perm_loads = self.find_by_type(LoadType.PERMANENT)\n    live_loads = self.find_by_type(LoadType.LIVE)\n    other_loads = self.find_by_type(LoadType.OTHER)\n    snow_loads = self.find_by_type(LoadType.SNOW)\n    wind_loads = self.find_by_type(LoadType.WIND)\n    temperature_loads = self.find_by_type(LoadType.TEMPERATURE)\n    wind_temp = list(product(wind_loads, temperature_loads))\n\n    combinations = {}\n\n    # Characteristic loads combinations\n    for item in wind_temp:\n        variable_loads = list(chain(live_loads, item, snow_loads, other_loads))\n\n        for j in range(len(variable_loads)):\n            combo = LoadCombination(\n                name=\"SLS-K: \",\n                combotype=CombinationType.SLS_K,\n                factors={})\n\n            for _name in perm_loads:\n                perm_load = self.data[_name]\n                factor = 1.0\n                if abs(factor) &lt; COMBO_TOLERANCE:\n                    continue\n                combo.name += f\"+{factor:.2f}_{_name}\"\n                combo.factors[_name] = (perm_load, factor)\n\n            for i, _name in enumerate(variable_loads):\n                load = self.data[_name]\n                factor = 1.0 if i == j else load.psi0\n                if abs(factor) &lt; COMBO_TOLERANCE:\n                    continue\n                combo.name += f\"+{factor:.2f}_{_name}\"\n                combo.factors[load.name] = (load, round(factor, 3))\n\n        if combo.name not in combinations:\n            combinations[combo.name] = combo\n\n    # Frequent loads combinations\n    for item in wind_temp:\n        variable_loads = list(chain(live_loads, item, snow_loads, other_loads))\n\n        for j, __name in enumerate(variable_loads):\n            combo = LoadCombination(\n                name=\"SLS-FR: \",\n                combotype=CombinationType.SLS_FR,\n                factors={})\n\n            for _name in perm_loads:\n                perm_load = self.data[_name]\n                factor = 1.0\n                if abs(factor) &lt; COMBO_TOLERANCE:\n                    continue\n                combo.name += f\"+{factor:.2f}_{_name}\"\n                combo.factors[_name] = (perm_load, factor)\n\n            for i, _name in enumerate(variable_loads):\n                load = self.data[_name]\n                factor = load.psi1 if i == j else load.psi2\n                if abs(factor) &lt; COMBO_TOLERANCE:\n                    continue\n                combo.name += f\"+{factor:.2f}_{_name}\"\n                combo.factors[load.name] = (load, round(factor, 3))\n\n        if combo.name not in combinations:\n            combinations[combo.name] = combo\n\n    # Quasi-permanent loads combinations\n    for item in wind_temp:\n        variable_loads = list(chain(live_loads, item, snow_loads, other_loads))\n\n        for __name in variable_loads:\n            combo = LoadCombination(\n                name=\"SLS-QP: \",\n                combotype=CombinationType.SLS_QP,\n                factors={})\n\n            for _name in perm_loads:\n                perm_load = self.data[_name]\n                factor = 1.0\n                if abs(factor) &lt; COMBO_TOLERANCE:\n                    continue\n                combo.name += f\"+{factor:.2f}_{_name}\"\n                combo.factors[_name] = (perm_load, factor)\n\n            for _name in variable_loads:\n                load = self.data[_name]\n                factor = load.psi2\n                if abs(factor) &lt; COMBO_TOLERANCE:\n                    continue\n                combo.name += f\"+{factor:.2f}_{_name}\"\n                combo.factors[load.name] = (load, round(factor, 3))\n\n        if combo.name not in combinations:\n            combinations[combo.name] = combo\n\n    return combinations\n</code></pre>"},{"location":"reference/eurocodepy/ec1/combos/#eurocodepy.ec1.combos.LoadCollection.get_ULS_combos","title":"<code>get_ULS_combos()</code>","text":"<p>Calculate ULS load combinations based on the loads in the collection.</p> <p>Returns:</p> Type Description <code>dict</code> <p>list[LoadCombination]: List of ULS load combinations.</p> Source code in <code>eurocodepy/ec1/combos.py</code> <pre><code>def get_ULS_combos(self) -&gt; dict:  # noqa: C901, N802, PLR0912\n    \"\"\"Calculate ULS load combinations based on the loads in the collection.\n\n    Returns:\n        list[LoadCombination]: List of ULS load combinations.\n\n    \"\"\"\n    perm_loads = self.find_by_type(LoadType.PERMANENT)\n    live_loads = self.find_by_type(LoadType.LIVE)\n    other_loads = self.find_by_type(LoadType.OTHER)\n    snow_loads = self.find_by_type(LoadType.SNOW)\n    earthquake_loads = self.find_by_type(LoadType.EARTHQUAKE)\n    wind_loads = self.find_by_type(LoadType.WIND)\n    temperature_loads = self.find_by_type(LoadType.TEMPERATURE)\n    wind_temp = list(product(wind_loads, temperature_loads))\n\n    combinations = {}\n\n    # Variable loads combinations\n    for item in wind_temp:\n        variable_loads = list(chain(live_loads, item, snow_loads, other_loads))\n\n        for j, name in enumerate(variable_loads):  # noqa: B007\n            combo = LoadCombination(\n                name=\"ULS: \",\n                combotype=CombinationType.ULS,\n                factors={})\n\n            for _name in perm_loads:\n                perm_load = self.data[_name]\n                factor = round(perm_load.gamma_unf, 3)\n                if abs(factor) &lt; COMBO_TOLERANCE:\n                    continue\n                combo.name += f\"+{factor:.2f}_{_name}\"\n                combo.factors[_name] = (perm_load, factor)\n\n            for i, _name in enumerate(variable_loads):\n                load = self.data[_name]\n                factor = load.gamma_unf if i == j else load.gamma_unf * load.psi0\n                if abs(factor) &lt; COMBO_TOLERANCE:\n                    continue\n                combo.name += f\"+{factor:.2f}_{_name}\"\n                combo.factors[load.name] = (load, round(factor, 3))\n\n            if combo.name not in combinations:\n                combinations[combo.name] = combo\n\n    # Seismic loads combinations\n    for item in wind_temp:\n        variable_loads = list(chain(live_loads, item, snow_loads, other_loads))\n\n        for loadname in earthquake_loads:\n            combo = LoadCombination(\n                name=\"ULS-E: \",\n                combotype=CombinationType.ULS,\n                factors={})\n\n            for name in perm_loads:\n                perm_load = self.data[name]\n                factor = 1.0\n                combo.name += f\"+{factor:.2f}_{name}\"\n                combo.factors[name] = (perm_load, factor)\n\n            for name in variable_loads:\n                load = self.data[name]\n                factor = load.psi2\n                if abs(factor) &lt; COMBO_TOLERANCE:\n                    continue\n                combo.name += f\"+{factor:.2f}_{name}\"\n                combo.factors[load.name] = (load, round(factor, 3))\n\n            load = self.data[loadname]\n            combo.name += f\"+{load.gamma_unf:.2f}_{loadname}\"\n            combo.factors[loadname] = (load, load.gamma_unf)\n\n            if combo.name not in combinations:\n                combinations[combo.name] = combo\n\n    return combinations\n</code></pre>"},{"location":"reference/eurocodepy/ec1/combos/#eurocodepy.ec1.combos.LoadCollection.remove","title":"<code>remove(name)</code>","text":"<p>Remove a load from the collection by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the load to remove.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If no load is found with the given name.</p> Source code in <code>eurocodepy/ec1/combos.py</code> <pre><code>def remove(self, name: str) -&gt; None:\n    \"\"\"Remove a load from the collection by its name.\n\n    Args:\n        name (str): The name of the load to remove.\n\n    Raises:\n        ValueError: If no load is found with the given name.\n\n    \"\"\"\n    if name not in self.data:\n        msg = f\"No load found with name '_{name}'.\"\n        raise ValueError(msg)\n    del self.data[name]\n</code></pre>"},{"location":"reference/eurocodepy/ec1/combos/#eurocodepy.ec1.combos.LoadCombination","title":"<code>LoadCombination</code>","text":"<p>Class representing a load combination for Eurocode standards.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the load combination.</p> <code>combotype</code> <code>CombinationType</code> <p>Type of the load combination.</p> <code>factors</code> <code>dict</code> <p>Load factors for different loads.</p> Source code in <code>eurocodepy/ec1/combos.py</code> <pre><code>class LoadCombination:\n    \"\"\"Class representing a load combination for Eurocode standards.\n\n    Attributes:\n        name (str): Name of the load combination.\n        combotype (CombinationType): Type of the load combination.\n        factors (dict): Load factors for different loads.\n\n    \"\"\"\n\n    def __init__(self, name: str, combotype: CombinationType, factors: dict) -&gt; None:  # noqa: D107\n        self.name = name\n        self.type = combotype\n        self.factors = factors\n\n    def __repr__(self) -&gt; str:  # noqa: D105\n        return f\"LoadCombination(name={self.name}, type={self.type}, factors={self.factors})\"\n\n    def __str__(self) -&gt; str:  # noqa: D105\n        return f\"{self.name} ({self.type}): {self.factors}\"\n</code></pre>"},{"location":"reference/eurocodepy/ec1/combos/#eurocodepy.ec1.combos.LoadType","title":"<code>LoadType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for different types of loads as per Eurocode standards.</p> Source code in <code>eurocodepy/ec1/combos.py</code> <pre><code>class LoadType(Enum):\n    \"\"\"Enum for different types of loads as per Eurocode standards.\"\"\"\n\n    PERMANENT = 0\n    LIVE = 1\n    WIND = 2\n    SNOW = 3\n    EARTHQUAKE = 4\n    TEMPERATURE = 5\n    FIRE = 6\n    ACCIDENTAL = 7\n    OTHER = 8\n\n    def __str__(self) -&gt; str:  # noqa: D105\n        return self.value\n\n    @classmethod\n    def from_string(cls, value: str) -&gt; \"LoadType\":\n        \"\"\"Convert a string to a LoadType enum member.\n\n        Args:\n            value (str): The string representation of the load type.\n\n        Returns:\n            LoadType: The corresponding enum member.\n\n        Raises:\n            ValueError: If the string does not match any enum member.\n\n        \"\"\"\n        try:\n            return cls(value)\n        except ValueError:\n            msg = f\"Invalid load type: {value}\"\n            raise ValueError(msg) from None\n</code></pre>"},{"location":"reference/eurocodepy/ec1/combos/#eurocodepy.ec1.combos.LoadType.from_string","title":"<code>from_string(value)</code>  <code>classmethod</code>","text":"<p>Convert a string to a LoadType enum member.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The string representation of the load type.</p> required <p>Returns:</p> Name Type Description <code>LoadType</code> <code>LoadType</code> <p>The corresponding enum member.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string does not match any enum member.</p> Source code in <code>eurocodepy/ec1/combos.py</code> <pre><code>@classmethod\ndef from_string(cls, value: str) -&gt; \"LoadType\":\n    \"\"\"Convert a string to a LoadType enum member.\n\n    Args:\n        value (str): The string representation of the load type.\n\n    Returns:\n        LoadType: The corresponding enum member.\n\n    Raises:\n        ValueError: If the string does not match any enum member.\n\n    \"\"\"\n    try:\n        return cls(value)\n    except ValueError:\n        msg = f\"Invalid load type: {value}\"\n        raise ValueError(msg) from None\n</code></pre>"},{"location":"reference/eurocodepy/ec1/snow/","title":"snow","text":""},{"location":"reference/eurocodepy/ec1/wind/","title":"wind","text":""},{"location":"reference/eurocodepy/ec1/wind/#eurocodepy.ec1.wind.I_v","title":"<code>I_v(z, z_min, z_0, co, k_I=1)</code>","text":"<p>Calculate the turbulence intensity, Iv(z), at height z.</p> <p>It is defined as the standard deviation of the turbulence divided by the mean wind velocity.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance</p> required <code>z_min</code> <code>float</code> <p>minimum height.</p> required <code>z_0</code> <code>float</code> <p>roughness length.</p> required <code>co</code> <code>float</code> <p>orography factor.</p> required <code>k_I</code> <code>float</code> <p>turbulence intensity factor. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>turbulence intensity</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def I_v(z: float, z_min: float, z_0: float, co: float, k_I: float = 1) -&gt; float:\n    \"\"\"Calculate the turbulence intensity, Iv(z), at height z.\n\n    It is defined as the standard deviation of the turbulence divided by the mean wind velocity.\n\n    Args:\n        z (float): vertical distance\n        z_min (float, optional): minimum height.\n        z_0 (float, optional): roughness length.\n        co (float): orography factor.\n        k_I (float, optional): turbulence intensity factor. Defaults to 1.\n\n    Returns:\n        float: turbulence intensity\n\n    \"\"\"\n    zeff = max(z, z_min)\n    Iv = k_I / co / log(zeff/z_0)\n    return Iv\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/#eurocodepy.ec1.wind.c_o","title":"<code>c_o(z, x=0, H=0, Lu=10, Ld=1000)</code>","text":"<p>Calculate the orography factor.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance</p> required <code>x</code> <code>float</code> <p>horizontal distance. Defaults to 0.</p> <code>0</code> <code>H</code> <code>float</code> <p>height of the hill/cliff. Defaults to 0.</p> <code>0</code> <code>Lu</code> <code>float</code> <p>length of the hill/cliff. Defaults to 10.</p> <code>10</code> <code>Ld</code> <code>float</code> <p>length of the cliff. Defaults to 1000, meaning it's a cliff.</p> <code>1000</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>orography factor</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def c_o(z: float, x: float=0, H: float = 0, Lu: float = 10, Ld: float = 1000) -&gt; float:\n    \"\"\"Calculate the orography factor.\n\n    Args:\n        z (float): vertical distance\n        x (float, optional): horizontal distance. Defaults to 0.\n        H (float, optional): height of the hill/cliff. Defaults to 0.\n        Lu (float, optional): length of the hill/cliff. Defaults to 10.\n        Ld (float, optional): length of the cliff. Defaults to 1000, meaning it's a cliff.\n\n    Returns:\n        float: orography factor\n\n    \"\"\"\n    phi = H/Lu\n    if phi &lt; 0.05: return 1.0\n    s = s_coef(x, z, H, Lu, Ld)\n    return 1.0 + 2.0 * s * phi if phi &lt; 0.3 else 1.0 + 0.6 * s\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/#eurocodepy.ec1.wind.c_r","title":"<code>c_r(z, z_min, z_0, z_0II)</code>","text":"<p>Calculate the roughness factor.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance.</p> required <code>z_min</code> <code>float</code> <p>minimum height.</p> required <code>z_0</code> <code>float</code> <p>roughness length.</p> required <code>z_OII</code> <code>float</code> <p>roughness length for terrain II.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the roughness factor</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def c_r(z: float, z_min: float, z_0: float, z_0II: float) -&gt; float:\n    \"\"\"Calculate the roughness factor.\n\n    Args:\n        z (float): vertical distance.\n        z_min (float, optional): minimum height.\n        z_0 (float, optional): roughness length.\n        z_OII (float, optional): roughness length for terrain II.\n\n    Returns:\n        float: the roughness factor\n\n    \"\"\"\n    k_r = 0.19*((z_0/z_0II)**0.07)\n    zeff = z if z &gt;= z_min else z_min\n    return k_r * log(zeff/z_0)\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/#eurocodepy.ec1.wind.q_p","title":"<code>q_p(z, vb, z_min, z_0, cr, co, rho=1.25, k_I=1)</code>","text":"<p>Calculate the peak velocity pressure, qp(z), at height z.</p> <p>Peak velocity includes mean and short-term velocity fluctuations.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance.</p> required <code>vb</code> <code>float</code> <p>fundamental value of the basic wind velocity.</p> required <code>z_min</code> <code>float</code> <p>minimum height.</p> required <code>z_0</code> <code>float</code> <p>roughness length.</p> required <code>cr</code> <code>float</code> <p>terrain roughness factor.</p> required <code>co</code> <code>float</code> <p>orography factor.</p> required <code>rho</code> <code>float</code> <p>air density. Defaults to 1.25 kg/m3.</p> <code>1.25</code> <code>k_I</code> <code>float</code> <p>turbulence intensity factor. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>peak velocity pressure</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def q_p(z: float, vb: float, z_min: float, z_0: float, cr: float, co: float,\n        rho: float=1.25, k_I: float = 1) -&gt; float:\n    \"\"\"Calculate the peak velocity pressure, qp(z), at height z.\n\n    Peak velocity includes mean and short-term velocity fluctuations.\n\n    Args:\n        z (float): vertical distance.\n        vb (float): fundamental value of the basic wind velocity.\n        z_min (float, optional): minimum height.\n        z_0 (float, optional): roughness length.\n        cr (float): terrain roughness factor.\n        co (float): orography factor.\n        rho (float, optional): air density. Defaults to 1.25 kg/m3.\n        k_I (float, optional): turbulence intensity factor. Defaults to 1.\n\n    Returns:\n        float: peak velocity pressure\n\n    \"\"\"\n    v = cr * co * vb\n    zeff = max(z, z_min)\n    Iv = k_I / co / log(zeff/z_0)\n    qp = 0.5 * (1.0 + 7*Iv) * v**2 * rho\n    return qp\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/#eurocodepy.ec1.wind.s_coef","title":"<code>s_coef(x, z, H, Lu, Ld=1000)</code>","text":"<p>Calculate coefficient s.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>horizontal distance</p> required <code>z</code> <code>float</code> <p>vertical distance</p> required <code>H</code> <code>float</code> <p>height of the hill/cliff</p> required <code>Lu</code> <code>float</code> <p>length of the hill/cliff</p> required <code>Ld</code> <code>float</code> <p>length of the cliff. Defaults to 1000, meaning is a cliff.</p> <code>1000</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>description</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def s_coef(x: float, z: float, H: float, Lu: float, Ld: float = 1000) -&gt; float:\n    \"\"\"Calculate coefficient s.\n\n    Args:\n        x (float): horizontal distance\n        z (float): vertical distance\n        H (float): height of the hill/cliff\n        Lu (float): length of the hill/cliff\n        Ld (float, optional): length of the cliff. Defaults to 1000, meaning is a cliff.\n\n    Returns:\n        float: _description_\n\n    \"\"\"\n    phi0 = H / Ld\n    phi = H / Lu\n\n    if phi &lt; 0.05: return 0.0\n    orography_type = \"hill\" if phi0 &gt; 0.05 else \"cliff\"\n\n    Le = H/0.3 if phi &gt;= 0.3 else Lu\n    x_Lu = x/Lu\n    z_Le = z/Le\n\n    s = 0.0\n    if x_Lu &lt;= 0:\n        if -1.5 &lt; x_Lu and z_Le &lt; 2:\n            A = (\n                0.1552 * z_Le**4 - 0.8575 * z_Le**3 +\n                1.8133 * z_Le**2 - 1.9115 * z_Le + 1.0124\n                )\n            B = 0.3542 * z_Le**2 - 1.0577 * z_Le + 2.6456\n            s = A * exp(B * x_Lu)\n        elif x_Lu &lt; -1.5 or z_Le &gt;= 2:\n            s = 0.0\n    elif orography_type == \"hill\":\n        x_Ld = x/Ld\n        if x_Ld &lt; 2 and z_Le &lt; 2:\n            A = (\n                0.1552 * z_Le**4 - 0.8575 * z_Le**3 +\n                1.8133 * z_Le**2 - 1.9115 * z_Le + 1.0124\n            )\n            B = -0.3056 * z_Le**2 + 1.0212 * z_Le - 1.7637\n            s = A * exp(B * x_Lu)\n        elif x_Ld &gt;= 2 or z_Le &gt;= 2:\n            s = 0.0\n    else:  # orography_type == 'cliff'\n        x_Le = x/Le\n        z_Le = max(z_Le, 0.1)\n        if (0.1 &lt; x_Le &lt; 3.5) and (z_Le &lt; 2):\n            logzle = log10(z_Le)\n            A = -1.3420*logzle**3 -0.8222 * logzle**2 + 0.4609 * logzle - 0.0791\n            B = -1.0196*logzle**3 -0.8910 * logzle**2 + 0.5343 * logzle - 0.1156\n            C = 0.8030*logzle**3 + 0.4236 * logzle**2 - 0.5738 * logzle + 0.1606\n            logxle = log10(x/Le)\n            s = A*logxle**2 + B*logxle + C\n        elif (0.1 &gt;= x_Le) and (z_Le &lt; 2):\n            s1 = (\n                0.1552 * z_Le**4\n                - 0.8575 * z_Le**3\n                + 1.8133 * z_Le**2\n                - 1.9115 * z_Le\n                + 1.0124\n            )\n            logzle = log10(z_Le)\n            A = -1.3420 * logzle**3 - 0.8222 * logzle**2 + 0.4609 * logzle - 0.0791\n            B = -1.0196 * logzle**3 - 0.8910 * logzle**2 + 0.5343 * logzle - 0.1156\n            C =  0.8030 * logzle**3 + 0.4236 * logzle**2 - 0.5738 * logzle + 0.1606\n            logxle = log10(0.1 / Le)\n            s2 = A * logxle**2 + B * logxle + C\n            s = s1 + x_Le*(s2 - s1) / 0.1\n        elif x_Le &gt;= 3.5 or z_Le &gt;= 2:\n            s = 0.0\n\n    return s\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/#eurocodepy.ec1.wind.v_b","title":"<code>v_b(vb_0, c_season=1.0, c_dir=1.0)</code>","text":"<p>Calculate the basic wind velocity.</p> <p>Parameters:</p> Name Type Description Default <code>vb_0</code> <code>float</code> <p>fundamental value of the basic wind velocity</p> required <code>c_season</code> <code>float</code> <p>seasonal factor. Defaults to 1.0.</p> <code>1.0</code> <code>c_dir</code> <code>float</code> <p>directional factor. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>basic wind velocity</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def v_b(vb_0: float, c_season: float=1.0, c_dir: float=1.0) -&gt; float:\n    \"\"\"Calculate the basic wind velocity.\n\n    Args:\n        vb_0 (float): fundamental value of the basic wind velocity\n        c_season (float, optional): seasonal factor. Defaults to 1.0.\n        c_dir (float, optional): directional factor. Defaults to 1.0.\n\n    Returns:\n        float: basic wind velocity\n\n    \"\"\"\n    return c_season * c_dir * vb_0\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/#eurocodepy.ec1.wind.v_m","title":"<code>v_m(z, vb, cr, co)</code>","text":"<p>Calculate the mean wind velocity, vm(z), at a height z above the terrain.</p> <p>Depends on the terrain roughness and orography and on the basic wind velocity.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance</p> required <code>vb</code> <code>float</code> <p>basic wind velocity</p> required <code>cr</code> <code>float</code> <p>terrain roughness factor.</p> required <code>co</code> <code>float</code> <p>orography factor.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>mean wind velocity, vm(z)</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def v_m(z: float, vb: float, cr: float, co: float) -&gt; float:\n    \"\"\"Calculate the mean wind velocity, vm(z), at a height z above the terrain.\n\n    Depends on the terrain roughness and orography and on the basic wind velocity.\n\n    Args:\n        z (float): vertical distance\n        vb (float): basic wind velocity\n        cr (float): terrain roughness factor.\n        co (float): orography factor.\n\n    Returns:\n        float: mean wind velocity, vm(z)\n\n    \"\"\"\n    return cr * co * vb\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/#eurocodepy.ec1.wind.v_p","title":"<code>v_p(z, vb, z_min, z_0, cr, co, k_I=1)</code>","text":"<p>Calculate the peak velocity, vp(z), at height z.</p> <p>which includes mean and short-term velocity fluctuations.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance</p> required <code>vb</code> <code>float</code> <p>fundamental value of the basic wind velocity</p> required <code>z_min</code> <code>float</code> <p>minimum height.</p> required <code>z_0</code> <code>float</code> <p>roughness length.</p> required <code>cr</code> <code>float</code> <p>terrain roughness factor.</p> required <code>co</code> <code>float</code> <p>orography factor.</p> required <code>k_I</code> <code>float</code> <p>turbulence intensity factor. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>peak velocity pressure</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def v_p(z: float, vb: float, z_min: float, z_0: float, cr: float, co: float, k_I:float=1) -&gt; float:\n    \"\"\"Calculate the peak velocity, vp(z), at height z.\n\n    which includes mean and short-term velocity fluctuations.\n\n    Args:\n        z (float): vertical distance\n        vb (float): fundamental value of the basic wind velocity\n        z_min (float, optional): minimum height.\n        z_0 (float, optional): roughness length.\n        cr (float): terrain roughness factor.\n        co (float): orography factor.\n        k_I (float, optional): turbulence intensity factor. Defaults to 1.\n\n    Returns:\n        float: peak velocity pressure\n\n    \"\"\"\n    v = cr * co * vb\n    zeff = max(z, z_min)\n    Iv = k_I / co / log(zeff / z_0)\n    vp = (1.0 + 7 * Iv) * v\n    return vp\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/pressure/","title":"pressure","text":""},{"location":"reference/eurocodepy/ec1/wind/pressure/#eurocodepy.ec1.wind.pressure.I_v","title":"<code>I_v(z, z_min, z_0, co, k_I=1)</code>","text":"<p>Calculate the turbulence intensity, Iv(z), at height z.</p> <p>It is defined as the standard deviation of the turbulence divided by the mean wind velocity.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance</p> required <code>z_min</code> <code>float</code> <p>minimum height.</p> required <code>z_0</code> <code>float</code> <p>roughness length.</p> required <code>co</code> <code>float</code> <p>orography factor.</p> required <code>k_I</code> <code>float</code> <p>turbulence intensity factor. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>turbulence intensity</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def I_v(z: float, z_min: float, z_0: float, co: float, k_I: float = 1) -&gt; float:\n    \"\"\"Calculate the turbulence intensity, Iv(z), at height z.\n\n    It is defined as the standard deviation of the turbulence divided by the mean wind velocity.\n\n    Args:\n        z (float): vertical distance\n        z_min (float, optional): minimum height.\n        z_0 (float, optional): roughness length.\n        co (float): orography factor.\n        k_I (float, optional): turbulence intensity factor. Defaults to 1.\n\n    Returns:\n        float: turbulence intensity\n\n    \"\"\"\n    zeff = max(z, z_min)\n    Iv = k_I / co / log(zeff/z_0)\n    return Iv\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/pressure/#eurocodepy.ec1.wind.pressure.c_o","title":"<code>c_o(z, x=0, H=0, Lu=10, Ld=1000)</code>","text":"<p>Calculate the orography factor.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance</p> required <code>x</code> <code>float</code> <p>horizontal distance. Defaults to 0.</p> <code>0</code> <code>H</code> <code>float</code> <p>height of the hill/cliff. Defaults to 0.</p> <code>0</code> <code>Lu</code> <code>float</code> <p>length of the hill/cliff. Defaults to 10.</p> <code>10</code> <code>Ld</code> <code>float</code> <p>length of the cliff. Defaults to 1000, meaning it's a cliff.</p> <code>1000</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>orography factor</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def c_o(z: float, x: float=0, H: float = 0, Lu: float = 10, Ld: float = 1000) -&gt; float:\n    \"\"\"Calculate the orography factor.\n\n    Args:\n        z (float): vertical distance\n        x (float, optional): horizontal distance. Defaults to 0.\n        H (float, optional): height of the hill/cliff. Defaults to 0.\n        Lu (float, optional): length of the hill/cliff. Defaults to 10.\n        Ld (float, optional): length of the cliff. Defaults to 1000, meaning it's a cliff.\n\n    Returns:\n        float: orography factor\n\n    \"\"\"\n    phi = H/Lu\n    if phi &lt; 0.05: return 1.0\n    s = s_coef(x, z, H, Lu, Ld)\n    return 1.0 + 2.0 * s * phi if phi &lt; 0.3 else 1.0 + 0.6 * s\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/pressure/#eurocodepy.ec1.wind.pressure.c_r","title":"<code>c_r(z, z_min, z_0, z_0II)</code>","text":"<p>Calculate the roughness factor.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance.</p> required <code>z_min</code> <code>float</code> <p>minimum height.</p> required <code>z_0</code> <code>float</code> <p>roughness length.</p> required <code>z_OII</code> <code>float</code> <p>roughness length for terrain II.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the roughness factor</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def c_r(z: float, z_min: float, z_0: float, z_0II: float) -&gt; float:\n    \"\"\"Calculate the roughness factor.\n\n    Args:\n        z (float): vertical distance.\n        z_min (float, optional): minimum height.\n        z_0 (float, optional): roughness length.\n        z_OII (float, optional): roughness length for terrain II.\n\n    Returns:\n        float: the roughness factor\n\n    \"\"\"\n    k_r = 0.19*((z_0/z_0II)**0.07)\n    zeff = z if z &gt;= z_min else z_min\n    return k_r * log(zeff/z_0)\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/pressure/#eurocodepy.ec1.wind.pressure.q_p","title":"<code>q_p(z, vb, z_min, z_0, cr, co, rho=1.25, k_I=1)</code>","text":"<p>Calculate the peak velocity pressure, qp(z), at height z.</p> <p>Peak velocity includes mean and short-term velocity fluctuations.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance.</p> required <code>vb</code> <code>float</code> <p>fundamental value of the basic wind velocity.</p> required <code>z_min</code> <code>float</code> <p>minimum height.</p> required <code>z_0</code> <code>float</code> <p>roughness length.</p> required <code>cr</code> <code>float</code> <p>terrain roughness factor.</p> required <code>co</code> <code>float</code> <p>orography factor.</p> required <code>rho</code> <code>float</code> <p>air density. Defaults to 1.25 kg/m3.</p> <code>1.25</code> <code>k_I</code> <code>float</code> <p>turbulence intensity factor. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>peak velocity pressure</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def q_p(z: float, vb: float, z_min: float, z_0: float, cr: float, co: float,\n        rho: float=1.25, k_I: float = 1) -&gt; float:\n    \"\"\"Calculate the peak velocity pressure, qp(z), at height z.\n\n    Peak velocity includes mean and short-term velocity fluctuations.\n\n    Args:\n        z (float): vertical distance.\n        vb (float): fundamental value of the basic wind velocity.\n        z_min (float, optional): minimum height.\n        z_0 (float, optional): roughness length.\n        cr (float): terrain roughness factor.\n        co (float): orography factor.\n        rho (float, optional): air density. Defaults to 1.25 kg/m3.\n        k_I (float, optional): turbulence intensity factor. Defaults to 1.\n\n    Returns:\n        float: peak velocity pressure\n\n    \"\"\"\n    v = cr * co * vb\n    zeff = max(z, z_min)\n    Iv = k_I / co / log(zeff/z_0)\n    qp = 0.5 * (1.0 + 7*Iv) * v**2 * rho\n    return qp\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/pressure/#eurocodepy.ec1.wind.pressure.s_coef","title":"<code>s_coef(x, z, H, Lu, Ld=1000)</code>","text":"<p>Calculate coefficient s.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>horizontal distance</p> required <code>z</code> <code>float</code> <p>vertical distance</p> required <code>H</code> <code>float</code> <p>height of the hill/cliff</p> required <code>Lu</code> <code>float</code> <p>length of the hill/cliff</p> required <code>Ld</code> <code>float</code> <p>length of the cliff. Defaults to 1000, meaning is a cliff.</p> <code>1000</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>description</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def s_coef(x: float, z: float, H: float, Lu: float, Ld: float = 1000) -&gt; float:\n    \"\"\"Calculate coefficient s.\n\n    Args:\n        x (float): horizontal distance\n        z (float): vertical distance\n        H (float): height of the hill/cliff\n        Lu (float): length of the hill/cliff\n        Ld (float, optional): length of the cliff. Defaults to 1000, meaning is a cliff.\n\n    Returns:\n        float: _description_\n\n    \"\"\"\n    phi0 = H / Ld\n    phi = H / Lu\n\n    if phi &lt; 0.05: return 0.0\n    orography_type = \"hill\" if phi0 &gt; 0.05 else \"cliff\"\n\n    Le = H/0.3 if phi &gt;= 0.3 else Lu\n    x_Lu = x/Lu\n    z_Le = z/Le\n\n    s = 0.0\n    if x_Lu &lt;= 0:\n        if -1.5 &lt; x_Lu and z_Le &lt; 2:\n            A = (\n                0.1552 * z_Le**4 - 0.8575 * z_Le**3 +\n                1.8133 * z_Le**2 - 1.9115 * z_Le + 1.0124\n                )\n            B = 0.3542 * z_Le**2 - 1.0577 * z_Le + 2.6456\n            s = A * exp(B * x_Lu)\n        elif x_Lu &lt; -1.5 or z_Le &gt;= 2:\n            s = 0.0\n    elif orography_type == \"hill\":\n        x_Ld = x/Ld\n        if x_Ld &lt; 2 and z_Le &lt; 2:\n            A = (\n                0.1552 * z_Le**4 - 0.8575 * z_Le**3 +\n                1.8133 * z_Le**2 - 1.9115 * z_Le + 1.0124\n            )\n            B = -0.3056 * z_Le**2 + 1.0212 * z_Le - 1.7637\n            s = A * exp(B * x_Lu)\n        elif x_Ld &gt;= 2 or z_Le &gt;= 2:\n            s = 0.0\n    else:  # orography_type == 'cliff'\n        x_Le = x/Le\n        z_Le = max(z_Le, 0.1)\n        if (0.1 &lt; x_Le &lt; 3.5) and (z_Le &lt; 2):\n            logzle = log10(z_Le)\n            A = -1.3420*logzle**3 -0.8222 * logzle**2 + 0.4609 * logzle - 0.0791\n            B = -1.0196*logzle**3 -0.8910 * logzle**2 + 0.5343 * logzle - 0.1156\n            C = 0.8030*logzle**3 + 0.4236 * logzle**2 - 0.5738 * logzle + 0.1606\n            logxle = log10(x/Le)\n            s = A*logxle**2 + B*logxle + C\n        elif (0.1 &gt;= x_Le) and (z_Le &lt; 2):\n            s1 = (\n                0.1552 * z_Le**4\n                - 0.8575 * z_Le**3\n                + 1.8133 * z_Le**2\n                - 1.9115 * z_Le\n                + 1.0124\n            )\n            logzle = log10(z_Le)\n            A = -1.3420 * logzle**3 - 0.8222 * logzle**2 + 0.4609 * logzle - 0.0791\n            B = -1.0196 * logzle**3 - 0.8910 * logzle**2 + 0.5343 * logzle - 0.1156\n            C =  0.8030 * logzle**3 + 0.4236 * logzle**2 - 0.5738 * logzle + 0.1606\n            logxle = log10(0.1 / Le)\n            s2 = A * logxle**2 + B * logxle + C\n            s = s1 + x_Le*(s2 - s1) / 0.1\n        elif x_Le &gt;= 3.5 or z_Le &gt;= 2:\n            s = 0.0\n\n    return s\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/pressure/#eurocodepy.ec1.wind.pressure.v_b","title":"<code>v_b(vb_0, c_season=1.0, c_dir=1.0)</code>","text":"<p>Calculate the basic wind velocity.</p> <p>Parameters:</p> Name Type Description Default <code>vb_0</code> <code>float</code> <p>fundamental value of the basic wind velocity</p> required <code>c_season</code> <code>float</code> <p>seasonal factor. Defaults to 1.0.</p> <code>1.0</code> <code>c_dir</code> <code>float</code> <p>directional factor. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>basic wind velocity</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def v_b(vb_0: float, c_season: float=1.0, c_dir: float=1.0) -&gt; float:\n    \"\"\"Calculate the basic wind velocity.\n\n    Args:\n        vb_0 (float): fundamental value of the basic wind velocity\n        c_season (float, optional): seasonal factor. Defaults to 1.0.\n        c_dir (float, optional): directional factor. Defaults to 1.0.\n\n    Returns:\n        float: basic wind velocity\n\n    \"\"\"\n    return c_season * c_dir * vb_0\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/pressure/#eurocodepy.ec1.wind.pressure.v_m","title":"<code>v_m(z, vb, cr, co)</code>","text":"<p>Calculate the mean wind velocity, vm(z), at a height z above the terrain.</p> <p>Depends on the terrain roughness and orography and on the basic wind velocity.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance</p> required <code>vb</code> <code>float</code> <p>basic wind velocity</p> required <code>cr</code> <code>float</code> <p>terrain roughness factor.</p> required <code>co</code> <code>float</code> <p>orography factor.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>mean wind velocity, vm(z)</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def v_m(z: float, vb: float, cr: float, co: float) -&gt; float:\n    \"\"\"Calculate the mean wind velocity, vm(z), at a height z above the terrain.\n\n    Depends on the terrain roughness and orography and on the basic wind velocity.\n\n    Args:\n        z (float): vertical distance\n        vb (float): basic wind velocity\n        cr (float): terrain roughness factor.\n        co (float): orography factor.\n\n    Returns:\n        float: mean wind velocity, vm(z)\n\n    \"\"\"\n    return cr * co * vb\n</code></pre>"},{"location":"reference/eurocodepy/ec1/wind/pressure/#eurocodepy.ec1.wind.pressure.v_p","title":"<code>v_p(z, vb, z_min, z_0, cr, co, k_I=1)</code>","text":"<p>Calculate the peak velocity, vp(z), at height z.</p> <p>which includes mean and short-term velocity fluctuations.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>float</code> <p>vertical distance</p> required <code>vb</code> <code>float</code> <p>fundamental value of the basic wind velocity</p> required <code>z_min</code> <code>float</code> <p>minimum height.</p> required <code>z_0</code> <code>float</code> <p>roughness length.</p> required <code>cr</code> <code>float</code> <p>terrain roughness factor.</p> required <code>co</code> <code>float</code> <p>orography factor.</p> required <code>k_I</code> <code>float</code> <p>turbulence intensity factor. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>peak velocity pressure</p> Source code in <code>eurocodepy/ec1/wind/pressure.py</code> <pre><code>def v_p(z: float, vb: float, z_min: float, z_0: float, cr: float, co: float, k_I:float=1) -&gt; float:\n    \"\"\"Calculate the peak velocity, vp(z), at height z.\n\n    which includes mean and short-term velocity fluctuations.\n\n    Args:\n        z (float): vertical distance\n        vb (float): fundamental value of the basic wind velocity\n        z_min (float, optional): minimum height.\n        z_0 (float, optional): roughness length.\n        cr (float): terrain roughness factor.\n        co (float): orography factor.\n        k_I (float, optional): turbulence intensity factor. Defaults to 1.\n\n    Returns:\n        float: peak velocity pressure\n\n    \"\"\"\n    v = cr * co * vb\n    zeff = max(z, z_min)\n    Iv = k_I / co / log(zeff / z_0)\n    vp = (1.0 + 7 * Iv) * v\n    return vp\n</code></pre>"},{"location":"reference/eurocodepy/ec2/","title":"ec2","text":"<p>Eurocode 2: Design of concrete structures.</p> <p>This module provides classes and functions for Eurocode 2 concrete design. It includes properties for different concrete grades and types, as well as calculations for serviceability and ultimate limit states.</p>"},{"location":"reference/eurocodepy/ec2/materials/","title":"materials","text":""},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Bar","title":"<code>Bar</code>","text":"<p>Represents a reinforcement bar with a given diameter and number of bars.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Bar--attributes","title":"Attributes","text":"<p>diameter : float     Diameter of the bar. area : float     Area of the bar cross-section. number : int     Number of bars in the bundle.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Bar--methods","title":"Methods","text":"<p>total_area     Returns the total area of all bars.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>class Bar:\n    \"\"\"Represents a reinforcement bar with a given diameter and number of bars.\n\n    Attributes\n    ----------\n    diameter : float\n        Diameter of the bar.\n    area : float\n        Area of the bar cross-section.\n    number : int\n        Number of bars in the bundle.\n\n    Methods\n    -------\n    total_area\n        Returns the total area of all bars.\n\n    \"\"\"\n\n    def __init__(self, diameter: float | str, n: int = 1) -&gt; None:\n        if isinstance(diameter, str):\n            self.bar = dbase.ReinforcementBars[diameter]\n            self.diameter = self.bar[\"d\"]\n            self.area = self.bar[\"A\"]\n        else:\n            self.diameter = diameter\n            self.area = round(np.pi * diameter**2 / 400.0, 2)\n\n        self.number = n\n\n    def total_area(self) -&gt; float:\n        \"\"\"Return the total area of all bars in the bundle.\n\n        Returns\n        -------\n        float\n            The total area of all bars in the bundle.\n\n        \"\"\"\n        return self.number * self.area\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Compara barras com base no di\u00e2metro e \u00e1rea.\n\n        Returns\n        -------\n        bool\n            True se as barras t\u00eam o mesmo di\u00e2metro, False caso contr\u00e1rio.\n\n        \"\"\"\n        return (\n            isinstance(other, Bar) and\n            self.diameter == other.diameter\n        )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Make Bar hashable based on diameter.\n\n        Returns\n        -------\n        int\n            Hash value based on the bar's diameter.\n\n        \"\"\"\n        return hash(self.diameter)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the Bar object.\n\n        Returns\n        -------\n        str\n            String representation of the Bar object.\n\n        \"\"\"\n        return f\"Bar(diameter={self.diameter}, area={self.area})\"\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Bar.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compara barras com base no di\u00e2metro e \u00e1rea.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Bar.__eq__--returns","title":"Returns","text":"<p>bool     True se as barras t\u00eam o mesmo di\u00e2metro, False caso contr\u00e1rio.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Compara barras com base no di\u00e2metro e \u00e1rea.\n\n    Returns\n    -------\n    bool\n        True se as barras t\u00eam o mesmo di\u00e2metro, False caso contr\u00e1rio.\n\n    \"\"\"\n    return (\n        isinstance(other, Bar) and\n        self.diameter == other.diameter\n    )\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Bar.__hash__","title":"<code>__hash__()</code>","text":"<p>Make Bar hashable based on diameter.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Bar.__hash__--returns","title":"Returns","text":"<p>int     Hash value based on the bar's diameter.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Make Bar hashable based on diameter.\n\n    Returns\n    -------\n    int\n        Hash value based on the bar's diameter.\n\n    \"\"\"\n    return hash(self.diameter)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Bar.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the Bar object.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Bar.__repr__--returns","title":"Returns","text":"<p>str     String representation of the Bar object.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the Bar object.\n\n    Returns\n    -------\n    str\n        String representation of the Bar object.\n\n    \"\"\"\n    return f\"Bar(diameter={self.diameter}, area={self.area})\"\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Bar.total_area","title":"<code>total_area()</code>","text":"<p>Return the total area of all bars in the bundle.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Bar.total_area--returns","title":"Returns","text":"<p>float     The total area of all bars in the bundle.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>def total_area(self) -&gt; float:\n    \"\"\"Return the total area of all bars in the bundle.\n\n    Returns\n    -------\n    float\n        The total area of all bars in the bundle.\n\n    \"\"\"\n    return self.number * self.area\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.BarLayout","title":"<code>BarLayout</code>","text":"<p>Manages a layout of reinforcement bars or bundles for concrete design.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.BarLayout--attributes","title":"Attributes","text":"<p>bars : list[Bar]     List of Bar objects representing the reinforcement layout.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.BarLayout--methods","title":"Methods","text":"<p>add_bar(item: Union[Bar, Bundle], n: int = 1)     Adds a bar or bundle of bars to the layout. total_area     Returns the total area of all bars in the layout. diameter     Returns the diameter (to be implemented).</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>class BarLayout:\n    \"\"\"Manages a layout of reinforcement bars or bundles for concrete design.\n\n    Attributes\n    ----------\n    bars : list[Bar]\n        List of Bar objects representing the reinforcement layout.\n\n    Methods\n    -------\n    add_bar(item: Union[Bar, Bundle], n: int = 1)\n        Adds a bar or bundle of bars to the layout.\n    total_area\n        Returns the total area of all bars in the layout.\n    diameter\n        Returns the diameter (to be implemented).\n\n    \"\"\"\n\n    def __init__(self, bars: list[Bar]) -&gt; None:\n        \"\"\"Initialize a BarLayout with a list of Bar objects.\n\n        Args:\n            bars (list[Bar]): List of Bar objects representing the reinforcement layout.\n\n        \"\"\"\n        self.bars = bars if bars is not None else []\n\n    def add_bar(self, item: Bar | Bundle, n: int = 1) -&gt; None:\n        \"\"\"Adiciona uma barra ou um bundle de barras ao layout.\n\n        Args:\n            item (Bar or Bundle): objeto Bar individual ou Bundle de barras.\n            n (int): n\u00famero de vezes que o item ser\u00e1 adicionado\n                (aplicado ao n\u00famero de barras).\n\n        Raises:\n            TypeError: Se o item n\u00e3o for do tipo Bar ou Bundle.\n\n        \"\"\"\n        if isinstance(item, Bar):\n            self._add_or_merge_bar(item, n)\n        elif isinstance(item, Bundle):\n            for bar in item.bars:\n                self._add_or_merge_bar(bar, n)\n        else:\n            msg = \"Item deve ser do tipo Bar ou Bundle\"\n            raise TypeError(msg)\n\n    def _add_or_merge_bar(self, bar: Bar, n: int) -&gt; None:\n        for existing_bar in self.bars:\n            if existing_bar == bar:\n                existing_bar.number += bar.number * n\n                return\n        # N\u00e3o encontrou igual, adiciona nova entrada\n        self.bars.append(Bar(bar.diameter, bar.number * n))\n\n    @property\n    def total_area(self) -&gt; float:\n        \"\"\"Retorna a \u00e1rea total considerando todas as barras.\"\"\"\n        return sum(bar.area * bar.number for bar in self.bars)\n\n    @property\n    def diameter(self) -&gt; float:\n        \"\"\"Returns the diameter (to be implemented).\"\"\"\n        return self.diameter\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.BarLayout.diameter","title":"<code>diameter</code>  <code>property</code>","text":"<p>Returns the diameter (to be implemented).</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.BarLayout.total_area","title":"<code>total_area</code>  <code>property</code>","text":"<p>Retorna a \u00e1rea total considerando todas as barras.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.BarLayout.__init__","title":"<code>__init__(bars)</code>","text":"<p>Initialize a BarLayout with a list of Bar objects.</p> <p>Parameters:</p> Name Type Description Default <code>bars</code> <code>list[Bar]</code> <p>List of Bar objects representing the reinforcement layout.</p> required Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>def __init__(self, bars: list[Bar]) -&gt; None:\n    \"\"\"Initialize a BarLayout with a list of Bar objects.\n\n    Args:\n        bars (list[Bar]): List of Bar objects representing the reinforcement layout.\n\n    \"\"\"\n    self.bars = bars if bars is not None else []\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.BarLayout.add_bar","title":"<code>add_bar(item, n=1)</code>","text":"<p>Adiciona uma barra ou um bundle de barras ao layout.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Bar or Bundle</code> <p>objeto Bar individual ou Bundle de barras.</p> required <code>n</code> <code>int</code> <p>n\u00famero de vezes que o item ser\u00e1 adicionado (aplicado ao n\u00famero de barras).</p> <code>1</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>Se o item n\u00e3o for do tipo Bar ou Bundle.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>def add_bar(self, item: Bar | Bundle, n: int = 1) -&gt; None:\n    \"\"\"Adiciona uma barra ou um bundle de barras ao layout.\n\n    Args:\n        item (Bar or Bundle): objeto Bar individual ou Bundle de barras.\n        n (int): n\u00famero de vezes que o item ser\u00e1 adicionado\n            (aplicado ao n\u00famero de barras).\n\n    Raises:\n        TypeError: Se o item n\u00e3o for do tipo Bar ou Bundle.\n\n    \"\"\"\n    if isinstance(item, Bar):\n        self._add_or_merge_bar(item, n)\n    elif isinstance(item, Bundle):\n        for bar in item.bars:\n            self._add_or_merge_bar(bar, n)\n    else:\n        msg = \"Item deve ser do tipo Bar ou Bundle\"\n        raise TypeError(msg)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Bundle","title":"<code>Bundle</code>","text":"<p>Represents a bundle of reinforcement bars for concrete design.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Bundle--attributes","title":"Attributes","text":"<p>bars : list[Bar]     List of Bar objects included in the bundle. diameter : float     Equivalent diameter of the bundle. area : float     Total area of all bars in the bundle. number : int     Number of bundles.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Bundle--methods","title":"Methods","text":"<p>total_area     Returns the total area of all bars in the bundle. equiv_diameter     Calculates and returns the equivalent diameter of the bundle.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>class Bundle:\n    \"\"\"Represents a bundle of reinforcement bars for concrete design.\n\n    Attributes\n    ----------\n    bars : list[Bar]\n        List of Bar objects included in the bundle.\n    diameter : float\n        Equivalent diameter of the bundle.\n    area : float\n        Total area of all bars in the bundle.\n    number : int\n        Number of bundles.\n\n    Methods\n    -------\n    total_area\n        Returns the total area of all bars in the bundle.\n    equiv_diameter\n        Calculates and returns the equivalent diameter of the bundle.\n\n    \"\"\"\n\n    def __init__(self, bars: list[Bar]) -&gt; None:\n        \"\"\"Initialize a Bundle with a list of Bar objects.\n\n        Args:\n            bars (list[Bar]): List of Bar objects to be included in the bundle.\n\n        Raises:\n            ValueError: If the number of bars in the bundle is less than 2 or\n                greater than 4.\n\n        \"\"\"\n        if len(bars) &gt; MAX_BUNDLE_BARS:\n            msg = \"Number of bars in a bundle must be less or equal 4\"\n            raise ValueError(msg)\n        if len(bars) &lt; MIN_BUNDLE_BARS:\n            msg = \"Number of bars in a bundle must be more than 1\"\n            raise ValueError(msg)\n        self.bars = bars\n        self.diameter = np.sqrt(sum(x.diameter**2 for x in bars))\n        self.area = sum(bar.area for bar in self.bars)\n        self.number = 1\n\n    @property\n    def total_area(self) -&gt; float:\n        \"\"\"Return the total area of all bars in the bundle.\"\"\"\n        return self.number * self.area\n\n    @property\n    def equiv_diameter(self) -&gt; float:\n        \"\"\"Calculate and return the equivalent diameter of the bundle of bars.\n\n        Returns\n        -------\n        float\n            The equivalent diameter calculated as the sum of squared\n            diameters divided by the sum of diameters.\n\n        \"\"\"\n        num = sum(bar.diameter**2 for bar in self.bars)\n        den = sum(bar.diameter for bar in self.bars)\n        return num / den\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Bundle.equiv_diameter","title":"<code>equiv_diameter</code>  <code>property</code>","text":"<p>Calculate and return the equivalent diameter of the bundle of bars.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Bundle.equiv_diameter--returns","title":"Returns","text":"<p>float     The equivalent diameter calculated as the sum of squared     diameters divided by the sum of diameters.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Bundle.total_area","title":"<code>total_area</code>  <code>property</code>","text":"<p>Return the total area of all bars in the bundle.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Bundle.__init__","title":"<code>__init__(bars)</code>","text":"<p>Initialize a Bundle with a list of Bar objects.</p> <p>Parameters:</p> Name Type Description Default <code>bars</code> <code>list[Bar]</code> <p>List of Bar objects to be included in the bundle.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the number of bars in the bundle is less than 2 or greater than 4.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>def __init__(self, bars: list[Bar]) -&gt; None:\n    \"\"\"Initialize a Bundle with a list of Bar objects.\n\n    Args:\n        bars (list[Bar]): List of Bar objects to be included in the bundle.\n\n    Raises:\n        ValueError: If the number of bars in the bundle is less than 2 or\n            greater than 4.\n\n    \"\"\"\n    if len(bars) &gt; MAX_BUNDLE_BARS:\n        msg = \"Number of bars in a bundle must be less or equal 4\"\n        raise ValueError(msg)\n    if len(bars) &lt; MIN_BUNDLE_BARS:\n        msg = \"Number of bars in a bundle must be more than 1\"\n        raise ValueError(msg)\n    self.bars = bars\n    self.diameter = np.sqrt(sum(x.diameter**2 for x in bars))\n    self.area = sum(bar.area for bar in self.bars)\n    self.number = 1\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Concrete","title":"<code>Concrete</code>","text":"<p>Represents EC2 concrete properties and provides access to parameters.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Concrete--attributes","title":"Attributes","text":"<p>grade : str     The concrete grade (e.g., 'C30/37'). name : str     The normalized name of the concrete grade. fck : float     Characteristic compressive strength (MPa). fcm : float     Mean compressive strength (MPa). fctm : float     Mean tensile strength (MPa). fctk_05 : float     5% fractile tensile strength (MPa). fctk_95 : float     95% fractile tensile strength (MPa). Ecm : float     Modulus of elasticity (MPa). eps_c2 : float     Strain at peak stress. eps_cu2 : float     Ultimate compressive strain. n : float     Parameter n for stress-strain curve. gamma_c : float     Partial safety factor for concrete. fcd : float     Design compressive strength (MPa). fctd : float     Design tensile strength (MPa).</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Concrete--methods","title":"Methods","text":"<p>repr()     Returns a string representation of the Concrete object. str()     Returns a user-friendly string representation of the Concrete object. from_fck(f_ck: int, name: object = None)     Class method to create a Concrete instance from characteristic     compressive strength.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>class Concrete:\n    \"\"\"Represents EC2 concrete properties and provides access to parameters.\n\n    Attributes\n    ----------\n    grade : str\n        The concrete grade (e.g., 'C30/37').\n    name : str\n        The normalized name of the concrete grade.\n    fck : float\n        Characteristic compressive strength (MPa).\n    fcm : float\n        Mean compressive strength (MPa).\n    fctm : float\n        Mean tensile strength (MPa).\n    fctk_05 : float\n        5% fractile tensile strength (MPa).\n    fctk_95 : float\n        95% fractile tensile strength (MPa).\n    Ecm : float\n        Modulus of elasticity (MPa).\n    eps_c2 : float\n        Strain at peak stress.\n    eps_cu2 : float\n        Ultimate compressive strain.\n    n : float\n        Parameter n for stress-strain curve.\n    gamma_c : float\n        Partial safety factor for concrete.\n    fcd : float\n        Design compressive strength (MPa).\n    fctd : float\n        Design tensile strength (MPa).\n\n    Methods\n    -------\n    __repr__()\n        Returns a string representation of the Concrete object.\n    __str__()\n        Returns a user-friendly string representation of the Concrete object.\n    from_fck(f_ck: int, name: object = None)\n        Class method to create a Concrete instance from characteristic\n        compressive strength.\n\n    \"\"\"\n\n    def __init__(self, class_name: str = \"C30/37\") -&gt; None:\n        self.grade = class_name\n\n        class_name = class_name.replace(\"/\", \"_\").upper()\n        if class_name not in dbase.ConcreteGrades:\n            grades_list = [item.replace(\"_\", \"/\") for item in dbase.ConcreteGrades]\n            msg = (\n                f\"Concrete class '{class_name}' not found in database. \"\n                f\"Concrete type must be one of {grades_list}\"\n            )\n            raise ValueError(msg)\n\n        conc = dbase.ConcreteGrades[class_name]\n        self.name = class_name\n        self.fck = conc[\"fck\"]  # MPa\n        self.fcm = conc[\"fcm\"]  # Mean compressive strength (MPa)\n        self.fctm = conc[\"fctm\"]  # Mean tensile strength (MPa)\n        self.fctk_05 = conc[\"fctk05\"] * self.fctm  # 5% fractile (MPa)\n        self.fctk_95 = round(1.3 * self.fctm, 1)  # 95% fractile (MPa)\n        self.Ecm = conc[\"Ecm\"]  # Modulus of elasticity (MPa)\n        self.eps_c2 = conc[\"epsc2\"]  # Strain at peak stress\n        self.eps_cu2 = conc[\"epscu2\"]  # Ultimate compressive strain\n        self.n = conc[\"n\"]  # Ultimate compressive strain\n\n        self.gamma_c = GammaC\n        self.fcd = round(self.fck / GammaC, 1)  # Design yield strength (MPa)\n        self.fctd = round(self.fctk_05 / GammaCT, 1)  # Design yield strength (MPa)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the Concrete object.\n\n        Returns\n        -------\n        str\n            String representation of the Concrete object.\n\n        \"\"\"\n        return (\n            f\"Concrete(grade='{self.grade}', fck={self.fck}, fcm={self.fcm}, \"\n            f\"fctm={self.fctm}, fctk_05={self.fctk_05}, fctk_95={self.fctk_95}, \"\n            f\"Ecm={self.Ecm}, eps_c2={self.eps_c2}, eps_cu2={self.eps_cu2}, \"\n            f\"n={self.n}, fcd={self.fcd}, fctd={self.fctd})\"\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the Concrete object.\n\n        Returns\n        -------\n        str\n            String representation of the Concrete object.\n\n        \"\"\"\n        return (\n            f\"Concrete {self.grade} (\"\n            f\"fck={self.fck} MPa, \"\n            f\"fcm={self.fcm} MPa, \"\n            f\"fctm={self.fctm} MPa, \"\n            f\"fctk_05={self.fctk_05} MPa, \"\n            f\"fctk_95={self.fctk_95} MPa, \"\n            f\"Ecm={self.Ecm} MPa, \"\n            f\"eps_c2={self.eps_c2}, \"\n            f\"eps_cu2={self.eps_cu2}, \"\n            f\"n={self.n}, \"\n            f\"fcd={self.fcd} MPa, \"\n            f\"fctd={self.fctd} MPa)\"\n        )\n\n    @classmethod\n    def from_fck(cls, f_ck: int, name: object = None) -&gt; \"Concrete\":\n        \"\"\"Create a Concrete instance from characteristic compressive strength.\n\n        Args:\n            f_ck (int): Characteristic compressive strength of concrete (MPa)\n            name (str, optional): Name for the concrete grade.\n\n        Returns:\n            Concrete: Concrete instance.\n\n        \"\"\"\n        fck = float(f_ck)\n        cls.fck = round(fck, 1)  # MPa\n        cls.fcm = round(fck + 8, 1)  # Mean compressive strength (MPa)\n        cls.fctm = round(0.30 * fck**(2 / 3), 1)  # Mean tensile strength (MPa)\n        cls.fctk_005 = round(0.7 * cls.fctm, 1)  # 5% fractile\n        cls.fctk_095 = round(1.3 * cls.fctm, 1)  # 95% fractile\n        cls.Ecm = round(22000 * (cls.fcm / 10)**0.3, 1)  # Modulus of elasticity (MPa)\n        cls.eps_c2 = 2.0 if fck &lt;= REF_FCK else 2.0 + 0.085 * (fck - 50) ** 0.53\n        # Strain at peak stress\n        cls.eps_cu2 = (\n            3.5 if fck &lt;= REF_FCK\n            else round(2.6 + 35 * ((90.0 - fck) / 100.0) ** 4, 1)\n        )\n        cls.n = (\n            2.0\n            if fck &lt;= REF_FCK\n            else round(1.4 + 23.4 * ((90.0 - fck) / 100.0) ** 4, 1)\n        )\n        if name is not None:\n            cls.name = name\n            cls.grade = name\n        else:\n            cls.name = f\"C{f_ck}\"\n            cls.grade = f\"C{f_ck}\"\n\n        cls.gamma_c = GammaC\n        cls.fcd = round(cls.fck / GammaC, 1)  # Design yield strength (MPa)\n        cls.fctd = round(cls.fctk_05 / GammaCT, 1)  # Design yield strength (MPa)\n\n        return cls\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Concrete.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the Concrete object.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Concrete.__repr__--returns","title":"Returns","text":"<p>str     String representation of the Concrete object.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the Concrete object.\n\n    Returns\n    -------\n    str\n        String representation of the Concrete object.\n\n    \"\"\"\n    return (\n        f\"Concrete(grade='{self.grade}', fck={self.fck}, fcm={self.fcm}, \"\n        f\"fctm={self.fctm}, fctk_05={self.fctk_05}, fctk_95={self.fctk_95}, \"\n        f\"Ecm={self.Ecm}, eps_c2={self.eps_c2}, eps_cu2={self.eps_cu2}, \"\n        f\"n={self.n}, fcd={self.fcd}, fctd={self.fctd})\"\n    )\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Concrete.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the Concrete object.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Concrete.__str__--returns","title":"Returns","text":"<p>str     String representation of the Concrete object.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the Concrete object.\n\n    Returns\n    -------\n    str\n        String representation of the Concrete object.\n\n    \"\"\"\n    return (\n        f\"Concrete {self.grade} (\"\n        f\"fck={self.fck} MPa, \"\n        f\"fcm={self.fcm} MPa, \"\n        f\"fctm={self.fctm} MPa, \"\n        f\"fctk_05={self.fctk_05} MPa, \"\n        f\"fctk_95={self.fctk_95} MPa, \"\n        f\"Ecm={self.Ecm} MPa, \"\n        f\"eps_c2={self.eps_c2}, \"\n        f\"eps_cu2={self.eps_cu2}, \"\n        f\"n={self.n}, \"\n        f\"fcd={self.fcd} MPa, \"\n        f\"fctd={self.fctd} MPa)\"\n    )\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Concrete.from_fck","title":"<code>from_fck(f_ck, name=None)</code>  <code>classmethod</code>","text":"<p>Create a Concrete instance from characteristic compressive strength.</p> <p>Parameters:</p> Name Type Description Default <code>f_ck</code> <code>int</code> <p>Characteristic compressive strength of concrete (MPa)</p> required <code>name</code> <code>str</code> <p>Name for the concrete grade.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Concrete</code> <code>Concrete</code> <p>Concrete instance.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>@classmethod\ndef from_fck(cls, f_ck: int, name: object = None) -&gt; \"Concrete\":\n    \"\"\"Create a Concrete instance from characteristic compressive strength.\n\n    Args:\n        f_ck (int): Characteristic compressive strength of concrete (MPa)\n        name (str, optional): Name for the concrete grade.\n\n    Returns:\n        Concrete: Concrete instance.\n\n    \"\"\"\n    fck = float(f_ck)\n    cls.fck = round(fck, 1)  # MPa\n    cls.fcm = round(fck + 8, 1)  # Mean compressive strength (MPa)\n    cls.fctm = round(0.30 * fck**(2 / 3), 1)  # Mean tensile strength (MPa)\n    cls.fctk_005 = round(0.7 * cls.fctm, 1)  # 5% fractile\n    cls.fctk_095 = round(1.3 * cls.fctm, 1)  # 95% fractile\n    cls.Ecm = round(22000 * (cls.fcm / 10)**0.3, 1)  # Modulus of elasticity (MPa)\n    cls.eps_c2 = 2.0 if fck &lt;= REF_FCK else 2.0 + 0.085 * (fck - 50) ** 0.53\n    # Strain at peak stress\n    cls.eps_cu2 = (\n        3.5 if fck &lt;= REF_FCK\n        else round(2.6 + 35 * ((90.0 - fck) / 100.0) ** 4, 1)\n    )\n    cls.n = (\n        2.0\n        if fck &lt;= REF_FCK\n        else round(1.4 + 23.4 * ((90.0 - fck) / 100.0) ** 4, 1)\n    )\n    if name is not None:\n        cls.name = name\n        cls.grade = name\n    else:\n        cls.name = f\"C{f_ck}\"\n        cls.grade = f\"C{f_ck}\"\n\n    cls.gamma_c = GammaC\n    cls.fcd = round(cls.fck / GammaC, 1)  # Design yield strength (MPa)\n    cls.fctd = round(cls.fctk_05 / GammaCT, 1)  # Design yield strength (MPa)\n\n    return cls\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.ConcreteGrade","title":"<code>ConcreteGrade</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of standard Eurocode 2 concrete grades.</p> <p>Each member represents a concrete grade with its associated properties.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>class ConcreteGrade(Enum):\n    \"\"\"Enumeration of standard Eurocode 2 concrete grades.\n\n    Each member represents a concrete grade with its associated properties.\n    \"\"\"\n\n    C20_25 = Concrete(\"C20/25\")\n    C25_30 = Concrete(\"C25/30\")\n    C30_37 = Concrete(\"C30/37\")\n    C35_45 = Concrete(\"C35/45\")\n    C40_50 = Concrete(\"C40/50\")\n    C45_55 = Concrete(\"C45/55\")\n    C50_60 = Concrete(\"C50/60\")\n    C55_67 = Concrete(\"C55/67\")\n    C60_75 = Concrete(\"C60/75\")\n    C70_85 = Concrete(\"C70/85\")\n    C80_95 = Concrete(\"C80/95\")\n    C90_105 = Concrete(\"C90/105\")\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.CreepParams","title":"<code>CreepParams</code>  <code>dataclass</code>","text":"<p>Data class for storing parameters used in creep coefficient calculations.</p> <p>Attributes:</p> Name Type Description <code>t</code> <code>int</code> <p>Time in days.</p> <code>h0</code> <code>int</code> <p>Effective height in mm.</p> <code>rh</code> <code>int</code> <p>Relative humidity in percent.</p> <code>t0</code> <code>int</code> <p>Initial time in days.</p> <code>fck</code> <code>float</code> <p>Concrete compressive strength in MPa.</p> <code>cem</code> <code>float</code> <p>Cement parameter.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>@dataclass\nclass CreepParams:\n    \"\"\"Data class for storing parameters used in creep coefficient calculations.\n\n    Attributes:\n        t (int): Time in days.\n        h0 (int): Effective height in mm.\n        rh (int): Relative humidity in percent.\n        t0 (int): Initial time in days.\n        fck (float): Concrete compressive strength in MPa.\n        cem (float): Cement parameter.\n\n    \"\"\"\n\n    t: int = 1000000\n    h0: int = 100\n    rh: int = 65\n    t0: int = 10\n    fck: float = 20.0\n    cem: float = 0.0\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Prestress","title":"<code>Prestress</code>","text":"<p>Represents Eurocode 2 prestressing steel properties.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Prestress--attributes","title":"Attributes","text":"<p>name : str     Name of the prestressing steel type. pType : str     Type of prestressing steel ('strand', 'bar', or 'wire'). zone : str     Zone classification. fpk : float     Characteristic prestress force (MPa). fp0_1k : float     Characteristic prestress force at 0.1% strain (MPa). Ep : float     Modulus of elasticity (MPa). d : float     Diameter (mm). Ap : float     Cross-sectional area (cm\u00b2). gamma_P : float     Partial safety factor for prestressing steel. fpd : float     Design yield strength (MPa).</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Prestress--methods","title":"Methods","text":"<p>repr()     Returns a string representation of the Prestress object. str()     Returns a user-friendly string representation of the Prestress object.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>class Prestress:\n    \"\"\"Represents Eurocode 2 prestressing steel properties.\n\n    Attributes\n    ----------\n    name : str\n        Name of the prestressing steel type.\n    pType : str\n        Type of prestressing steel ('strand', 'bar', or 'wire').\n    zone : str\n        Zone classification.\n    fpk : float\n        Characteristic prestress force (MPa).\n    fp0_1k : float\n        Characteristic prestress force at 0.1% strain (MPa).\n    Ep : float\n        Modulus of elasticity (MPa).\n    d : float\n        Diameter (mm).\n    Ap : float\n        Cross-sectional area (cm\u00b2).\n    gamma_P : float\n        Partial safety factor for prestressing steel.\n    fpd : float\n        Design yield strength (MPa).\n\n    Methods\n    -------\n    __repr__()\n        Returns a string representation of the Prestress object.\n    __str__()\n        Returns a user-friendly string representation of the Prestress object.\n\n    \"\"\"\n\n    def __init__(self, type_label: str | PrestressClass = \"Y1860S7 12.5\") -&gt; None:  # noqa: D107\n        if isinstance(type_label, PrestressClass):\n            class_name = type_label.name\n            self.name = class_name.replace(\"_\", \" \", 1).replace(\"_\", \".\", 1)\n        elif isinstance(type_label, str):\n            self.name = type_label\n            class_name = type_label.replace(\" \", \"_\")\n            class_name = class_name.replace(\".\", \"_\")\n        else:\n            msg = \"type_label must be a string or PrestressClass enum\"\n            raise TypeError(msg)\n\n        if class_name not in dbase.PrestressGrades:\n            grades_list = [\n                item.replace(\"_\", \" \", 1).replace(\"_\", \".\", 1)\n                for item in dbase.PrestressGrades\n            ]\n            msg = (\n                f\"Prestress steel class '{class_name}' not found in database. \"\n                f\"Prestress type must be one of {grades_list}\"\n            )\n            raise ValueError(msg)\n\n        reinf = dbase.PrestressGrades[class_name]\n        self.pType = reinf[\"T\"]  # 'strand', 'bar', or 'wire'\n        self.zone = reinf[\"zone\"]\n        self.fpk = reinf[\"fpk\"]  # Characteristic prestress force (MPa)\n        # Characteristic prestress force at 0.1% strain (MPa)\n        self.fp0_1k = reinf[\"fp0_1k\"]\n        self.Ep = reinf[\"Ep\"]  # Modulus of elasticity (MPa)\n        self.d = reinf[\"d\"]  # Diameter (mm)\n        self.Ap = reinf[\"Ap\"]  # Cross-sectional area (cm\u00b2)\n\n        gamma_p = dbase.PrestressParams[\"gamma_p\"]  # Partial safety factor\n        self.gamma_P = gamma_p\n        self.fpd = round(self.fp0_1k / gamma_p, 0)  # Design yield strength (MPa)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the Prestress object.\n\n        Returns\n        -------\n        str\n            String representation of the Prestress object.\n\n        \"\"\"\n        return (\n            f\"Prestress(name='{self.name}', pType='{self.pType}', zone='{self.zone}', \"\n            f\"fpk={self.fpk}, fp0_1k={self.fp0_1k}, Ep={self.Ep}, d={self.d}, \"\n            f\"Ap={self.Ap}, fpd={self.fpd})\"\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the Prestress object.\n\n        Returns\n        -------\n        str\n            String representation of the Prestress object.\n\n        \"\"\"\n        return (\n            f\"Prestress {self.name} (pType='{self.pType}', zone='{self.zone}', \"\n            f\"fpk={self.fpk} MPa, fp0_1k={self.fp0_1k} MPa, Ep={self.Ep} MPa, \"\n            f\"d={self.d} mm, Ap={self.Ap} cm\u00b2, fpd={self.fpd} MPa)\"\n        )\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Prestress.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the Prestress object.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Prestress.__repr__--returns","title":"Returns","text":"<p>str     String representation of the Prestress object.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the Prestress object.\n\n    Returns\n    -------\n    str\n        String representation of the Prestress object.\n\n    \"\"\"\n    return (\n        f\"Prestress(name='{self.name}', pType='{self.pType}', zone='{self.zone}', \"\n        f\"fpk={self.fpk}, fp0_1k={self.fp0_1k}, Ep={self.Ep}, d={self.d}, \"\n        f\"Ap={self.Ap}, fpd={self.fpd})\"\n    )\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Prestress.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the Prestress object.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Prestress.__str__--returns","title":"Returns","text":"<p>str     String representation of the Prestress object.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the Prestress object.\n\n    Returns\n    -------\n    str\n        String representation of the Prestress object.\n\n    \"\"\"\n    return (\n        f\"Prestress {self.name} (pType='{self.pType}', zone='{self.zone}', \"\n        f\"fpk={self.fpk} MPa, fp0_1k={self.fp0_1k} MPa, Ep={self.Ep} MPa, \"\n        f\"d={self.d} mm, Ap={self.Ap} cm\u00b2, fpd={self.fpd} MPa)\"\n    )\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Reinforcement","title":"<code>Reinforcement</code>","text":"<p>Represents Eurocode 2 steel reinforcement properties.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Reinforcement--attributes","title":"Attributes","text":"<p>grade : str     Steel type label (e.g., 'B500B', 'B500C'). name : str     Name of the reinforcement type. fyk : float     Characteristic yield strength (MPa). epsilon_uk : float     Ultimate strain (\u2030). ftk : float     Characteristic tensile strength (MPa). Es : float     Modulus of elasticity (MPa). ClassType : str     Class type ('A', 'B', or 'C'). gamma_s : float     Partial safety factor for reinforcement. fyd : float     Design yield strength (MPa).</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Reinforcement--methods","title":"Methods","text":"<p>repr()     Returns a string representation of the Reinforcement object. str()     Returns a user-friendly string representation of the Reinforcement object.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>class Reinforcement:\n    \"\"\"Represents Eurocode 2 steel reinforcement properties.\n\n    Attributes\n    ----------\n    grade : str\n        Steel type label (e.g., 'B500B', 'B500C').\n    name : str\n        Name of the reinforcement type.\n    fyk : float\n        Characteristic yield strength (MPa).\n    epsilon_uk : float\n        Ultimate strain (\u2030).\n    ftk : float\n        Characteristic tensile strength (MPa).\n    Es : float\n        Modulus of elasticity (MPa).\n    ClassType : str\n        Class type ('A', 'B', or 'C').\n    gamma_s : float\n        Partial safety factor for reinforcement.\n    fyd : float\n        Design yield strength (MPa).\n\n    Methods\n    -------\n    __repr__()\n        Returns a string representation of the Reinforcement object.\n    __str__()\n        Returns a user-friendly string representation of the Reinforcement object.\n\n    \"\"\"\n\n    def __init__(self, type_label: str | ReinforcementClass = \"B500B\") -&gt; None:\n        if isinstance(type_label, ReinforcementClass):\n            type_label = type_label.name\n        self.grade = type_label\n        self.name = type_label\n\n        if type_label not in dbase.ReinforcementGrades:\n            msg = (\n                f\"Steel type '{type_label}' not found in database. \"\n                f\"Steel type must be one of {list(dbase.ReinforcementGrades.keys())}\"\n            )\n            raise ValueError(msg)\n\n        reinf = dbase.ReinforcementGrades[type_label]\n        self.fyk = reinf[\"fyk\"]  # Characteristic yield strength (MPa)\n        self.epsilon_uk = reinf[\"epsuk\"]  # Ultimate strain (\u2030)\n        self.ftk = reinf[\"ftk\"]  # Characteristic tensile strength (MPa)\n        self.Es = reinf[\"Es\"]  # Modulus of elasticity (MPa)\n        self.ClassType = reinf[\"T\"]  # 'A', 'B', or 'C'\n\n        gamma_s = dbase.ReinforcementParams[\"gamma_s\"]  # Partial safety factor\n        self.gamma_s = GammaS\n        self.fyd = round(self.fyk / gamma_s, 1)  # Design yield strength (MPa)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the Reinforcement object.\n\n        Returns\n        -------\n        str\n            String representation of the Reinforcement object.\n\n        \"\"\"\n        return (\n            f\"Reinforcement(grade='{self.grade}', fyk={self.fyk}, \"\n            f\"epsilon_uk={self.epsilon_uk}, ftk={self.ftk}, Es={self.Es}, \"\n            f\"ClassType='{self.ClassType}', fyd={self.fyd})\"\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the Reinforcement object.\n\n        Returns\n        -------\n        str\n            String representation of the Reinforcement object.\n\n        \"\"\"\n        return (\n            f\"Reinforcement {self.grade} (\"\n            f\"fyk={self.fyk} MPa, \"\n            f\"epsilon_uk={self.epsilon_uk} \u2030, \"\n            f\"ftk={self.ftk} MPa, \"\n            f\"Es={self.Es} MPa, \"\n            f\"ClassType='{self.ClassType}', \"\n            f\"fyd={self.fyd} MPa)\"\n        )\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Reinforcement.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the Reinforcement object.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Reinforcement.__repr__--returns","title":"Returns","text":"<p>str     String representation of the Reinforcement object.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the Reinforcement object.\n\n    Returns\n    -------\n    str\n        String representation of the Reinforcement object.\n\n    \"\"\"\n    return (\n        f\"Reinforcement(grade='{self.grade}', fyk={self.fyk}, \"\n        f\"epsilon_uk={self.epsilon_uk}, ftk={self.ftk}, Es={self.Es}, \"\n        f\"ClassType='{self.ClassType}', fyd={self.fyd})\"\n    )\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Reinforcement.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the Reinforcement object.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.Reinforcement.__str__--returns","title":"Returns","text":"<p>str     String representation of the Reinforcement object.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the Reinforcement object.\n\n    Returns\n    -------\n    str\n        String representation of the Reinforcement object.\n\n    \"\"\"\n    return (\n        f\"Reinforcement {self.grade} (\"\n        f\"fyk={self.fyk} MPa, \"\n        f\"epsilon_uk={self.epsilon_uk} \u2030, \"\n        f\"ftk={self.ftk} MPa, \"\n        f\"Es={self.Es} MPa, \"\n        f\"ClassType='{self.ClassType}', \"\n        f\"fyd={self.fyd} MPa)\"\n    )\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.ReinforcementGrade","title":"<code>ReinforcementGrade</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of standard Eurocode 2 reinforcement steel grades.</p> <p>Each member represents a reinforcement grade with its associated properties.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>class ReinforcementGrade(Enum):\n    \"\"\"Enumeration of standard Eurocode 2 reinforcement steel grades.\n\n    Each member represents a reinforcement grade with its associated properties.\n    \"\"\"\n\n    A400NR = Reinforcement(\"A400NR\")\n    A500NR = Reinforcement(\"A500NR\")\n    A500EL = Reinforcement(\"A500EL\")\n    A400NRSD = Reinforcement(\"A400NRSD\")\n    A500NRSD = Reinforcement(\"A500NRSD\")\n    B400A = Reinforcement(\"B400A\")\n    B400B = Reinforcement(\"B400B\")\n    B400C = Reinforcement(\"B400C\")\n    B500A = Reinforcement(\"B500A\")\n    B500B = Reinforcement(\"B500B\")\n    B500C = Reinforcement(\"B500C\")\n    B600A = Reinforcement(\"B600A\")\n    B600B = Reinforcement(\"B600B\")\n    B600C = Reinforcement(\"B600C\")\n    B700A = Reinforcement(\"B700A\")\n    B700B = Reinforcement(\"B700B\")\n    B700C = Reinforcement(\"B700C\")\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.ShrinkStrainParams","title":"<code>ShrinkStrainParams</code>  <code>dataclass</code>","text":"<p>Data class for storing parameters used in shrinkage strain calculations.</p> <p>Attributes:</p> Name Type Description <code>t</code> <code>int</code> <p>Time in days.</p> <code>h0</code> <code>int</code> <p>Effective height in mm.</p> <code>ts</code> <code>int</code> <p>Time of shrinkage start in days.</p> <code>rh</code> <code>int</code> <p>Relative humidity in percent.</p> <code>fck</code> <code>float</code> <p>Concrete compressive strength in MPa.</p> <code>cem</code> <code>str</code> <p>Cement type.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>@dataclass\nclass ShrinkStrainParams:\n    \"\"\"Data class for storing parameters used in shrinkage strain calculations.\n\n    Attributes:\n        t (int): Time in days.\n        h0 (int): Effective height in mm.\n        ts (int): Time of shrinkage start in days.\n        rh (int): Relative humidity in percent.\n        fck (float): Concrete compressive strength in MPa.\n        cem (str): Cement type.\n\n    \"\"\"\n\n    t: int = 1000000\n    h0: int = 100\n    ts: int = 3\n    rh: int = 65\n    fck: float = 20.0\n    cem: str = \"Type N\"\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.beta_cc","title":"<code>beta_cc(t, s=0.25)</code>","text":"<p>Calculate the strength hardening coefficient.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>time (days)</p> required <code>s</code> <code>float</code> <p>cement type parameter. Optional, defaults to 0.25 (Type N cement)</p> <code>0.25</code> <code>s</code> <code>= 0.20, fast hardening R</code> <p>CEM42,5R, CEM52,5N e CEM52,5R</p> <code>0.25</code> <code>s</code> <code>= 0.25, normal hardening N</code> <p>CEM32,5R, CEM42,5N</p> <code>0.25</code> <code>s</code> <code>= 0.38, slow hardening S</code> <p>CEM32,5N</p> <code>0.25</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>strength hardening coefficient</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>def beta_cc(t: float, s: float = 0.25) -&gt; float:\n    \"\"\"Calculate the strength hardening coefficient.\n\n    Args:\n        t (float): time (days)\n        s (float): cement type parameter. Optional, defaults to 0.25 (Type N cement)\n\n        s = 0.20, fast hardening R: CEM42,5R, CEM52,5N e CEM52,5R\n        s = 0.25, normal hardening N: CEM32,5R, CEM42,5N\n        s = 0.38, slow hardening S: CEM32,5N\n\n    Returns:\n        float: strength hardening coefficient\n\n    \"\"\"\n    return np.exp(s * (1 - np.sqrt(28.0 / t)))\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.beta_ce","title":"<code>beta_ce(t, s=0.25)</code>","text":"<p>Calculate the modulus of elasticity hardening coefficient.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>time (days)</p> required <code>s</code> <code>float</code> <p>cement type parameter. Optional, defaults to 0.25 (Type N cement)</p> <code>0.25</code> <code>s</code> <code>= 0.20, fast hardening R</code> <p>CEM42,5R, CEM52,5N e CEM52,5R</p> <code>0.25</code> <code>s</code> <code>= 0.25, normal hardening N</code> <p>CEM32,5R, CEM42,5N</p> <code>0.25</code> <code>s</code> <code>= 0.38, slow hardening S</code> <p>CEM32,5N</p> <code>0.25</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>modulus of elasticity hardening coefficient</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>def beta_ce(t: float, s: float = 0.25) -&gt; float:\n    \"\"\"Calculate the modulus of elasticity hardening coefficient.\n\n    Args:\n        t (float): time (days)\n        s (float): cement type parameter. Optional, defaults to 0.25 (Type N cement)\n\n        s = 0.20, fast hardening R: CEM42,5R, CEM52,5N e CEM52,5R\n        s = 0.25, normal hardening N: CEM32,5R, CEM42,5N\n        s = 0.38, slow hardening S: CEM32,5N\n\n    Returns:\n        float: modulus of elasticity hardening coefficient\n\n    \"\"\"\n    return (np.exp(s * (1 - np.sqrt(28.0 / t))))**0.3\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.calc_creep_coef","title":"<code>calc_creep_coef(params)</code>","text":"<p>Calculate the creep coefficient using EN1992-1:2004.</p> <p>This function calculates the creep coefficient of concrete based on the time, effective height, relative humidity, initial time, concrete compressive strength, and cement parameter. The creep coefficient is a measure of the time-dependent deformation of concrete under sustained load. It is calculated using the coefficients defined for different concrete compressive strengths and the effects of relative humidity and time.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>CreepParams</code> <p>Parameters for the creep coefficient calculation.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the creep coeficient</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>def calc_creep_coef(params: CreepParams) -&gt; float:\n    \"\"\"Calculate the creep coefficient using EN1992-1:2004.\n\n    This function calculates the creep coefficient of concrete based on the time,\n    effective height, relative humidity, initial time, concrete compressive strength,\n    and cement parameter. The creep coefficient is a measure of the time-dependent\n    deformation of concrete under sustained load. It is calculated using the\n    coefficients defined for different concrete compressive strengths and the effects\n    of relative humidity and time.\n\n    Args:\n        params (CreepParams): Parameters for the creep coefficient calculation.\n\n    Returns:\n        float: the creep coeficient\n\n    \"\"\"\n    t = params.t\n    h0 = params.h0\n    rh = params.rh\n    t0 = params.t0\n    fck = params.fck\n    cem = params.cem\n\n    fcm = _calc_fcm(fck)\n    alpha1, alpha2, alpha3 = _calc_alphas(fcm)\n    tt0 = _calc_tt0(t0, cem)\n    phi_rh = _calc_phi_rh(rh, h0, fcm, alpha1, alpha2)\n    beta_fcm = _calc_beta_fcm(fcm)\n    beta_t0 = _calc_beta_t0(tt0)\n    phi_0 = beta_fcm * beta_t0 * phi_rh\n\n    try:\n        betah = _calc_betah(alpha3, rh, h0)\n        betacc = _calc_betacc(t, t0, betah)\n        phi = betacc * phi_0\n    except (ZeroDivisionError, ValueError, OverflowError):\n        phi = 0.0\n\n    return phi\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.calc_shrink_strain","title":"<code>calc_shrink_strain(params)</code>","text":"<p>Calculate the total shrinkage strain. Uses EN1992-1:2004.</p> <p>This function calculates the total shrinkage strain of concrete based on the time, effective height, time of shrinkage start, relative humidity, concrete compressive strength, and cement type. The shrinkage strain is calculated using the coefficients defined for different cement types and the concrete compressive strength.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ShrinkStrainParams</code> <p>Parameters for shrinkage strain calculation.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the total shrinkage strain</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>def calc_shrink_strain(params: ShrinkStrainParams) -&gt; float:\n    \"\"\"Calculate the total shrinkage strain. Uses EN1992-1:2004.\n\n    This function calculates the total shrinkage strain of concrete based on the time,\n    effective height, time of shrinkage start, relative humidity, concrete compressive\n    strength, and cement type. The shrinkage strain is calculated using the coefficients\n    defined for different cement types and the concrete compressive strength.\n\n    Args:\n        params (ShrinkStrainParams): Parameters for shrinkage strain calculation.\n\n    Returns:\n        float: the total shrinkage strain\n\n    \"\"\"\n    t = params.t\n    h0 = params.h0\n    ts = params.ts\n    rh = params.rh\n    fck = params.fck\n    cem = params.cem\n\n    fcm = fck + 8\n    alpha1 = cemprops[cem][0]\n    alpha2 = cemprops[cem][1]\n\n    eps_ca = 25.0e-6 * (fck - 10)\n    beta_as = 1.0 - np.exp(-0.2 * (t**0.5))\n\n    beta_rh = 1.55 * (1.0 - (rh / 100)**3)\n    eps_cd = beta_rh * 0.85e-6 * ((220 + 110 * alpha1) * np.exp(-alpha2 * fcm / 10.0))\n    beta_ds = (t - ts) / ((t - ts) + 0.4 * h0**1.5)\n\n    return beta_as * eps_ca + beta_ds * eps_cd\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.get_concrete","title":"<code>get_concrete(concrete)</code>","text":"<p>Return a Concrete instance from a string, Concrete, or ConcreteGrade input.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.get_concrete--parameters","title":"Parameters","text":"<p>concrete : str, Concrete, or ConcreteGrade     The concrete specification as a string (e.g., 'C30/37'), a Concrete object,     or a ConcreteGrade enum.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.get_concrete--returns","title":"Returns","text":"<p>Concrete     A Concrete instance corresponding to the input.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.get_concrete--raises","title":"Raises","text":"<p>TypeError     If the input is not a str, Concrete, or ConcreteGrade.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>def get_concrete(concrete: str | Concrete | ConcreteGrade) -&gt; Concrete:\n    \"\"\"Return a Concrete instance from a string, Concrete, or ConcreteGrade input.\n\n    Parameters\n    ----------\n    concrete : str, Concrete, or ConcreteGrade\n        The concrete specification as a string (e.g., 'C30/37'), a Concrete object,\n        or a ConcreteGrade enum.\n\n    Returns\n    -------\n    Concrete\n        A Concrete instance corresponding to the input.\n\n    Raises\n    ------\n    TypeError\n        If the input is not a str, Concrete, or ConcreteGrade.\n\n    \"\"\"\n    if isinstance(concrete, Concrete):\n        return concrete\n    if isinstance(concrete, ConcreteGrade):\n        return concrete.value\n    if isinstance(concrete, str):\n        return Concrete(concrete)\n\n    msg = \"Input must be a str, Concrete, or ConcreteGrade\"\n    raise TypeError(msg)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.get_reinforcement","title":"<code>get_reinforcement(reinforcement)</code>","text":"<p>Return a Reinforcement object from string, Reinforcement, or ReinforcementGrade.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.get_reinforcement--parameters","title":"Parameters","text":"<p>reinforcement : str, Reinforcement, or ReinforcementGrade     The reinforcement specification as a string (e.g., 'B500B'), a     Reinforcement object, or a ReinforcementGrade enum.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.get_reinforcement--returns","title":"Returns","text":"<p>Reinforcement     A Reinforcement instance corresponding to the input.</p>"},{"location":"reference/eurocodepy/ec2/materials/#eurocodepy.ec2.materials.get_reinforcement--raises","title":"Raises","text":"<p>TypeError     If the input is not a str, Reinforcement, or ReinforcementGrade.</p> Source code in <code>eurocodepy/ec2/materials.py</code> <pre><code>def get_reinforcement(\n    reinforcement: str | Reinforcement | ReinforcementGrade,\n) -&gt; Reinforcement:\n    \"\"\"Return a Reinforcement object from string, Reinforcement, or ReinforcementGrade.\n\n    Parameters\n    ----------\n    reinforcement : str, Reinforcement, or ReinforcementGrade\n        The reinforcement specification as a string (e.g., 'B500B'), a\n        Reinforcement object, or a ReinforcementGrade enum.\n\n    Returns\n    -------\n    Reinforcement\n        A Reinforcement instance corresponding to the input.\n\n    Raises\n    ------\n    TypeError\n        If the input is not a str, Reinforcement, or ReinforcementGrade.\n\n    \"\"\"\n    if isinstance(reinforcement, Reinforcement):\n        return reinforcement\n    if isinstance(reinforcement, ReinforcementGrade):\n        return reinforcement.value\n    if isinstance(reinforcement, str):\n        return Reinforcement(reinforcement)\n\n    msg = \"Input must be a str, Reinforcement, or ReinforcementGrade\"\n    raise TypeError(msg)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/fire/","title":"fire","text":""},{"location":"reference/eurocodepy/ec2/fire/fire_base/","title":"fire_base","text":""},{"location":"reference/eurocodepy/ec2/sls/","title":"sls","text":""},{"location":"reference/eurocodepy/ec2/sls/crack/","title":"crack","text":""},{"location":"reference/eurocodepy/ec2/sls/crack/#eurocodepy.ec2.sls.crack.Ac_eff","title":"<code>Ac_eff(b, d, x, h)</code>","text":"<p>Calculates the effective height of the tension zone (h_eff) according to EN 1992-1-1, 7.3.2.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>float</code> <p>Bredth of the beam</p> required <code>d</code> <code>float</code> <p>Effective depth to tension reinforcement</p> required <code>x</code> <code>float</code> <p>Depth of the neutral axis</p> required <code>h</code> <code>float</code> <p>Total section height</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Effective height of the tension zone (h_eff) [mm]</p> Source code in <code>eurocodepy/ec2/sls/crack.py</code> <pre><code>def Ac_eff(b: float, d: float, x: float, h: float) -&gt; float:\n    \"\"\"\n    Calculates the effective height of the tension zone (h_eff) according to EN 1992-1-1, 7.3.2.\n\n    Args:\n        b (float): Bredth of the beam\n        d (float): Effective depth to tension reinforcement\n        x (float): Depth of the neutral axis\n        h (float): Total section height\n\n    Returns:\n        float: Effective height of the tension zone (h_eff) [mm]\n    \"\"\"\n    return min(2.5 * (h - d), (h - x) / 3, h / 2) * b\n</code></pre>"},{"location":"reference/eurocodepy/ec2/sls/crack/#eurocodepy.ec2.sls.crack.crack_opening","title":"<code>crack_opening(b, h, phi, As, ds, Asc, dsc, conc, reinf, M)</code>","text":"<p>Function for calculate the crack opening of a reinforced cocnrete beam.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>float</code> <p>Bredth of the beam</p> required <code>h</code> <code>float</code> <p>Total section height</p> required <code>phi</code> <code>float</code> <p>bar diameter</p> required <code>As</code> <code>ndarray</code> <p>Reinforcement areas</p> required <code>ds</code> <code>ndarray</code> <p>Effective depths to tension reinforcement</p> required <code>conc</code> <code>Concrete</code> <p>Concrete</p> required <code>reinf</code> <code>Reinforcement</code> <p>Reinforcement</p> required <code>M</code> <code>ndarray</code> <p>Bending moments</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>description</p> Source code in <code>eurocodepy/ec2/sls/crack.py</code> <pre><code>def crack_opening(b: float, h: float, phi, As: np.ndarray, ds: np.ndarray, Asc: np.ndarray, dsc: np.ndarray,\n            conc: Union[str, Concrete, ConcreteGrade], reinf: Union[str, Reinforcement, ReinforcementGrade],\n            M: np.ndarray) -&gt; float:\n    \"\"\"Function for calculate the crack opening of a reinforced cocnrete beam.\n\n    Args:\n        b (float): Bredth of the beam\n        h (float): Total section height\n        phi (float): bar diameter\n        As (np.ndarray): Reinforcement areas\n        ds (np.ndarray): Effective depths to tension reinforcement\n        conc (Concrete): Concrete\n        reinf (Reinforcement): Reinforcement\n        M (np.ndarray): Bending moments\n\n    Returns:\n        float: _description_\n    \"\"\"\n    conc = get_concrete(conc)\n    reinf = get_reinforcement(reinf)\n    Ap = np.array([0.0])\n    dp = np.array([h])\n    alpha_Es = 15.0\n    alpha_Ep = 15.0\n    N = np.full_like(M, 0.001)\n    Es = reinf.Es * 1000.0\n    fctm = conc.fctm * 1000.0\n\n    uncrk, crack = calc_section_rectangular(h, b, As, Asc, Ap, ds, dsc, dp, alpha_Es, alpha_Ep, M, N)\n    x = crack[\"NeutralAxis\"]\n    d = np.sum(As * ds + Asc * dsc) / np.sum(As + Asc)\n    ac_eff = Ac_eff(b, d, x, h)\n    rho_p_eff = np.sum(As) / Ac_eff(b, d, x, h)\n    sig_s = alpha_Es * M / crack[\"Inertia\"] * (ds - x)\n    epssm = eps_sm(sig_s, Es, rho_p_eff, fctm, alpha_Es, k_t = 0.4)\n    srmax = sr_max(h-d, phi, rho_p_eff, k1, k2)\n    wk = epssm * srmax * 1000.0\n    return wk\n</code></pre>"},{"location":"reference/eurocodepy/ec2/sls/crack/#eurocodepy.ec2.sls.crack.eps_sm","title":"<code>eps_sm(sigma_s, Es, rho_p_eff, fct_eff, alpha_e, k_t=0.6)</code>","text":"<p>Calculates mean strain in reinforcement (eps_sm) according to EN 1992-1-1, 7.3.4.</p> <p>Parameters:</p> Name Type Description Default <code>sigma_s</code> <code>float</code> <p>Stress in reinforcement under relevant load [MPa]</p> required <code>Es</code> <code>float</code> <p>Modulus of elasticity of steel [MPa]</p> required <code>rho_p_eff</code> <code>float</code> <p>Effective reinforcement ratio</p> required <code>fct_eff</code> <code>float</code> <p>Effective tensile strength of concrete [MPa]</p> required <code>alpha_e</code> <code>float</code> <p>Modular ratio (Es/Ecm)</p> required <code>k_t</code> <code>float</code> <p>Coefficient for duration of load (0.6 for short-term, 0.4 for long-term)</p> <code>0.6</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Mean strain in reinforcement (eps_sm)</p> Source code in <code>eurocodepy/ec2/sls/crack.py</code> <pre><code>def eps_sm(sigma_s: float, Es: float, rho_p_eff: float, fct_eff: float, alpha_e: float, k_t: float = 0.6) -&gt; float:\n    \"\"\"\n    Calculates mean strain in reinforcement (eps_sm) according to EN 1992-1-1, 7.3.4.\n\n    Args:\n        sigma_s (float): Stress in reinforcement under relevant load [MPa]\n        Es (float): Modulus of elasticity of steel [MPa]\n        rho_p_eff (float): Effective reinforcement ratio\n        fct_eff (float): Effective tensile strength of concrete [MPa]\n        alpha_e (float): Modular ratio (Es/Ecm)\n        k_t (float): Coefficient for duration of load (0.6 for short-term, 0.4 for long-term)\n\n    Returns:\n        float: Mean strain in reinforcement (eps_sm)\n    \"\"\"\n    sig1 = (sigma_s - k_t * fct_eff * (1.0 + alpha_e * rho_p_eff) / rho_p_eff)\n    sig2 = 0.6 * sigma_s\n    return  np.where(sig1 &gt; sig2, sig1, sig2) / Es\n</code></pre>"},{"location":"reference/eurocodepy/ec2/sls/crack/#eurocodepy.ec2.sls.crack.is_cracked","title":"<code>is_cracked(b, h, phi, As, ds, Asc, dsc, conc, reinf, M)</code>","text":"<p>Function for calculate the crack opening of a reinforced cocnrete beam.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>float</code> <p>Bredth of the beam</p> required <code>h</code> <code>float</code> <p>Total section height</p> required <code>phi</code> <code>float</code> <p>bar diameter</p> required <code>As</code> <code>ndarray</code> <p>Reinforcement areas</p> required <code>ds</code> <code>ndarray</code> <p>Effective depths to tension reinforcement</p> required <code>conc</code> <code>Concrete</code> <p>Concrete</p> required <code>reinf</code> <code>Reinforcement</code> <p>Reinforcement</p> required <code>M</code> <code>ndarray</code> <p>Bending moments</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>bool</code> <p>True if cracked, otherwise False</p> Source code in <code>eurocodepy/ec2/sls/crack.py</code> <pre><code>def is_cracked(b: float, h: float, phi, As: np.ndarray, ds: np.ndarray, Asc: np.ndarray, dsc: np.ndarray,\n            conc: Union[str, Concrete, ConcreteGrade], reinf: Union[str, Reinforcement, ReinforcementGrade],\n            M: np.ndarray) -&gt; bool:\n    \"\"\"Function for calculate the crack opening of a reinforced cocnrete beam.\n\n    Args:\n        b (float): Bredth of the beam\n        h (float): Total section height\n        phi (float): bar diameter\n        As (np.ndarray): Reinforcement areas\n        ds (np.ndarray): Effective depths to tension reinforcement\n        conc (Concrete): Concrete\n        reinf (Reinforcement): Reinforcement\n        M (np.ndarray): Bending moments\n\n    Returns:\n        float: True if cracked, otherwise False\n    \"\"\"\n    conc = get_concrete(conc)\n    reinf = get_reinforcement(reinf)\n    Ap = np.array([0.0])\n    dp = np.array([h])\n    alpha_Es = 15.0\n    alpha_Ep = 15.0\n    N = np.full_like(M, 0.001)\n    Es = reinf.Es * 1000.0\n    fctm = conc.fctm * 1000.0\n\n    uncrk, crack = calc_section_rectangular(h, b, As, Asc, Ap, ds, dsc, dp, alpha_Es, alpha_Ep, M, N)\n    sig_c = M / uncrk[\"Wi\"]\n\n    cracked = np.all(sig_c &lt; fctm)\n    return cracked\n</code></pre>"},{"location":"reference/eurocodepy/ec2/sls/crack/#eurocodepy.ec2.sls.crack.iscracked_annexLL","title":"<code>iscracked_annexLL(fctm, fcm, sigxx, sigyy, sigzz, sigxy, sigyz, sigzx)</code>","text":"<p>Checks if the point is cracked using expression (LL.101) of Annex LL of EN 1992-2:2005. Author. Paulo Cachim (2022)</p> <p>Parameters:</p> Name Type Description Default <code>fctm</code> <code>float</code> <p>mean tensile strength of concrete</p> required <code>fcm</code> <code>float</code> <p>mean comprerssive strength of concrete</p> required <code>sigxx</code> <code>float</code> <p>stress xx</p> required <code>sigyy</code> <code>float</code> <p>stress yy</p> required <code>sigzz</code> <code>float</code> <p>stress zz</p> required <code>sigxy</code> <code>float</code> <p>stress xy</p> required <code>sigyz</code> <code>float</code> <p>stress yz</p> required <code>sigzx</code> <code>float</code> <p>stress zx</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if cracked, False otherwise</p> Source code in <code>eurocodepy/ec2/sls/crack.py</code> <pre><code>def iscracked_annexLL(fctm: float, fcm: float, \n                sigxx: float, sigyy: float, sigzz: float, \n                sigxy: float, sigyz: float, sigzx: float) -&gt; bool:\n    \"\"\"Checks if the point is cracked using expression (LL.101) of Annex LL of EN 1992-2:2005.\n    Author. Paulo Cachim (2022)\n\n    Args:\n        fctm (float): mean tensile strength of concrete\n        fcm (float): mean comprerssive strength of concrete\n        sigxx (float): stress xx\n        sigyy (float): stress yy\n        sigzz (float): stress zz\n        sigxy (float): stress xy\n        sigyz (float): stress yz\n        sigzx (float): stress zx\n\n    Returns:\n        bool: True if cracked, False otherwise\n    \"\"\"\n    # Calculate stress invariants\n    invar = utils.stress.invariants(sigxx, sigyy, sigzz, sigxy, sigyz, sigzx)\n    I1 = invar[0] / fcm\n    J2 = invar[1] / fcm / fcm\n    cos3t = invar[8]\n\n    # Calculate auxiliary parameters\n    k = fctm/fcm\n    c1 = 1.0/(0.7*k**0.9)\n    c2 = 1.0 - 6.8*(k-0.07)**2\n    alpha = 1.0/(9.0*k**1.4)\n    beta = 1.0/(3.7*k**1.1)\n    ang = np.acos(abs(c2 * cos3t))/3.0\n    lamb = c1 * np.cos(ang) if cos3t &gt;= 0 else c1 * (np.pi/3.0-ang)\n\n    # Calculate cracking condition (&gt;0 cracked; &lt;0 uncracked)\n    crack = alpha*J2 + lamb*np.sqrt(J2) + beta*I1 - 1.0\n\n    # Return cracked stated (True: cracked: False: uncracked)\n    return True if crack &gt; 0 else False\n</code></pre>"},{"location":"reference/eurocodepy/ec2/sls/crack/#eurocodepy.ec2.sls.crack.sr_max","title":"<code>sr_max(c, phi, rho_p_eff, k1=0.8, k2=0.5)</code>","text":"<p>Calculates maximum crack spacing sr_max according to EN 1992-1-1, 7.3.4.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>float</code> <p>Concrete cover to the centroid of the tensile reinforcement [mm]</p> required <code>phi</code> <code>float</code> <p>Bar diameter [mm]</p> required <code>rho_p_eff</code> <code>float</code> <p>Effective reinforcement ratio (As,eff / (Ac,eff * \u03c1))</p> required <code>k1</code> <code>float</code> <p>Coefficient for bond properties (0.8 for high bond bars, 1.6 for plain bars)</p> <code>0.8</code> <code>k2</code> <code>float</code> <p>Coefficient for strain distribution (0.5 for bending, 1.0 for pure tension)</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum crack spacing sr_max [mm]</p> Source code in <code>eurocodepy/ec2/sls/crack.py</code> <pre><code>def sr_max(c: float, phi: float, rho_p_eff: float, k1: float = 0.8, k2: float = 0.5) -&gt; float:\n    \"\"\"\n    Calculates maximum crack spacing sr_max according to EN 1992-1-1, 7.3.4.\n\n    Args:\n        c (float): Concrete cover to the centroid of the tensile reinforcement [mm]\n        phi (float): Bar diameter [mm]\n        rho_p_eff (float): Effective reinforcement ratio (As,eff / (Ac,eff * \u03c1))\n        k1 (float): Coefficient for bond properties (0.8 for high bond bars, 1.6 for plain bars)\n        k2 (float): Coefficient for strain distribution (0.5 for bending, 1.0 for pure tension)\n\n    Returns:\n        float: Maximum crack spacing sr_max [mm]\n    \"\"\"\n    return k3 * c + k1 * k2 * k4 * phi / rho_p_eff\n</code></pre>"},{"location":"reference/eurocodepy/ec2/sls/creep/","title":"creep","text":""},{"location":"reference/eurocodepy/ec2/sls/creep/#eurocodepy.ec2.sls.creep.creep_coef","title":"<code>creep_coef(t, t0, fcm28, RH, hn, t0_T, concrete_class)</code>","text":"<p>Calculates the creep coefficient based on time, initial time, concrete compressive strength, relative humidity, effective height, initial temperature, and concrete class. This function computes the creep coefficient using the coefficients defined for different concrete compressive strengths, relative humidity, and time. The creep coefficient is a measure of the time-dependent deformation of concrete under sustained load. It combines the effects of basic creep and drying creep, adjusted for the initial time and temperature. The function uses the concrete class to determine the adjustment factor for the initial time. The function returns the total creep coefficient as a float value. Uses EN1992-1:2025.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>_type_</code> <p>description</p> required <code>t0</code> <code>_type_</code> <p>description</p> required <code>fcm28</code> <code>_type_</code> <p>description</p> required <code>RH</code> <code>_type_</code> <p>description</p> required <code>hn</code> <code>_type_</code> <p>description</p> required <code>t0_T</code> <code>_type_</code> <p>description</p> required <code>concrete_class</code> <code>_type_</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>eurocodepy/ec2/sls/creep.py</code> <pre><code>def creep_coef(t, t0, fcm28, RH, hn, t0_T, concrete_class):\n    \"\"\"Calculates the creep coefficient based on time, initial time, concrete compressive strength, relative humidity, effective height, initial temperature, and concrete class.\n    This function computes the creep coefficient using the coefficients defined for different concrete compressive strengths, relative humidity, and time.\n    The creep coefficient is a measure of the time-dependent deformation of concrete under sustained load.\n    It combines the effects of basic creep and drying creep, adjusted for the initial time and temperature.\n    The function uses the concrete class to determine the adjustment factor for the initial time.\n    The function returns the total creep coefficient as a float value.\n    Uses EN1992-1:2025.\n\n    Args:\n        t (_type_): _description_\n        t0 (_type_): _description_\n        fcm28 (_type_): _description_\n        RH (_type_): _description_\n        hn (_type_): _description_\n        t0_T (_type_): _description_\n        concrete_class (_type_): _description_\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    alpha_sc_val = alpha_sc(concrete_class)\n    t0_adj_val = t0_adj(t0_T, alpha_sc_val)\n    return varphi_bc(t, t0, fcm28, t0_adj_val) + varphi_dc(t, t0, fcm28, RH, hn, t0_adj_val)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/sls/shrinkage/","title":"shrinkage","text":""},{"location":"reference/eurocodepy/ec2/sls/shrinkage/#eurocodepy.ec2.sls.shrinkage.draw_charts","title":"<code>draw_charts(chart_data)</code>","text":"<p>Draws charts related to creep and shrinkage of concrete.</p> <p>Parameters:</p> Name Type Description Default <code>chart_data</code> <p>A dictionary containing the data for the charts.</p> required Source code in <code>eurocodepy/ec2/sls/shrinkage.py</code> <pre><code>def draw_charts(chart_data):\n    \"\"\"\n    Draws charts related to creep and shrinkage of concrete.\n\n    Args:\n        chart_data: A dictionary containing the data for the charts.\n    \"\"\"\n\n    t_values = chart_data[\"t_values\"]\n    epsilon_cs_values = chart_data[\"epsilon_cs_values\"]\n\n    # Chart 1: Creep and shrinkage over time\n    plt.figure(figsize=(10, 6))\n    plt.plot(t_values, epsilon_cs_values)\n    plt.xlabel(\"Time (days)\")\n    plt.ylabel(\"Creep and Shrinkage (x10^-6)\")\n    plt.title(\"Creep and Shrinkage Over Time\")\n    plt.grid(True)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/sls/shrinkage/#eurocodepy.ec2.sls.shrinkage.generate_chart_data","title":"<code>generate_chart_data(fcm28, RH, hn, concrete_class, alpha_NDP_b, alpha_NDP_d)</code>","text":"<p>Generates data for charts related to creep and shrinkage of concrete.</p> <p>Parameters:</p> Name Type Description Default <code>fcm28</code> <p>Characteristic compressive strength of concrete at 28 days (MPa).</p> required <code>RH</code> <p>Relative humidity (%).</p> required <code>hn</code> <p>Notional size of the concrete member (mm).</p> required <code>concrete_class</code> <p>Class of concrete ('CS', 'CN', or 'CR').</p> required <code>alpha_NDP_b</code> <p>Coefficient depending on type of cement.</p> required <code>alpha_NDP_d</code> <p>Coefficient depending on type of cement.</p> required <p>Returns:</p> Type Description <p>A dictionary containing the data for the charts.</p> Source code in <code>eurocodepy/ec2/sls/shrinkage.py</code> <pre><code>def generate_chart_data(fcm28, RH, hn, concrete_class, alpha_NDP_b, alpha_NDP_d):\n    \"\"\"\n    Generates data for charts related to creep and shrinkage of concrete.\n\n    Args:\n        fcm28: Characteristic compressive strength of concrete at 28 days (MPa).\n        RH: Relative humidity (%).\n        hn: Notional size of the concrete member (mm).\n        concrete_class: Class of concrete ('CS', 'CN', or 'CR').\n        alpha_NDP_b: Coefficient depending on type of cement.\n        alpha_NDP_d: Coefficient depending on type of cement.\n\n    Returns:\n        A dictionary containing the data for the charts.\n    \"\"\"\n\n    t_values = np.linspace(0, 365 * 50, 500)  # Time in days, up to 50 years\n    epsilon_cs_values = []\n\n    for t in t_values:\n        epsilon_cs_values.append(shrink_strain(t, 1, fcm28, RH, hn, concrete_class, alpha_NDP_b, alpha_NDP_d))\n\n    return {\n        \"t_values\": t_values,\n        \"epsilon_cs_values\": epsilon_cs_values,\n    }\n</code></pre>"},{"location":"reference/eurocodepy/ec2/sls/shrinkage/#eurocodepy.ec2.sls.shrinkage.generate_table_data","title":"<code>generate_table_data(fcm28, concrete_class, alpha_NDP_b, alpha_NDP_d)</code>","text":"<p>Generates data for the table related to creep and shrinkage of concrete.</p> <p>Parameters:</p> Name Type Description Default <code>fcm28</code> <p>Characteristic compressive strength of concrete at 28 days (MPa).</p> required <code>concrete_class</code> <p>Class of concrete ('CS', 'CN', or 'CR').</p> required <code>alpha_NDP_b</code> <p>Coefficient depending on type of cement.</p> required <code>alpha_NDP_d</code> <p>Coefficient depending on type of cement.</p> required <p>Returns:</p> Type Description <p>A dictionary containing the data for the table.</p> Source code in <code>eurocodepy/ec2/sls/shrinkage.py</code> <pre><code>def generate_table_data(fcm28, concrete_class, alpha_NDP_b, alpha_NDP_d):\n    \"\"\"\n    Generates data for the table related to creep and shrinkage of concrete.\n\n    Args:\n        fcm28: Characteristic compressive strength of concrete at 28 days (MPa).\n        concrete_class: Class of concrete ('CS', 'CN', or 'CR').\n        alpha_NDP_b: Coefficient depending on type of cement.\n        alpha_NDP_d: Coefficient depending on type of cement.\n\n    Returns:\n        A dictionary containing the data for the table.\n    \"\"\"\n\n    RH_values = [50, 65, 80]\n    t_values = [365]  # You specified t = 365 days\n    hn_values = [100, 300, 500, 700, 1000]\n    table_data = {}\n\n    for RH in RH_values:\n        table_data[RH] = {}\n        for hn in hn_values:\n            epsilon_cs_values = []\n            for t in t_values:\n                epsilon_cs_values.append(shrink_strain(t, 1, fcm28, RH, hn, concrete_class, alpha_NDP_b, alpha_NDP_d)*1000.0)\n            table_data[RH][hn] = epsilon_cs_values * 1000\n\n    return table_data\n</code></pre>"},{"location":"reference/eurocodepy/ec2/sls/shrinkage/#eurocodepy.ec2.sls.shrinkage.print_table","title":"<code>print_table(table_data)</code>","text":"<p>Prints the table related to creep and shrinkage of concrete.</p> <p>Parameters:</p> Name Type Description Default <code>table_data</code> <p>A dictionary containing the data for the table.</p> required Source code in <code>eurocodepy/ec2/sls/shrinkage.py</code> <pre><code>def print_table(table_data):\n    \"\"\"\n    Prints the table related to creep and shrinkage of concrete.\n\n    Args:\n        table_data: A dictionary containing the data for the table.\n    \"\"\"\n\n    RH_values = sorted(table_data.keys())\n    hn_values = sorted(table_data[RH_values[0]].keys())\n\n    # Print header row\n    print(\"RH \\\\ hn\\t\", end=\"\")\n    for hn in hn_values:\n        print(f\"{hn}\\t\", end=\"\")\n    print()\n\n    # Print data rows\n    for RH in RH_values:\n        print(f\"{RH}\\t\", end=\"\")\n        for hn in hn_values:\n            print(f\"{table_data[RH][hn][0]:.2f}\\t\", end=\"\")  # Assuming one t value\n        print()\n</code></pre>"},{"location":"reference/eurocodepy/ec2/sls/shrinkage/#eurocodepy.ec2.sls.shrinkage.shrink_strain","title":"<code>shrink_strain(t, ts, fcm28, RH, hn, concrete_class, alpha_NDP_b, alpha_NDP_d)</code>","text":"<p>Calculates the total shrinkage and creep strain of concrete based on time, initial time, concrete compressive strength, relative humidity, effective height, concrete class, and coefficients for cement type. This function computes the total strain by combining the basic creep strain and drying shrinkage strain, adjusted for the initial time and temperature. The basic creep strain is calculated using the concrete compressive strength and the coefficients for the concrete class. The drying shrinkage strain is calculated using the relative humidity, effective height, and coefficients for the concrete class. The function returns the total strain as a float value. Uses EN1992-1:2025.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>_type_</code> <p>description</p> required <code>ts</code> <code>_type_</code> <p>description</p> required <code>fcm28</code> <code>_type_</code> <p>description</p> required <code>RH</code> <code>_type_</code> <p>description</p> required <code>hn</code> <code>_type_</code> <p>description</p> required <code>concrete_class</code> <code>_type_</code> <p>description</p> required <code>alpha_NDP_b</code> <code>_type_</code> <p>description</p> required <code>alpha_NDP_d</code> <code>_type_</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>eurocodepy/ec2/sls/shrinkage.py</code> <pre><code>def shrink_strain(t, ts, fcm28, RH, hn, concrete_class, alpha_NDP_b, alpha_NDP_d):\n    \"\"\"Calculates the total shrinkage and creep strain of concrete based on time, initial time, concrete compressive strength, relative humidity, effective height, concrete class, and coefficients for cement type.\n    This function computes the total strain by combining the basic creep strain and drying shrinkage strain, adjusted for the initial time and temperature.\n    The basic creep strain is calculated using the concrete compressive strength and the coefficients for the concrete class.\n    The drying shrinkage strain is calculated using the relative humidity, effective height, and coefficients for the concrete class.\n    The function returns the total strain as a float value. Uses EN1992-1:2025.\n\n    Args:\n        t (_type_): _description_\n        ts (_type_): _description_\n        fcm28 (_type_): _description_\n        RH (_type_): _description_\n        hn (_type_): _description_\n        concrete_class (_type_): _description_\n        alpha_NDP_b (_type_): _description_\n        alpha_NDP_d (_type_): _description_\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    alpha_bs, alpha_ds = get_alpha_bs_ds(concrete_class)\n    return epsilon_cbs(t, fcm28, alpha_bs, alpha_NDP_b) + epsilon_cds(t, ts, fcm28, RH, hn, alpha_ds, alpha_NDP_d)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/","title":"uls","text":""},{"location":"reference/eurocodepy/ec2/uls/beam/","title":"beam","text":""},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.RCBeam","title":"<code>RCBeam</code>","text":"<p>A reinforced concrete beam object for ULS checks in bending and shear.</p>"},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.RCBeam--attributes","title":"Attributes","text":"<p>b : float     Breadth of the beam in meters. h : float     Height of the beam in meters. at : float     Tensile reinforcement mechanical cover in meters. ac : float     Compressive reinforcement mechanical cover in meters. conc : Union[str, Concrete, ConcreteGrade]     Concrete class or object. reinf : Union[str, Reinforcement, ReinforcementGrade]     Reinforcement class or object.</p>"},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.RCBeam--methods","title":"Methods","text":"<p>calc_shear(ved: float, cott: float = 2.5)     Calculate shear parameters for the beam. calc_bending(med: float, iprint: bool = False)     Calculate bending reinforcement for the beam.</p> Source code in <code>eurocodepy/ec2/uls/beam.py</code> <pre><code>class RCBeam:\n    \"\"\"A reinforced concrete beam object for ULS checks in bending and shear.\n\n    Attributes\n    ----------\n    b : float\n        Breadth of the beam in meters.\n    h : float\n        Height of the beam in meters.\n    at : float\n        Tensile reinforcement mechanical cover in meters.\n    ac : float\n        Compressive reinforcement mechanical cover in meters.\n    conc : Union[str, Concrete, ConcreteGrade]\n        Concrete class or object.\n    reinf : Union[str, Reinforcement, ReinforcementGrade]\n        Reinforcement class or object.\n\n    Methods\n    -------\n    calc_shear(ved: float, cott: float = 2.5)\n        Calculate shear parameters for the beam.\n    calc_bending(med: float, iprint: bool = False)\n        Calculate bending reinforcement for the beam.\n\n    \"\"\"\n\n    def __init__(self, b: float, h: float, at: float, ac: float,\n                conc: str | Concrete | ConcreteGrade = \"C20/25\",\n                reinf: str | Reinforcement | ReinforcementGrade = \"B500B\") -&gt; None:\n        \"\"\"Reinforced concrete beam object.\n\n        Characterized by bredth (b), height (h), reinforcement covers  and materials.\n        Checks ULS for bending and shear.\n\n        Args:\n            b (float): bredth of the beam in m.\n            h (float): height of the beam in m.\n            conc (str, optional): concrete class. Defaults to \"C25/30\".\n            reinf (str, optional): reinforcement lass. Defaults to \"B500B\".\n            at (float, optional): tensile reinforcement mechanical cover.\n            Defaults to 0.05 m.\n            ac (float, optional): compressive reinforcement mechanical cover.\n            Defaults to 0.05 m.\n\n        \"\"\"\n        self.concrete = get_concrete(conc)\n        self.reinforcement = get_reinforcement(reinf)\n        self.b = b\n        self.h = h\n        self.conc = conc\n        self.reinf = reinf\n        self.at = at\n        self.ac = ac\n        self.d = self.h - self.at\n        self.fck = self.concrete.fck\n        self.fyk = self.reinforcement.fyk\n        self.gammac = GammaC\n        self.gammas = GammaS\n        self.fcd = self.concrete.fck\n        self.fyd = self.reinforcement.fyd\n\n    def calc_shear(self, ved: float,\n        cott: float = 2.5) -&gt; tuple[float, float, float, float, float, float, float]:\n        \"\"\"Calculate shear parameters for the reinforced concrete beam.\n\n        Args:\n            ved (float): Design shear force.\n            cott (float, optional): Truss inclination (cotangent of theta).\n            Defaults to 2.5.\n\n        Returns:\n            Tuple[float, float, float, float, float, float, float]:\n                aslt, aslc, alpha, epsst, epssc, asws, vrdmax\n\n        \"\"\"\n        aslt = 0.0\n        aslc = 0.0\n        alpha = 0.0\n        epsst = 0.0\n        epssc = 0.0\n        vrdmax = 0.0\n\n        # cotetas = np.arange(1.0, 2.5001, 0.1)  # noqa: ERA001\n        # vrdmaxs = calc_vrdmax(self.b, self.d, self.fck, self.gammac, self.fyk, \n        # self.gammas, cotetas)\n        # min_val = np.min((lambda i: i &gt; ved, vrdmaxs))  # noqa: ERA001\n        # cott = cotetas[i]  # noqa: ERA001\n\n        asws_val, vrdmax = calc_asws(self.b, self.d, self.fck, self.gammac,\n                        self.fyk, self.gammas, cott, ved)\n        return aslt, aslc, alpha, epsst, epssc, asws_val, vrdmax\n\n    def calc_bending(self, med: float, iprint: bool = False,\n                ) -&gt; tuple[float, float, float, float, float]:\n        \"\"\"Calculate the reinforcement area in a rectangular concrete beam.\n\n        Args:\n            med (float): design bending moment in kNm.\n            delta (float, optional): redistribution ratio (0.7 to 1.0). Defaults to 1.0\n            (no redistribution).\n            iprint (bool, optional): prints results to stdout. Defaults to False.\n\n        Returns:\n            Tuple[float, float, float, float, float]: reinforcement area in cm2,\n            strain in reinforcement, neutral axis depth.\n\n        \"\"\"\n        # Calculate med_max\n        alpha_c = self.ac / self.d\n        epscu2 = self.concrete.eps_cu2\n\n        alpha_lim = 0.45 if self.fck &lt;= 50 else 0.35  # correct this values for fck &gt; 50\n        omega_max = alpha_lim / 1.25\n        miu_max = omega_max * (1 - 0.5 * omega_max)\n        med_max = miu_max * self.b * self.d * self.d * self.fck / self.gammac * 1000.0\n\n        aslt = 0.0\n        aslc = 0.0\n        alpha = 0.0\n        epsst = 0.0\n        epssc = 0.0\n\n        # Check if miu is less than miu-max and calculate reinforcement accordingly\n        # if med &lt;= med_max:\n        med_eff = np.minimum(med, med_max)\n        aslt, epsst, alpha = calc_asl(\n            self.b, self.d, med_eff, self.fcd, self.fyd, iprint)\n        aslc = np.where(med &lt;= med_max, 0.0,\n                    (med - med_max) / ((self.d - self.ac) * self.fyd) * 10.0)\n        aslt += aslc\n        epssc = np.where(med &lt;= med_max, None, (alpha - alpha_c) / alpha * epscu2)\n\n        return np.array([aslt, aslc, alpha, epsst, epssc])\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.RCBeam.__init__","title":"<code>__init__(b, h, at, ac, conc='C20/25', reinf='B500B')</code>","text":"<p>Reinforced concrete beam object.</p> <p>Characterized by bredth (b), height (h), reinforcement covers  and materials. Checks ULS for bending and shear.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>float</code> <p>bredth of the beam in m.</p> required <code>h</code> <code>float</code> <p>height of the beam in m.</p> required <code>conc</code> <code>str</code> <p>concrete class. Defaults to \"C25/30\".</p> <code>'C20/25'</code> <code>reinf</code> <code>str</code> <p>reinforcement lass. Defaults to \"B500B\".</p> <code>'B500B'</code> <code>at</code> <code>float</code> <p>tensile reinforcement mechanical cover.</p> required <code>ac</code> <code>float</code> <p>compressive reinforcement mechanical cover.</p> required Source code in <code>eurocodepy/ec2/uls/beam.py</code> <pre><code>def __init__(self, b: float, h: float, at: float, ac: float,\n            conc: str | Concrete | ConcreteGrade = \"C20/25\",\n            reinf: str | Reinforcement | ReinforcementGrade = \"B500B\") -&gt; None:\n    \"\"\"Reinforced concrete beam object.\n\n    Characterized by bredth (b), height (h), reinforcement covers  and materials.\n    Checks ULS for bending and shear.\n\n    Args:\n        b (float): bredth of the beam in m.\n        h (float): height of the beam in m.\n        conc (str, optional): concrete class. Defaults to \"C25/30\".\n        reinf (str, optional): reinforcement lass. Defaults to \"B500B\".\n        at (float, optional): tensile reinforcement mechanical cover.\n        Defaults to 0.05 m.\n        ac (float, optional): compressive reinforcement mechanical cover.\n        Defaults to 0.05 m.\n\n    \"\"\"\n    self.concrete = get_concrete(conc)\n    self.reinforcement = get_reinforcement(reinf)\n    self.b = b\n    self.h = h\n    self.conc = conc\n    self.reinf = reinf\n    self.at = at\n    self.ac = ac\n    self.d = self.h - self.at\n    self.fck = self.concrete.fck\n    self.fyk = self.reinforcement.fyk\n    self.gammac = GammaC\n    self.gammas = GammaS\n    self.fcd = self.concrete.fck\n    self.fyd = self.reinforcement.fyd\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.RCBeam.calc_bending","title":"<code>calc_bending(med, iprint=False)</code>","text":"<p>Calculate the reinforcement area in a rectangular concrete beam.</p> <p>Parameters:</p> Name Type Description Default <code>med</code> <code>float</code> <p>design bending moment in kNm.</p> required <code>delta</code> <code>float</code> <p>redistribution ratio (0.7 to 1.0). Defaults to 1.0</p> required <code>iprint</code> <code>bool</code> <p>prints results to stdout. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>float</code> <p>Tuple[float, float, float, float, float]: reinforcement area in cm2,</p> <code>float</code> <p>strain in reinforcement, neutral axis depth.</p> Source code in <code>eurocodepy/ec2/uls/beam.py</code> <pre><code>def calc_bending(self, med: float, iprint: bool = False,\n            ) -&gt; tuple[float, float, float, float, float]:\n    \"\"\"Calculate the reinforcement area in a rectangular concrete beam.\n\n    Args:\n        med (float): design bending moment in kNm.\n        delta (float, optional): redistribution ratio (0.7 to 1.0). Defaults to 1.0\n        (no redistribution).\n        iprint (bool, optional): prints results to stdout. Defaults to False.\n\n    Returns:\n        Tuple[float, float, float, float, float]: reinforcement area in cm2,\n        strain in reinforcement, neutral axis depth.\n\n    \"\"\"\n    # Calculate med_max\n    alpha_c = self.ac / self.d\n    epscu2 = self.concrete.eps_cu2\n\n    alpha_lim = 0.45 if self.fck &lt;= 50 else 0.35  # correct this values for fck &gt; 50\n    omega_max = alpha_lim / 1.25\n    miu_max = omega_max * (1 - 0.5 * omega_max)\n    med_max = miu_max * self.b * self.d * self.d * self.fck / self.gammac * 1000.0\n\n    aslt = 0.0\n    aslc = 0.0\n    alpha = 0.0\n    epsst = 0.0\n    epssc = 0.0\n\n    # Check if miu is less than miu-max and calculate reinforcement accordingly\n    # if med &lt;= med_max:\n    med_eff = np.minimum(med, med_max)\n    aslt, epsst, alpha = calc_asl(\n        self.b, self.d, med_eff, self.fcd, self.fyd, iprint)\n    aslc = np.where(med &lt;= med_max, 0.0,\n                (med - med_max) / ((self.d - self.ac) * self.fyd) * 10.0)\n    aslt += aslc\n    epssc = np.where(med &lt;= med_max, None, (alpha - alpha_c) / alpha * epscu2)\n\n    return np.array([aslt, aslc, alpha, epsst, epssc])\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.RCBeam.calc_shear","title":"<code>calc_shear(ved, cott=2.5)</code>","text":"<p>Calculate shear parameters for the reinforced concrete beam.</p> <p>Parameters:</p> Name Type Description Default <code>ved</code> <code>float</code> <p>Design shear force.</p> required <code>cott</code> <code>float</code> <p>Truss inclination (cotangent of theta).</p> <code>2.5</code> <p>Returns:</p> Type Description <code>tuple[float, float, float, float, float, float, float]</code> <p>Tuple[float, float, float, float, float, float, float]: aslt, aslc, alpha, epsst, epssc, asws, vrdmax</p> Source code in <code>eurocodepy/ec2/uls/beam.py</code> <pre><code>def calc_shear(self, ved: float,\n    cott: float = 2.5) -&gt; tuple[float, float, float, float, float, float, float]:\n    \"\"\"Calculate shear parameters for the reinforced concrete beam.\n\n    Args:\n        ved (float): Design shear force.\n        cott (float, optional): Truss inclination (cotangent of theta).\n        Defaults to 2.5.\n\n    Returns:\n        Tuple[float, float, float, float, float, float, float]:\n            aslt, aslc, alpha, epsst, epssc, asws, vrdmax\n\n    \"\"\"\n    aslt = 0.0\n    aslc = 0.0\n    alpha = 0.0\n    epsst = 0.0\n    epssc = 0.0\n    vrdmax = 0.0\n\n    # cotetas = np.arange(1.0, 2.5001, 0.1)  # noqa: ERA001\n    # vrdmaxs = calc_vrdmax(self.b, self.d, self.fck, self.gammac, self.fyk, \n    # self.gammas, cotetas)\n    # min_val = np.min((lambda i: i &gt; ved, vrdmaxs))  # noqa: ERA001\n    # cott = cotetas[i]  # noqa: ERA001\n\n    asws_val, vrdmax = calc_asws(self.b, self.d, self.fck, self.gammac,\n                    self.fyk, self.gammas, cott, ved)\n    return aslt, aslc, alpha, epsst, epssc, asws_val, vrdmax\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.calc_asl","title":"<code>calc_asl(b, d, med, fcd=13.7, fyd=348.0, iprint=False)</code>","text":"<p>Calculate the reinforcement in a rectangular concrete beam.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>float</code> <p>bredth of the beam in m.</p> required <code>d</code> <code>float</code> <p>depth of the reinforced in beam in m.</p> required <code>med</code> <code>float</code> <p>bending moment in kNm.</p> required <code>fcd</code> <code>float</code> <p>concrete strength in MPa. Defaults to 20.0.</p> <code>13.7</code> <code>fyd</code> <code>float</code> <p>reinforcement strength in MPa. Defaults to 400.0.</p> <code>348.0</code> <code>iprint</code> <code>bool</code> <p>print results. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>float</code> <p>Tuple[float, float, float, float]: reinforcement area in cm2,</p> <code>float</code> <p>strain in reinforcement, neutral axis depth, omega.</p> Source code in <code>eurocodepy/ec2/uls/beam.py</code> <pre><code>def calc_asl(b: float, d: float, med: float, fcd: float = 13.7,\n        fyd: float = 348.0, iprint: bool = False) -&gt; tuple[float, float, float]:\n    \"\"\"Calculate the reinforcement in a rectangular concrete beam.\n\n    Args:\n        b (float): bredth of the beam in m.\n        d (float): depth of the reinforced in beam in m.\n        med (float): bending moment in kNm.\n        fcd (float, optional): concrete strength in MPa. Defaults to 20.0.\n        fyd (float, optional): reinforcement strength in MPa. Defaults to 400.0.\n        iprint (bool, optional): print results. Defaults to False.\n\n    Returns:\n        Tuple[float, float, float, float]: reinforcement area in cm2,\n        strain in reinforcement, neutral axis depth, omega.\n\n    \"\"\"\n    mmed = med\n    bb = b\n    miu = mmed / bb / d**2 / fcd / 1000.0\n    try:\n        omega = 1.0 - np.sqrt(1 - 2 * miu)\n    except ValueError:\n        omega = np.nan\n    alpha = 1.25 * omega\n    ast = omega * b * d * fcd / fyd * 10000.0\n    epss = (1.0 - alpha) * 3.5 / alpha\n    if iprint:\n        print(\n            f\"miu={miu:.3f} omega={round(omega, 3):.3f} x/d={alpha:.3f} \"\n            f\"eps-s={epss:.3f} As={ast:.2f} cm2\",\n        )\n    return ast, epss, alpha\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.calc_asws","title":"<code>calc_asws(bw, d, fck, g_c, fyk, g_s, cott, ved)</code>","text":"<p>Calculate the design shear reinforcement.</p> <p>Parameters:</p> Name Type Description Default <code>bw</code> <code>float</code> <p>beam width</p> required <code>d</code> <code>float</code> <p>beam depth</p> required <code>fck</code> <code>float</code> <p>concrete compressive strength</p> required <code>g_c</code> <code>float</code> <p>concrete partial safety coefficient</p> required <code>fyk</code> <code>float</code> <p>steel strength</p> required <code>g_s</code> <code>float</code> <p>steel partial safety coefficient</p> required <code>cott</code> <code>float</code> <p>truss inclination (cot)</p> required <code>ved</code> <code>float</code> <p>design shear force</p> required <code>alpha</code> <code>float</code> <p>coefficient</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>Tuple[float, float]: (shear reinforcement (Asw/s), maximum shear force Vrd.max)</p> Source code in <code>eurocodepy/ec2/uls/beam.py</code> <pre><code>def calc_asws(bw: float, d: float, fck: float, g_c: float, fyk: float, g_s: float,\n            cott: float, ved: float) -&gt; tuple[float, float]:\n    \"\"\"Calculate the design shear reinforcement.\n\n    Args:\n        bw (float): beam width\n        d (float): beam depth\n        fck (float): concrete compressive strength\n        g_c (float): concrete partial safety coefficient\n        fyk (float): steel strength\n        g_s (float): steel partial safety coefficient\n        cott (float): truss inclination (cot)\n        ved (float): design shear force\n        alpha (float): coefficient\n\n    Returns:\n        Tuple[float, float]: (shear reinforcement (Asw/s), maximum shear force Vrd.max)\n\n    \"\"\"\n    z = 0.9 * d\n    niu = 0.6 * (1.0 - fck / 250)\n    vrd_max = bw * z * niu * fck / g_c * 1000.0 / (cott + 1.0 / cott)\n\n    asw_s = ved / z / fyk * g_s / cott / 1000.0 if vrd_max &gt;= ved else np.nan\n    return asw_s, vrd_max\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.calc_mrd","title":"<code>calc_mrd(b, d, ast, fcd=20.0, fyd=400.0, iprint=False)</code>","text":"<p>Calculate the bending moment in a rectangular concrete beam.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>float</code> <p>bredth of the beam in m.</p> required <code>d</code> <code>float</code> <p>depth of the reinforced in beam in m.</p> required <code>ast</code> <code>float</code> <p>reinforcement area in cm2.</p> required <code>fcd</code> <code>float</code> <p>concrete strength in MPa. Defaults to 20.0.</p> <code>20.0</code> <code>fyd</code> <code>float</code> <p>reinforcement strength in MPa. Defaults to 400.0.</p> <code>400.0</code> <code>iprint</code> <code>bool</code> <p>print results. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>float</code> <p>Tuple[float, float, float]: bending moment in kNm, strain in reinforcement,</p> <code>float</code> <p>neutral axis depth.</p> Source code in <code>eurocodepy/ec2/uls/beam.py</code> <pre><code>def calc_mrd(b: float, d: float, ast: float, fcd: float = 20.0, fyd: float = 400.0,\n            iprint: bool = False) -&gt; tuple[float, float, float]:\n    \"\"\"Calculate the bending moment in a rectangular concrete beam.\n\n    Args:\n        b (float): bredth of the beam in m.\n        d (float): depth of the reinforced in beam in m.\n        ast (float): reinforcement area in cm2.\n        fcd (float, optional): concrete strength in MPa. Defaults to 20.0.\n        fyd (float, optional): reinforcement strength in MPa. Defaults to 400.0.\n        iprint (bool, optional): print results. Defaults to False.\n\n    Returns:\n        Tuple[float, float, float]: bending moment in kNm, strain in reinforcement,\n        neutral axis depth.\n\n    \"\"\"\n    omega = ast * fyd / b / d / fcd / 10000.0\n    miu = omega * (1 - 0.5 * omega)\n    alpha = 1.25 * omega\n    epss = (1.0 - alpha) * 3.5 / alpha\n    mrd = miu * b * d * d * fcd * 1000\n    if iprint:\n        print(\n            f\"med={mrd:.1f} kNm; miu={round(miu, 3):.3f}; \"\n            f\"omega={round(omega, 3):.3f}\",\n        )\n    return mrd, epss, alpha\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.calc_vrd","title":"<code>calc_vrd(bw, d, fck, g_c, fyk, g_s, cott, asw_s)</code>","text":"<p>Calculate the design shear strength Vrds and Vrd.max.</p> <p>Parameters:</p> Name Type Description Default <code>bw</code> <code>float</code> <p>beam width</p> required <code>d</code> <code>float</code> <p>beam depth</p> required <code>fck</code> <code>float</code> <p>concrete compressive strength</p> required <code>g_c</code> <code>float</code> <p>concrete partial safety coefficient</p> required <code>fyk</code> <code>float</code> <p>steel strength</p> required <code>g_s</code> <code>float</code> <p>steel partial safety coefficient</p> required <code>cott</code> <code>float</code> <p>truss inclination (cot)</p> required <code>asw_s</code> <code>float</code> <p>steel transverse area (Asw/s)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>(shear reinforcement max(Asw/s), Vrd.max)</p> Source code in <code>eurocodepy/ec2/uls/beam.py</code> <pre><code>def calc_vrd(bw: float, d: float, fck: float, g_c: float, fyk: float, g_s: float,\n            cott: float, asw_s: float) -&gt; float:\n    \"\"\"Calculate the design shear strength Vrds and Vrd.max.\n\n    Args:\n        bw (float): beam width\n        d (float): beam depth\n        fck (float): concrete compressive strength\n        g_c (float): concrete partial safety coefficient\n        fyk (float): steel strength\n        g_s (float): steel partial safety coefficient\n        cott (float): truss inclination (cot)\n        asw_s (float): steel transverse area (Asw/s)\n\n    Returns:\n        float: (shear reinforcement max(Asw/s), Vrd.max)\n\n    \"\"\"\n    z = 0.9 * d\n    vrd_s = asw_s * z * fyk / g_s * cott * 1000.0\n    niu = 0.6 * (1.0 - fck / 250)\n    vrd_max = bw * z * niu * fck / g_c * 100.0 / (cott + 1.0 / cott)\n    return max(vrd_s, vrd_max)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.calc_vrdc","title":"<code>calc_vrdc(bw, d, fck, g_c, rho_l)</code>","text":"<p>Shear strength without shear reinforcement.</p> <p>Parameters:</p> Name Type Description Default <code>bw</code> <code>float</code> <p>beam width</p> required <code>d</code> <code>float</code> <p>beam depth</p> required <code>fck</code> <code>float</code> <p>concrete compressive strength</p> required <code>g_c</code> <code>float</code> <p>concrete partial safety coefficient</p> required <code>rho_l</code> <code>float</code> <p>longitudinal reinforcement ratio (As/bd)</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>Tuple[float, float, float]: (vrd.min, vrd.c, vrd [min(vrd.mmin, vrd.c])</p> Source code in <code>eurocodepy/ec2/uls/beam.py</code> <pre><code>def calc_vrdc(bw: float, d: float, fck: float,\n            g_c: float, rho_l: float) -&gt; tuple[float, float, float]:\n    \"\"\"Shear strength without shear reinforcement.\n\n    Args:\n        bw (float): beam width\n        d (float): beam depth\n        fck (float): concrete compressive strength\n        g_c (float): concrete partial safety coefficient\n        rho_l (float): longitudinal reinforcement ratio (As/bd)\n\n    Returns:\n        Tuple[float, float, float]: (vrd.min, vrd.c, vrd [min(vrd.mmin, vrd.c])\n\n    \"\"\"\n    k = min(2.0, 1.0 + np.sqrt(0.2 / d))\n    vrd_min = 35.0 * np.pow(k, 1.5) * np.sqrt(fck) * bw * d\n    vrd_c = 180.0 / g_c * k * (100.0 * rho_l * fck)**(1.0 / 3.0) * bw * d\n    vrd = max(vrd_min, vrd_c)\n    return vrd_min, vrd_c, vrd\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.calc_vrdmax","title":"<code>calc_vrdmax(bw, d, fck, g_c, cott)</code>","text":"<p>Calculate the design shear strength Vrd.max.</p> <p>Parameters:</p> Name Type Description Default <code>bw</code> <code>float</code> <p>beam width</p> required <code>d</code> <code>float</code> <p>beam depth</p> required <code>fck</code> <code>float</code> <p>concrete compressive strength</p> required <code>g_c</code> <code>float</code> <p>concrete partial safety coefficient</p> required <code>cott</code> <code>float</code> <p>angle of concrete struts</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Vrd.max</p> Source code in <code>eurocodepy/ec2/uls/beam.py</code> <pre><code>def calc_vrdmax(bw: float, d: float, fck: float, g_c: float, cott: float) -&gt; float:\n    \"\"\"Calculate the design shear strength Vrd.max.\n\n    Args:\n        bw (float): beam width\n        d (float): beam depth\n        fck (float): concrete compressive strength\n        g_c (float): concrete partial safety coefficient\n        cott (float): angle of concrete struts\n\n    Returns:\n        float: Vrd.max\n\n    \"\"\"\n    return bw * 0.9 * d * 0.6 * (1.0 - fck / 250\n                                 ) * fck / g_c * 100.0 / (cott + 1.0 / cott)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/beam/#eurocodepy.ec2.uls.beam.get_bend_params","title":"<code>get_bend_params(conc='C20/25')</code>","text":"<p>Calculate bending parameters for a given concrete class.</p> <p>Parameters:</p> Name Type Description Default <code>conc</code> <code>str</code> <p>Concrete class as a string (e.g., \"C20/25\").</p> <code>'C20/25'</code> <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>tuple[float, float, float]: chi1, chi2, chi parameters for bending calculations.</p> Source code in <code>eurocodepy/ec2/uls/beam.py</code> <pre><code>def get_bend_params(conc: str = \"C20/25\") -&gt; tuple[float, float, float]:\n    \"\"\"Calculate bending parameters for a given concrete class.\n\n    Args:\n        conc (str): Concrete class as a string (e.g., \"C20/25\").\n\n    Returns:\n        tuple[float, float, float]: chi1, chi2, chi parameters for bending calculations.\n\n    \"\"\"\n    concrete = Concrete(conc)\n    n = concrete.n\n    epsc2 = concrete.eps_c2\n    epscu2 = concrete.eps_cu2\n    epsc12 = epsc2 / epscu2\n    chi1 = 1.0 - epsc12 / (n + 1)\n    chi2 = 1.0 - ((n + 1) * (n + 2) * 0.5 - epsc12**2) / ((n + 1) * (n + 2) * chi1)\n    chi = 0.5 * chi1 / chi2\n    return chi1, chi2, chi\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/bend_circ/","title":"bend_circ","text":""},{"location":"reference/eurocodepy/ec2/uls/shear/","title":"shear","text":""},{"location":"reference/eurocodepy/ec2/uls/shear/#eurocodepy.ec2.uls.shear.calc_asws","title":"<code>calc_asws(bw, d, fck, g_c, fyk, g_s, cott, ved)</code>","text":"<p>Calculate the design shear reinforcement.</p> <p>Parameters:</p> Name Type Description Default <code>bw</code> <code>float</code> <p>beam width</p> required <code>d</code> <code>float</code> <p>beam depth</p> required <code>fck</code> <code>float</code> <p>concrete compressive strength</p> required <code>g_c</code> <code>float</code> <p>concrete partial safety coefficient</p> required <code>fyk</code> <code>float</code> <p>steel strength</p> required <code>g_s</code> <code>float</code> <p>steel partial safety coefficient</p> required <code>cott</code> <code>float</code> <p>truss inclination (cot)</p> required <code>ved</code> <code>float</code> <p>design shear force</p> required <code>alpha</code> <code>float</code> <p>coefficient</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>Tuple[float, float]: (shear reinforcement (Asw/s), maximum shear force Vrd.max)</p> Source code in <code>eurocodepy/ec2/uls/shear.py</code> <pre><code>def calc_asws(bw: float, d: float, fck: float, g_c: float, fyk: float, g_s: float,\n            cott: float, ved: float) -&gt; tuple[float, float]:\n    \"\"\"Calculate the design shear reinforcement.\n\n    Args:\n        bw (float): beam width\n        d (float): beam depth\n        fck (float): concrete compressive strength\n        g_c (float): concrete partial safety coefficient\n        fyk (float): steel strength\n        g_s (float): steel partial safety coefficient\n        cott (float): truss inclination (cot)\n        ved (float): design shear force\n        alpha (float): coefficient\n\n    Returns:\n        Tuple[float, float]: (shear reinforcement (Asw/s), maximum shear force Vrd.max)\n\n    \"\"\"\n    z = 0.9 * d\n    niu = 0.6 * (1.0 - fck / 250)\n    vrd_max = bw * z * niu * fck / g_c * 1000.0 / (cott + 1.0 / cott)\n\n    asw_s = ved / z / fyk * g_s / cott / 1000.0 if vrd_max &gt;= ved else np.nan\n    return asw_s, vrd_max\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/shear/#eurocodepy.ec2.uls.shear.calc_vrd","title":"<code>calc_vrd(bw, d, fck, g_c, fyk, g_s, cott, asw_s)</code>","text":"<p>Calculate the design shear strength Vrds and Vrd.max.</p> <p>Parameters:</p> Name Type Description Default <code>bw</code> <code>float</code> <p>beam width</p> required <code>d</code> <code>float</code> <p>beam depth</p> required <code>fck</code> <code>float</code> <p>concrete compressive strength</p> required <code>g_c</code> <code>float</code> <p>concrete partial safety coefficient</p> required <code>fyk</code> <code>float</code> <p>steel strength</p> required <code>g_s</code> <code>float</code> <p>steel partial safety coefficient</p> required <code>cott</code> <code>float</code> <p>truss inclination (cot)</p> required <code>asw_s</code> <code>float</code> <p>steel transverse area (Asw/s)</p> required <code>alpha</code> <code>float</code> <p>coefficient</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>(shear reinforcement max(Asw/s), Vrd.max)</p> Source code in <code>eurocodepy/ec2/uls/shear.py</code> <pre><code>def calc_vrd(bw: float, d: float, fck: float, g_c: float, fyk: float, g_s: float,\n            cott: float, asw_s: float) -&gt; float:\n    \"\"\"Calculate the design shear strength Vrds and Vrd.max.\n\n    Args:\n        bw (float): beam width\n        d (float): beam depth\n        fck (float): concrete compressive strength\n        g_c (float): concrete partial safety coefficient\n        fyk (float): steel strength\n        g_s (float): steel partial safety coefficient\n        cott (float): truss inclination (cot)\n        asw_s (float): steel transverse area (Asw/s)\n        alpha (float): coefficient\n\n    Returns:\n        float: (shear reinforcement max(Asw/s), Vrd.max)\n\n    \"\"\"\n    z = 0.9 * d\n    vrd_s = asw_s * z * fyk / g_s * cott * 1000.0\n    niu = 0.6 * (1.0 - fck / 250)\n    vrd_max = bw * z * niu * fck / g_c * 100.0 / (cott + 1.0 / cott)\n    return max(vrd_s, vrd_max)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/shear/#eurocodepy.ec2.uls.shear.calc_vrdc","title":"<code>calc_vrdc(bw, d, fck, g_c, rho_l)</code>","text":"<p>Shear strength without shear reinforcement.</p> <p>Parameters:</p> Name Type Description Default <code>bw</code> <code>float</code> <p>beam width</p> required <code>d</code> <code>float</code> <p>beam depth</p> required <code>fck</code> <code>float</code> <p>concrete compressive strength</p> required <code>g_c</code> <code>float</code> <p>concrete partial safety coefficient</p> required <code>rho_l</code> <code>float</code> <p>longitudinal reinforcement ratio (As/bd)</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>Tuple[float, float, float]: (vrd.min, vrd.c, vrd [min(vrd.mmin, vrd.c])</p> Source code in <code>eurocodepy/ec2/uls/shear.py</code> <pre><code>def calc_vrdc(bw: float, d: float, fck: float, g_c: float,\n        rho_l: float) -&gt; tuple[float, float, float]:\n    \"\"\"Shear strength without shear reinforcement.\n\n    Args:\n        bw (float): beam width\n        d (float): beam depth\n        fck (float): concrete compressive strength\n        g_c (float): concrete partial safety coefficient\n        rho_l (float): longitudinal reinforcement ratio (As/bd)\n\n    Returns:\n        Tuple[float, float, float]: (vrd.min, vrd.c, vrd [min(vrd.mmin, vrd.c])\n\n    \"\"\"\n    k = min(2.0, 1.0 + np.sqrt(0.2 / d))\n    vrd_min = 35.0 * np.pow(k, 1.5) * np.sqrt(fck) * bw * d\n    vrd_c = 180.0 / g_c * k * (100.0 * rho_l * fck)**(1.0 / 3.0) * bw * d\n    vrd = max(vrd_min, vrd_c)\n    return vrd_min, vrd_c, vrd\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/shear/#eurocodepy.ec2.uls.shear.calc_vrdmax","title":"<code>calc_vrdmax(bw, d, fck, g_c, cott)</code>","text":"<p>Calculate the design shear strength Vrd.max.</p> <p>Parameters:</p> Name Type Description Default <code>bw</code> <code>float</code> <p>beam width</p> required <code>d</code> <code>float</code> <p>beam depth</p> required <code>fck</code> <code>float</code> <p>concrete compressive strength</p> required <code>g_c</code> <code>float</code> <p>concrete partial safety coefficient</p> required <code>cott</code> <code>float</code> <p>truss inclination (cot)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Vrd.max</p> Source code in <code>eurocodepy/ec2/uls/shear.py</code> <pre><code>def calc_vrdmax(bw: float, d: float, fck: float, g_c: float, cott: float) -&gt; float:\n    \"\"\"Calculate the design shear strength Vrd.max.\n\n    Args:\n        bw (float): beam width\n        d (float): beam depth\n        fck (float): concrete compressive strength\n        g_c (float): concrete partial safety coefficient\n        cott (float): truss inclination (cot)\n\n    Returns:\n        float: Vrd.max\n\n    \"\"\"\n    return bw * 0.9 * d * 0.6 * (1.0 -\n                            fck / 250) * fck / g_c * 100.0 / (cott + 1.0 / cott)\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/shell/","title":"shell","text":""},{"location":"reference/eurocodepy/ec2/uls/shell/#eurocodepy.ec2.uls.shell.cal_reinf_shell_plan","title":"<code>cal_reinf_shell_plan(top_forces, bottom_forces)</code>","text":"<p>Calculate reinforcement for shell plane given top and bottom force tuples.</p> <p>Parameters:</p> Name Type Description Default <code>top_forces</code> <code>tuple</code> <p>(n_t_xx, n_t_yy, n_t_xy)</p> required <code>bottom_forces</code> <code>tuple</code> <p>(n_b_xx, n_b_yy, n_b_xy)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Reinforcement and concrete stresses for both layers.</p> Source code in <code>eurocodepy/ec2/uls/shell.py</code> <pre><code>def cal_reinf_shell_plan(top_forces: tuple, bottom_forces: tuple) -&gt; np.ndarray:\n    \"\"\"Calculate reinforcement for shell plane given top and bottom force tuples.\n\n    Args:\n        top_forces (tuple): (n_t_xx, n_t_yy, n_t_xy)\n        bottom_forces (tuple): (n_b_xx, n_b_yy, n_b_xy)\n\n    Returns:\n        np.ndarray: Reinforcement and concrete stresses for both layers.\n\n    \"\"\"\n    return np.array(\n        calc_reinf_plane(*top_forces) + calc_reinf_plane(*bottom_forces)\n    )\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/shell/#eurocodepy.ec2.uls.shell.calc_reinf_plane","title":"<code>calc_reinf_plane(n_xx, n_yy, n_xy)</code>","text":"<p>Calculate the reinforcement in a plane element.</p> <p>Parameters:</p> Name Type Description Default <code>n_xx</code> <code>float</code> <p>axial force in x direction</p> required <code>n_yy</code> <code>float</code> <p>axial force in y direction</p> required <code>n_xy</code> <code>float</code> <p>shear force in xy direction</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>the reinforecment in both diretions and concrete stresses</p> Source code in <code>eurocodepy/ec2/uls/shell.py</code> <pre><code>def calc_reinf_plane(n_xx: float, n_yy:float, n_xy: float) -&gt; list:\n    \"\"\"Calculate the reinforcement in a plane element.\n\n    Args:\n        n_xx (float): axial force in x direction\n        n_yy (float): axial force in y direction\n        n_xy (float): shear force in xy direction\n\n    Returns:\n        list: the reinforecment in both diretions and concrete stresses\n\n    \"\"\"\n    abs_n_xy = abs(n_xy)\n    n_xx_n_yy = n_xx * n_yy\n    n_xy_2 = n_xy * n_xy\n    if n_xx &gt;= -abs_n_xy and n_yy &gt;= -abs_n_xy:\n        theta = 1.0\n        asx = n_xx + abs_n_xy\n        asy = n_yy + abs_n_xy\n        asc = 2.0 * abs_n_xy\n    elif n_xx &lt; -abs_n_xy and n_xx &lt;= n_yy and n_xx_n_yy &lt;= n_xy_2:\n        theta = 0 if abs_n_xy &lt; 1.0e-12 else -n_xx / abs_n_xy\n        asx = 0.0\n        asy = n_yy + n_xy_2 / abs(n_xx)\n        asc = abs(n_xx) * (1.0 + (abs_n_xy/n_xx)**2)\n    elif n_yy &lt; -abs_n_xy and n_xx &gt;= n_yy and n_xx_n_yy &lt;= n_xy_2:\n        theta = -abs_n_xy / n_yy\n        asx = n_xx + n_xy_2 / abs(n_yy)\n        asy = 0.0\n        asc = abs(n_yy) * (1.0 + (abs_n_xy/n_yy)**2)\n    else:\n        cen = (n_xx + n_yy) * 0.5\n        rad = math.sqrt(n_xy_2+0.25*(n_xx-n_yy)**2)\n        theta = math.atan2(n_xx-n_yy, 2*n_xy) / 2.0\n        theta = 0 if theta == 0 else 1.0/math.tan(theta)\n        asx = 0.0\n        asy = 0.0\n        asc = abs(cen - rad)\n\n    return [asx, asy, asc, theta]\n</code></pre>"},{"location":"reference/eurocodepy/ec2/uls/shell/#eurocodepy.ec2.uls.shell.calc_reinf_shell","title":"<code>calc_reinf_shell(n_xx, n_yy, n_xy, m_xx, m_yy, m_xy, rec, h)</code>","text":"<p>Calculate the forces to ccalculate the reinforcement in a shell element.</p> <p>Parameters:</p> Name Type Description Default <code>n_xx</code> <code>float</code> <p>axial force in x direction</p> required <code>n_yy</code> <code>float</code> <p>axial force in y direction</p> required <code>n_xy</code> <code>float</code> <p>shear force in xy direction</p> required <code>m_xx</code> <code>float</code> <p>moment in x direction (bending)</p> required <code>m_yy</code> <code>float</code> <p>moment in y direction (bending)</p> required <code>m_xy</code> <code>float</code> <p>moment in xy direction (torsion)</p> required <code>rec</code> <code>float</code> <p>cover to reinforcement</p> required <code>h</code> <code>float</code> <p>height of the shell</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.array: the reinforecment in both diretions in top and bottom layer and concrete stresses</p> Source code in <code>eurocodepy/ec2/uls/shell.py</code> <pre><code>def calc_reinf_shell(n_xx: float, n_yy: float, n_xy: float, m_xx: float, m_yy: float, m_xy: float,\n            rec: float, h: float) -&gt; np.ndarray:\n    \"\"\"Calculate the forces to ccalculate the reinforcement in a shell element.\n\n    Args:\n        n_xx (float): axial force in x direction\n        n_yy (float): axial force in y direction\n        n_xy (float): shear force in xy direction\n        m_xx (float): moment in x direction (bending)\n        m_yy (float): moment in y direction (bending)\n        m_xy (float): moment in xy direction (torsion)\n        rec (float): cover to reinforcement\n        h (float): height of the shell\n\n    Returns:\n        np.array: the reinforecment in both diretions in top and bottom layer and concrete stresses\n\n    \"\"\"\n    t = 2 * rec\n    z = h - t\n    if h - 4 * rec &lt; 0:\n        return np.array([math.nan, math.nan, math.nan, math.nan, math.nan, math.nan])\n\n    n_t_xx = (0.5 * n_xx + m_xx / z) / t\n    n_t_yy = (0.5 * n_yy + m_yy / z) / t\n    n_t_xy = (0.5 * n_xy - m_xy / z) / t\n\n    n_b_xx = (0.5 * n_xx - m_xx / z) / t\n    n_b_yy = (0.5 * n_yy - m_yy / z) / t\n    n_b_xy = (0.5 * n_xy + m_xy / z) / t\n\n    as_vect = np.vectorize(cal_reinf_shell_plan, otypes=[np.ndarray])\n    return as_vect(n_t_xx, n_t_yy, n_t_xy, n_b_xx, n_b_yy, n_b_xy)\n</code></pre>"},{"location":"reference/eurocodepy/ec3/","title":"ec3","text":"<p>Eurocode 3 Steel Reinforcement Module.</p> <p>This module provides classes and functions for Eurocode 3 steel reinforcement design. It includes properties for different steel grades and types, as well as profile classes.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.ProfilesCHS","title":"<code>ProfilesCHS = _parse_profiles_CHS()</code>  <code>module-attribute</code>","text":"<p>Dictionary of Eurocode 3 CHS-shaped steel profiles.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.ProfilesI","title":"<code>ProfilesI = _parse_profiles_I()</code>  <code>module-attribute</code>","text":"<p>Dictionary of Eurocode 3 I-shaped steel profiles.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.ProfilesRHS","title":"<code>ProfilesRHS = _parse_profiles_RHS()</code>  <code>module-attribute</code>","text":"<p>Dictionary of Eurocode 3 RHS-shaped steel profiles.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.ProfilesSHS","title":"<code>ProfilesSHS = _parse_profiles_SHS()</code>  <code>module-attribute</code>","text":"<p>Dictionary of Eurocode 3 SHS-shaped steel profiles.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.Bolt","title":"<code>Bolt</code>","text":"<p>Represents a steel bolt according to Eurocode 3.</p> <p>Attributes:</p> Name Type Description <code>diameter</code> <code>str | float</code> <p>Bolt diameter designation (e.g., 'M16' or 16.0).</p> <code>grade</code> <code>str</code> <p>Bolt steel grade (e.g., '8.8').</p> <code>athread</code> <code>float</code> <p>Area of the thread (cm^2). Defaults to None.</p> <code>dnut</code> <code>float</code> <p>Diameter of the nut (mm). Defaults to None.</p> <code>name</code> <code>str</code> <p>Bolt diameter designation (e.g., 'M16').</p> <code>steel</code> <code>str</code> <p>Bolt steel grade (e.g., '8.8').</p> <code>d</code> <code>float</code> <p>Diameter of the bolt (mm).</p> <code>A</code> <code>float</code> <p>Area of the bolt (cm^2).</p> <code>Athread</code> <code>float</code> <p>Area of the thread (cm^2).</p> <code>fub</code> <code>float</code> <p>Characteristic ultimate strength (MPa).</p> <code>fyb</code> <code>float</code> <p>Characteristic yield strength (MPa).</p> <p>Methods:</p> Name Description <code>__str__</code> <p>Returns a string representation of the bolt properties.</p> <code>Raises</code> <p>ValueError: If the grade or diameter is not found in the database.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>class Bolt:\n    \"\"\"Represents a steel bolt according to Eurocode 3.\n\n    Attributes:\n        diameter (str | float): Bolt diameter designation (e.g., 'M16' or 16.0).\n        grade (str): Bolt steel grade (e.g., '8.8').\n        athread (float, optional): Area of the thread (cm^2). Defaults to None.\n        dnut (float, optional): Diameter of the nut (mm). Defaults to None.\n        name (str): Bolt diameter designation (e.g., 'M16').\n        steel (str): Bolt steel grade (e.g., '8.8').\n        d (float): Diameter of the bolt (mm).\n        A (float): Area of the bolt (cm^2).\n        Athread (float): Area of the thread (cm^2).\n        fub (float): Characteristic ultimate strength (MPa).\n        fyb (float): Characteristic yield strength (MPa).\n\n    Methods:\n        __str__(): Returns a string representation of the bolt properties.\n\n        Raises:\n            ValueError: If the grade or diameter is not found in the database.\n\n    \"\"\"\n\n    def __init__(self, diameter: str | float | object, grade: str, athread = None, dnut = None) -&gt; None:  # noqa: D107\n        if grade.replace(\".\", \"_\") not in dbase.BoltGrades:\n            msg = (\n                f\"Bolt grade '{grade}' not found in database. \"\n                f\"Bolt grade must be one of {list(dbase.BoltGrades.keys())}\"\n            )\n            raise ValueError(msg)\n\n        if isinstance(diameter, float) or isinstance(diameter, int):\n            self.name = f\"U{diameter}\"  # U = universal diameter\n            self.d = diameter\n            folga = 1 if diameter &lt;= 12 else 2 if diameter &lt;= 27 else 3\n            self.d0 = diameter + folga\n            self.dnut = dnut if dnut is not None else self.d0  # Optional nut diameter\n            self.A = np.pi * diameter**2 / 4 / 100.0\n            self.Athread = athread if athread is not None else self.A\n        else:\n            if diameter not in dbase.BoltDiameters:\n                msg = (\n                    f\"Bolt diameter '{diameter}' not found in database. \"\n                    f\"Bolt diameter must be one of {list(dbase.BoltDiameters.keys())}\"\n                )\n                raise ValueError(msg)\n\n            bolt = dbase.BoltDiameters[diameter]\n            self.name = diameter\n            self.d = bolt[\"d\"]\n            self.d0 = bolt[\"d0\"]\n            self.dnut = bolt.get(\"dnut\", None)  # Optional nut diameter\n            self.A = bolt[\"A\"]\n            self.Athread = bolt[\"Athread\"]\n\n        bolt_grade = dbase.BoltGrades[grade.replace(\".\", \"_\")]\n        self.steel = grade.replace(\"_\", \".\").upper()\n        self.fub = bolt_grade[\"fub\"]\n        self.fyb = bolt_grade[\"fyb\"]\n        self.gamma_M0 = dbase.SteelParams[\"gamma_M0\"]  # Partial safety factor\n        self.gamma_M1 = dbase.SteelParams[\"gamma_M1\"]  # Partial safety factor\n        self.gamma_M2 = dbase.SteelParams[\"gamma_M2\"]  # Partial safety factor\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the Bolt instance.\n\n        Returns:\n            str: A string describing the bolt properties.\n\n        \"\"\"\n        return (\n            f\"Bolt Type: {self.name}\\n\"\n            f\"Bolt steel grade: {self.steel}\\n\"\n            f\"Characteristic Yield Strength (fyb): {self.fyb} MPa\\n\"\n            f\"Characteristic Ultimate Strength (fub): {self.fub} MPa\\n\"\n            f\"Diameter (d): {self.d} mm\\n\"\n            f\"Area of the bolt (A): {self.A} cm^2\\n\"\n            f\"Area of the thread (Athread): {self.Athread} cm^2\\n\"\n        )\n\n    @staticmethod\n    def M20(grade: str = \"8.8\") -&gt; \"Bolt\":\n        \"\"\"\n        Convenience method to create a Bolt instance with M20 diameter.\n\n        Args:\n            grade (str): Bolt steel grade (e.g., '8.8', '10.9'). Defaults to '8.8'.\n\n        Returns:\n            Bolt: A Bolt instance with M20 diameter and the specified grade.\n        \"\"\"\n        return Bolt(\"M20\", grade)\n\n    @staticmethod\n    def M22(grade: str = \"8.8\") -&gt; \"Bolt\":\n        \"\"\"\n        Convenience method to create a Bolt instance with M22 diameter.\n\n        Args:\n            grade (str): Bolt steel grade (e.g., '8.8', '10.9'). Defaults to '8.8'.\n\n        Returns:\n            Bolt: A Bolt instance with M22 diameter and the specified grade.\n        \"\"\"\n        return Bolt(\"M22\", grade)\n\n    @staticmethod\n    def M24(grade: str = \"8.8\") -&gt; \"Bolt\":\n        \"\"\"\n        Convenience method to create a Bolt instance with M24 diameter.\n\n        Args:\n            grade (str): Bolt steel grade (e.g., '8.8', '10.9'). Defaults to '8.8'.\n\n        Returns:\n            Bolt: A Bolt instance with M24 diameter and the specified grade.\n        \"\"\"\n        return Bolt(\"M24\", grade)\n\n    @staticmethod\n    def M27(grade: str = \"8.8\") -&gt; \"Bolt\":\n        \"\"\"\n        Convenience method to create a Bolt instance with M27 diameter.\n\n        Args:\n            grade (str): Bolt steel grade (e.g., '8.8', '10.9'). Defaults to '8.8'.\n\n        Returns:\n            Bolt: A Bolt instance with M27 diameter and the specified grade.\n        \"\"\"\n        return Bolt(\"M27\", grade)\n\n    def M30(grade: str = \"8.8\") -&gt; \"Bolt\":\n        \"\"\"\n        Convenience method to create a Bolt instance with M30 diameter.\n\n        Args:\n            grade (str): Bolt steel grade (e.g., '8.8', '10.9'). Defaults to '8.8'.\n\n        Returns:\n            Bolt: A Bolt instance with M30 diameter and the specified grade.\n        \"\"\"\n        return Bolt(\"M30\", grade)\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.Bolt.M20","title":"<code>M20(grade='8.8')</code>  <code>staticmethod</code>","text":"<p>Convenience method to create a Bolt instance with M20 diameter.</p> <p>Parameters:</p> Name Type Description Default <code>grade</code> <code>str</code> <p>Bolt steel grade (e.g., '8.8', '10.9'). Defaults to '8.8'.</p> <code>'8.8'</code> <p>Returns:</p> Name Type Description <code>Bolt</code> <code>Bolt</code> <p>A Bolt instance with M20 diameter and the specified grade.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>@staticmethod\ndef M20(grade: str = \"8.8\") -&gt; \"Bolt\":\n    \"\"\"\n    Convenience method to create a Bolt instance with M20 diameter.\n\n    Args:\n        grade (str): Bolt steel grade (e.g., '8.8', '10.9'). Defaults to '8.8'.\n\n    Returns:\n        Bolt: A Bolt instance with M20 diameter and the specified grade.\n    \"\"\"\n    return Bolt(\"M20\", grade)\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.Bolt.M22","title":"<code>M22(grade='8.8')</code>  <code>staticmethod</code>","text":"<p>Convenience method to create a Bolt instance with M22 diameter.</p> <p>Parameters:</p> Name Type Description Default <code>grade</code> <code>str</code> <p>Bolt steel grade (e.g., '8.8', '10.9'). Defaults to '8.8'.</p> <code>'8.8'</code> <p>Returns:</p> Name Type Description <code>Bolt</code> <code>Bolt</code> <p>A Bolt instance with M22 diameter and the specified grade.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>@staticmethod\ndef M22(grade: str = \"8.8\") -&gt; \"Bolt\":\n    \"\"\"\n    Convenience method to create a Bolt instance with M22 diameter.\n\n    Args:\n        grade (str): Bolt steel grade (e.g., '8.8', '10.9'). Defaults to '8.8'.\n\n    Returns:\n        Bolt: A Bolt instance with M22 diameter and the specified grade.\n    \"\"\"\n    return Bolt(\"M22\", grade)\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.Bolt.M24","title":"<code>M24(grade='8.8')</code>  <code>staticmethod</code>","text":"<p>Convenience method to create a Bolt instance with M24 diameter.</p> <p>Parameters:</p> Name Type Description Default <code>grade</code> <code>str</code> <p>Bolt steel grade (e.g., '8.8', '10.9'). Defaults to '8.8'.</p> <code>'8.8'</code> <p>Returns:</p> Name Type Description <code>Bolt</code> <code>Bolt</code> <p>A Bolt instance with M24 diameter and the specified grade.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>@staticmethod\ndef M24(grade: str = \"8.8\") -&gt; \"Bolt\":\n    \"\"\"\n    Convenience method to create a Bolt instance with M24 diameter.\n\n    Args:\n        grade (str): Bolt steel grade (e.g., '8.8', '10.9'). Defaults to '8.8'.\n\n    Returns:\n        Bolt: A Bolt instance with M24 diameter and the specified grade.\n    \"\"\"\n    return Bolt(\"M24\", grade)\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.Bolt.M27","title":"<code>M27(grade='8.8')</code>  <code>staticmethod</code>","text":"<p>Convenience method to create a Bolt instance with M27 diameter.</p> <p>Parameters:</p> Name Type Description Default <code>grade</code> <code>str</code> <p>Bolt steel grade (e.g., '8.8', '10.9'). Defaults to '8.8'.</p> <code>'8.8'</code> <p>Returns:</p> Name Type Description <code>Bolt</code> <code>Bolt</code> <p>A Bolt instance with M27 diameter and the specified grade.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>@staticmethod\ndef M27(grade: str = \"8.8\") -&gt; \"Bolt\":\n    \"\"\"\n    Convenience method to create a Bolt instance with M27 diameter.\n\n    Args:\n        grade (str): Bolt steel grade (e.g., '8.8', '10.9'). Defaults to '8.8'.\n\n    Returns:\n        Bolt: A Bolt instance with M27 diameter and the specified grade.\n    \"\"\"\n    return Bolt(\"M27\", grade)\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.Bolt.M30","title":"<code>M30(grade='8.8')</code>","text":"<p>Convenience method to create a Bolt instance with M30 diameter.</p> <p>Parameters:</p> Name Type Description Default <code>grade</code> <code>str</code> <p>Bolt steel grade (e.g., '8.8', '10.9'). Defaults to '8.8'.</p> <code>'8.8'</code> <p>Returns:</p> Name Type Description <code>Bolt</code> <code>Bolt</code> <p>A Bolt instance with M30 diameter and the specified grade.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def M30(grade: str = \"8.8\") -&gt; \"Bolt\":\n    \"\"\"\n    Convenience method to create a Bolt instance with M30 diameter.\n\n    Args:\n        grade (str): Bolt steel grade (e.g., '8.8', '10.9'). Defaults to '8.8'.\n\n    Returns:\n        Bolt: A Bolt instance with M30 diameter and the specified grade.\n    \"\"\"\n    return Bolt(\"M30\", grade)\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.Bolt.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the Bolt instance.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string describing the bolt properties.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the Bolt instance.\n\n    Returns:\n        str: A string describing the bolt properties.\n\n    \"\"\"\n    return (\n        f\"Bolt Type: {self.name}\\n\"\n        f\"Bolt steel grade: {self.steel}\\n\"\n        f\"Characteristic Yield Strength (fyb): {self.fyb} MPa\\n\"\n        f\"Characteristic Ultimate Strength (fub): {self.fub} MPa\\n\"\n        f\"Diameter (d): {self.d} mm\\n\"\n        f\"Area of the bolt (A): {self.A} cm^2\\n\"\n        f\"Area of the thread (Athread): {self.Athread} cm^2\\n\"\n    )\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection","title":"<code>BoltedConnection</code>","text":"<p>Represents a bolted connection in a steel structure.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection--attributes","title":"Attributes","text":"<p>d0 : float     Hole diameter (d0 = d + 1) in mm. e1 : float     End distance (&gt;= 1.2d0) in mm. p1 : float     Spacing parallel to force (&gt;= 2.2d0) in mm. e2 : float     Edge distance (&gt;= 1.2d0) in mm. p2 : float     Spacing perpendicular to force (&gt;= 2.4d0) in mm. n1 : int     Number of bolts in parallel. n2 : int     Number of bolts in series. steel_plate : SteelPlate     Steel plate used in the connection. steel : ec.ec3.Steel     Steel grade of the connection. bolt : ec.ec3.Bolt     Bolt used in the connection.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>class BoltedConnection:\n    \"\"\"Represents a bolted connection in a steel structure.\n\n    Attributes\n    ----------\n    d0 : float\n        Hole diameter (d0 = d + 1) in mm.\n    e1 : float\n        End distance (&gt;= 1.2d0) in mm.\n    p1 : float\n        Spacing parallel to force (&gt;= 2.2d0) in mm.\n    e2 : float\n        Edge distance (&gt;= 1.2d0) in mm.\n    p2 : float\n        Spacing perpendicular to force (&gt;= 2.4d0) in mm.\n    n1 : int\n        Number of bolts in parallel.\n    n2 : int\n        Number of bolts in series.\n    steel_plate : SteelPlate\n        Steel plate used in the connection.\n    steel : ec.ec3.Steel\n        Steel grade of the connection.\n    bolt : ec.ec3.Bolt\n        Bolt used in the connection.\n\n    \"\"\"\n\n    _e1: float = 0.0  # end distance &gt;= 1.2d0\n    _p1: float = 0.0  # spacing parallel &gt;= 2.2d0\n    _e2: float = 0.0  # edge distance &gt;= 1.5d0\n    _p2: float = 0.0  # spacing perpendicular &gt;= 2.5d0\n    _n1: int = 1  # number of bolts in parallel\n    _n2: int = 1  # number of bolts in series\n\n    def __init__(self,\n            bolt: Bolt,\n            steel_plate: SteelPlate,\n            steel_plate_b: SteelPlate | object = None) -&gt; None:\n        \"\"\"Post-initialization to ensure the bolt is of type Bolt.\"\"\"\n        self._plate_a = steel_plate\n        self._plate_b = steel_plate_b if steel_plate_b is not None else steel_plate\n        self._bolt = bolt\n        self._e1 = REC_E1 * self.bolt.d0\n        self._p1 = REC_P2 * self.bolt.d0\n        self._e2 = REC_E2 * self.bolt.d0\n        self._p2 = REC_P2 * self.bolt.d0\n        self._result = None\n\n    @property\n    def steel(self) -&gt; Steel:\n        \"\"\"Returns the steel grade of the connection.\"\"\"\n        return self.steel_plate.steel\n\n    @property\n    def bolt(self) -&gt; Bolt:\n        \"\"\"Returns the bolt used in the connection.\"\"\"\n        return self._bolt\n\n    @property\n    def d0(self) -&gt; float:\n        \"\"\"Returns the hole diameter (d0 = d + 1) in mm.\"\"\"\n        return self.bolt.d0\n\n    @property\n    def e1(self) -&gt; float:\n        \"\"\"Returns the end distance (&gt;= 1.2d0) in mm.\"\"\"\n        return self._e1\n\n    @e1.setter\n    def e1(self, value: float) -&gt; None:\n        \"\"\"Set the end distance (&gt;= 1.2d0) in mm.\n\n        Raises\n        ------\n        ValueError\n            If the provided value is less than the minimum or exceeds the maximum allowed.\n\n        \"\"\"\n        if value &lt; MIN_E1 * self.d0:\n            msg = f\"End distance must be at least {MIN_E1} times the hole diameter ({self.d0}).\"\n            raise ValueError(msg)\n        t = min(self.steel_plate.thickness, self.steel_plate_b.thickness)\n        if value &gt; 4.0 * t + 40:\n            msg = f\"End distance must not exceed 4 times the plate thickness ({t}) plus 40 mm.\"\n            raise ValueError(msg)\n        self._e1 = value\n\n    @property\n    def p1(self) -&gt; float:\n        \"\"\"Returns the spacing parallel to force (&gt;= 2.2d0) in mm.\"\"\"\n        return self._p1\n\n    @p1.setter\n    def p1(self, value: float) -&gt; None:\n        \"\"\"Set the spacing parallel to force (&gt;= 2.2d0) in mm.\n\n        Raises\n        ------\n        ValueError\n            If the provided value is less than the minimum or exceeds the maximum allowed.\n\n        \"\"\"\n        if value &lt; MIN_P1 * self.d0:\n            msg = f\"Spacing parallel to force must be at least {MIN_P1} times the hole diameter ({self.d0}).\"\n            raise ValueError(msg)\n        t = min(self.steel_plate.thickness, self.steel_plate_b.thickness)\n        if value &gt; 14.0 * t or value &gt; 200:  # noqa: PLR2004\n            msg = (\n                f\"Spacing parallel to force must not exceed 14 \"\n                f\"times the plate thickness ({t}) or 200 mm.\"\n            )\n            raise ValueError(msg)\n        self._p1 = value\n\n    @property\n    def e2(self) -&gt; float:\n        \"\"\"Returns the edge distance (&gt;= 1.2d0) in mm.\"\"\"\n        return self._e2\n\n    @e2.setter\n    def e2(self, value: float) -&gt; None:\n        \"\"\"Set the edge distance (&gt;= 1.2d0) in mm.\n\n        Raises\n        ------\n        ValueError\n            If the provided value is less than the minimum or exceeds the maximum allowed.\n\n        \"\"\"\n        if value &lt; MIN_E2 * self.d0:\n            msg = f\"Edge distance must be at least {MIN_E2} times the hole diameter ({self.d0}).\"\n            raise ValueError(msg)\n        t = min(self.steel_plate.thickness, self.steel_plate_b.thickness)\n        if value &gt; 4.0 * t + 40:\n            msg = f\"Edge distance must not exceed 4 times the plate thickness ({t}) plus 40 mm.\"\n            raise ValueError(msg)\n        self._e2 = value\n\n    @property\n    def p2(self) -&gt; float:\n        \"\"\"Returns the spacing perpendicular to force (&gt;= 2.5d0) in mm.\"\"\"\n        return self._p2\n\n    @p2.setter\n    def p2(self, value: float) -&gt; None:\n        \"\"\"Set the spacing perpendicular to force (&gt;= 2.5d0) in mm.\n\n        Raises\n        ------\n        ValueError\n            If the provided value is less than the minimum or exceeds the maximum allowed.\n\n        \"\"\"\n        if value &lt; MIN_P2 * self.d0:\n            msg = f\"Spacing perpendicular to force must be at least {MIN_P2} times the hole diameter ({self.d0}).\"\n            raise ValueError(msg)\n        t = min(self.steel_plate.thickness, self.steel_plate_b.thickness)\n        if value &gt; 14.0 * t or value &gt; 200:  # noqa: PLR2004\n            msg = (\n                f\"Spacing perpendicular to force must not exceed 14 \"\n                f\"times the plate thickness ({t}) or 200 mm.\"\n            )\n            raise ValueError(msg)\n        self._p2 = value\n\n    @property\n    def steel_plate(self) -&gt; SteelPlate:\n        \"\"\"Returns the steel plate used in the connection.\"\"\"\n        return self._plate_a\n\n    @property\n    def steel_plate_b(self) -&gt; SteelPlate:\n        \"\"\"Returns the second steel plate used in the connection.\"\"\"\n        return self._plate_b\n\n    @property\n    def n1(self) -&gt; int:\n        \"\"\"Returns the number of bolts in parallel.\"\"\"\n        return self._n1\n\n    @n1.setter\n    def n1(self, value: int) -&gt; None:\n        \"\"\"Set the number of bolts in parallel.\"\"\"  # noqa: DOC501\n        if value &lt; 1:\n            msg = \"Number of bolts in parallel must be at least 1.\"\n            raise ValueError(msg)\n        self._n1 = value\n\n    @property\n    def n2(self) -&gt; int:\n        \"\"\"Returns the number of bolts in series.\"\"\"\n        return self._n2\n\n    @n2.setter\n    def n2(self, value: int) -&gt; None:\n        \"\"\"Set the number of bolts in series.\"\"\"  # noqa: DOC501\n        if value &lt; 1:\n            msg = \"Number of bolts in series must be at least 1.\"\n            raise ValueError(msg)\n        self._n2 = value\n\n    @steel_plate.setter\n    def steel_plate(self, value: SteelPlate) -&gt; None:\n        \"\"\"Set the steel plate used in the connection.\"\"\"\n        self._plate_a = value\n\n    @steel_plate_b.setter\n    def steel_plate_b(self, value: SteelPlate) -&gt; None:\n        \"\"\"Set the steel plate used in the connection.\"\"\"\n        self._plate_b = value\n\n    def Fv_Rd(self, threaded: bool = True) -&gt; float:\n        \"\"\"Return shear strength.\n\n        Args:\n            threaded (bool, optional): Shear occurs in threaded part. Defaults to True.\n\n        Returns:\n            float: shear strength\n\n        \"\"\"\n        if threaded:\n            alpha_v = 0.5 if self.bolt.steel in {\"4.6\", \"5.6\", \"6.4\"} else 0.6\n            area = self.bolt.Athread\n        else:\n            alpha_v = 0.6\n            area = self.bolt.A\n        return np.round(alpha_v * self.bolt.fub * area / self.bolt.gamma_M2 / 10.0, 2)\n\n    def Fb_Rd(self) -&gt; float:  # noqa: N802\n        \"\"\"Return bearing strength.\n\n        Args:\n            thread (bool, optional): Shear occurs in thread. Defaults to True.\n\n        Returns:\n            float: bearing strength\n\n        \"\"\"\n        t = min(self.steel_plate.thickness, self.steel_plate_b.thickness)\n        fu = self.steel_plate.steel.fuk\n\n        ad = min(self.e1 / (3 * self.d0), self.p1 / (3 * self.d0) - 1.0 / 4.0)\n        k1 = min(2.8 * self.e2 / self.d0 - 1.7, 1.4 * self.p2 / self.d0 - 1.7, 2.5)\n        ab = min(ad, self.bolt.fub / fu, 1.0)\n\n        return np.round(k1 * ab * fu * self.bolt.d * t / self.bolt.gamma_M2 / 1000.0, 2)\n\n    def Ft_Rd(self, countersunk: bool = False) -&gt; float:  # noqa: FBT001, FBT002, N802, PLR6301\n        \"\"\"Return tensile strength.\n\n        Args:\n            countersunk (bool, optional): Countersunk bolts. Defaults to False.\n\n        Returns:\n            float: tensile strength\n\n        \"\"\"\n        k2 = 0.6 if countersunk else 0.9\n        return np.round(k2 * self.bolt.fub * self.bolt.Athread / self.bolt.gamma_M2 / 10.0, 2)\n\n    def Bp_Rd(self) -&gt; float:\n        \"\"\"Return punching strength of the bolt.\n\n        Returns:\n            float: punching strength of the plate\n\n        \"\"\"\n        t = min(self.steel_plate.thickness, self.steel_plate_b.thickness)\n        return np.round(0.6 * np.pi * self.bolt.dnut * self.steel_plate.steel.fuk *\n                    t / self.bolt.gamma_M2 / 10.0, 2)\n\n    def check(self, Fv_Ed: np.ndarray, Ft_Ed: np.ndarray,  # noqa: N803\n                threaded: bool = True, countersunk: bool = False) -&gt; dict:  # noqa: FBT001, FBT002\n        \"\"\"Perform design checks for the bolted connection.\n\n        Parameters\n        ----------\n        Fv_Ed : np.ndarray\n            Array of applied shear forces.\n        Ft_Ed : np.ndarray\n            Array of applied tensile forces.\n        threaded : bool, optional\n            Whether shear occurs in the threaded part of the bolt (default is True).\n        countersunk : bool, optional\n            Whether the bolts are countersunk (default is False).\n\n        Returns\n        -------\n        dict\n            Dictionary containing the results of the design checks.\n\n        \"\"\"\n        self.Fv_Ed = Fv_Ed\n        self.Fb_Ed = Fv_Ed\n        self.Ft_Ed = Ft_Ed\n        shear_ratio = np.round(self.Fv_Ed / self.Fv_Rd(), 2)\n        shear_check = np.all(shear_ratio &lt;= 1)\n        bearing_ratio = np.round(self.Fv_Ed / self.Fb_Rd(), 2)\n        bearing_check = np.all(bearing_ratio &lt;= 1)\n        tensile_ratio = np.round(self.Ft_Ed / self.Ft_Rd(), 2)\n        tensile_check = np.all(tensile_ratio &lt;= 1)\n        punching_ratio = np.round(self.Ft_Ed / self.Bp_Rd(), 2)\n        punching_check = np.all(punching_ratio &lt;= 1)\n        combined_ratio = np.round(self.Fv_Ed / self.Fv_Rd() + self.Ft_Ed / 1.4 / self.Ft_Rd(), 2)\n        combined_check = np.all(combined_ratio &lt;= 1)\n\n        self._result = {\n            \"ShearRatios\": shear_ratio,\n            \"ShearRatio\": np.max(shear_ratio),\n            \"ShearCheck\": shear_check,\n            \"BearingRatios\": bearing_ratio,\n            \"BearingRatio\": np.max(bearing_ratio),\n            \"BearingCheck\": bearing_check,\n            \"TensileRatios\": tensile_ratio,\n            \"TensileRatio\": np.max(tensile_ratio),\n            \"TensileCheck\": tensile_check,\n            \"PunchingRatios\": punching_ratio,\n            \"PunchingRatio\": np.max(punching_ratio),\n            \"PunchingCheck\": punching_check,\n            \"CombinedRatios\": combined_ratio,\n            \"CombinedRatio\": np.max(combined_ratio),\n            \"CombinedCheck\": combined_check,\n            \"Check\": shear_check &amp; bearing_check &amp; tensile_check &amp; combined_check,\n        }\n\n        return self._result\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the bolted connection.\n\n        Returns:\n            str: String representation of the bolted connection.\n\n        \"\"\"\n        s: str = (\n            f\"\\nBOLTED CONNECTION\\n\"\n            f\"\\nGeometry and materials: mm\\n\"\n            f\"End distance e1: {self.e1} mm\\n\"\n            f\"Spacing parallel p1: {self.p1} mm\\n\"\n            f\"Edge distance e2: {self.e2} mm\\n\"\n            f\"Spacing perpendicular p2: {self.p2} mm\\n\"\n            f\"Number of bolts in parallel n1: {self.n1}\\n\"\n            f\"Number of bolts in series n2: {self.n2}\\n\"\n            f\"Bolt diameter: {self.bolt.d} mm\\n\"\n            f\"Bolt grade: {self.bolt.fub}\\n\"\n            f\"Bolt area: {self.bolt.A} cm^2\\n\"\n            f\"Bolt area thread: {self.bolt.Athread} cm^2\\n\"\n            f\"Bolt hole diameter: {self.bolt.d0} mm\\n\"\n            f\"Bolt nut 'diameter': {self.bolt.dnut} mm\\n\"\n            f\"Steel plate A thickness: {self.steel_plate.thickness} mm\\n\"\n            f\"Steel plate A grade: {self.steel_plate.steel.ClassType}\\n\"\n            f\"Steel plate B thickness: {self.steel_plate_b.thickness} mm\\n\"\n            f\"Steel plate B grade: {self.steel_plate_b.steel.ClassType}\\n\"\n            f\"\\nGeometry and materials:\\n\"\n            f\"Shear strength: {self.Fv_Rd(threaded=True)} kN\\n\"\n            f\"Bearing strength: {self.Fb_Rd()} kN\\n\"\n            f\"Tensile strength: {self.Ft_Rd()} kN\\n\"\n            f\"Punching strength: {self.Bp_Rd()} kN\\n\"\n            f\"\\nDesign checks:\\n\"\n        )\n\n        if self._result is not None:\n            t: str = (\n            f\"Shear ratios: {self._result['ShearRatios']}\\n\"\n            f\"Bearing ratios: {self._result['BearingRatios']}\\n\"\n            f\"Tensile ratios: {self._result['TensileRatios']}\\n\"\n            f\"Punching ratios: {self._result['PunchingRatios']}\\n\"\n            f\"Combined ratios: {self._result['CombinedRatios']}\\n\"\n            f\"Shear ratio: {self._result['ShearRatio']}\\n\"\n            f\"Bearing ratio: {self._result['BearingRatio']}\\n\"\n            f\"Tensile ratio: {self._result['TensileRatio']}\\n\"\n            f\"Punching ratio: {self._result['PunchingRatio']}\\n\"\n            f\"Combined ratio: {self._result['CombinedRatio']}\\n\"\n            f\"Shear check: {self._result['ShearCheck']}\\n\"\n            f\"Bearing check: {self._result['BearingCheck']}\\n\"\n            f\"Tensile check: {self._result['TensileCheck']}\\n\"\n            f\"Punching check: {self._result['PunchingCheck']}\\n\"\n            f\"Combined check: {self._result['CombinedCheck']}\\n\"\n            f\"Check: {self._result['Check']}\")\n        else:\n            t: str = \"WARNING: No results available. Run 'Check' method first.\"\n\n        return s + t\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection.bolt","title":"<code>bolt</code>  <code>property</code>","text":"<p>Returns the bolt used in the connection.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection.d0","title":"<code>d0</code>  <code>property</code>","text":"<p>Returns the hole diameter (d0 = d + 1) in mm.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection.e1","title":"<code>e1</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the end distance (&gt;= 1.2d0) in mm.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection.e2","title":"<code>e2</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the edge distance (&gt;= 1.2d0) in mm.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection.n1","title":"<code>n1</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the number of bolts in parallel.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection.n2","title":"<code>n2</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the number of bolts in series.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection.p1","title":"<code>p1</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the spacing parallel to force (&gt;= 2.2d0) in mm.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection.p2","title":"<code>p2</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the spacing perpendicular to force (&gt;= 2.5d0) in mm.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection.steel","title":"<code>steel</code>  <code>property</code>","text":"<p>Returns the steel grade of the connection.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection.steel_plate","title":"<code>steel_plate</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the steel plate used in the connection.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection.steel_plate_b","title":"<code>steel_plate_b</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the second steel plate used in the connection.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection.Bp_Rd","title":"<code>Bp_Rd()</code>","text":"<p>Return punching strength of the bolt.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>punching strength of the plate</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def Bp_Rd(self) -&gt; float:\n    \"\"\"Return punching strength of the bolt.\n\n    Returns:\n        float: punching strength of the plate\n\n    \"\"\"\n    t = min(self.steel_plate.thickness, self.steel_plate_b.thickness)\n    return np.round(0.6 * np.pi * self.bolt.dnut * self.steel_plate.steel.fuk *\n                t / self.bolt.gamma_M2 / 10.0, 2)\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection.Fb_Rd","title":"<code>Fb_Rd()</code>","text":"<p>Return bearing strength.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>bool</code> <p>Shear occurs in thread. Defaults to True.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>bearing strength</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def Fb_Rd(self) -&gt; float:  # noqa: N802\n    \"\"\"Return bearing strength.\n\n    Args:\n        thread (bool, optional): Shear occurs in thread. Defaults to True.\n\n    Returns:\n        float: bearing strength\n\n    \"\"\"\n    t = min(self.steel_plate.thickness, self.steel_plate_b.thickness)\n    fu = self.steel_plate.steel.fuk\n\n    ad = min(self.e1 / (3 * self.d0), self.p1 / (3 * self.d0) - 1.0 / 4.0)\n    k1 = min(2.8 * self.e2 / self.d0 - 1.7, 1.4 * self.p2 / self.d0 - 1.7, 2.5)\n    ab = min(ad, self.bolt.fub / fu, 1.0)\n\n    return np.round(k1 * ab * fu * self.bolt.d * t / self.bolt.gamma_M2 / 1000.0, 2)\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection.Ft_Rd","title":"<code>Ft_Rd(countersunk=False)</code>","text":"<p>Return tensile strength.</p> <p>Parameters:</p> Name Type Description Default <code>countersunk</code> <code>bool</code> <p>Countersunk bolts. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>tensile strength</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def Ft_Rd(self, countersunk: bool = False) -&gt; float:  # noqa: FBT001, FBT002, N802, PLR6301\n    \"\"\"Return tensile strength.\n\n    Args:\n        countersunk (bool, optional): Countersunk bolts. Defaults to False.\n\n    Returns:\n        float: tensile strength\n\n    \"\"\"\n    k2 = 0.6 if countersunk else 0.9\n    return np.round(k2 * self.bolt.fub * self.bolt.Athread / self.bolt.gamma_M2 / 10.0, 2)\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection.Fv_Rd","title":"<code>Fv_Rd(threaded=True)</code>","text":"<p>Return shear strength.</p> <p>Parameters:</p> Name Type Description Default <code>threaded</code> <code>bool</code> <p>Shear occurs in threaded part. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>shear strength</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def Fv_Rd(self, threaded: bool = True) -&gt; float:\n    \"\"\"Return shear strength.\n\n    Args:\n        threaded (bool, optional): Shear occurs in threaded part. Defaults to True.\n\n    Returns:\n        float: shear strength\n\n    \"\"\"\n    if threaded:\n        alpha_v = 0.5 if self.bolt.steel in {\"4.6\", \"5.6\", \"6.4\"} else 0.6\n        area = self.bolt.Athread\n    else:\n        alpha_v = 0.6\n        area = self.bolt.A\n    return np.round(alpha_v * self.bolt.fub * area / self.bolt.gamma_M2 / 10.0, 2)\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection.__init__","title":"<code>__init__(bolt, steel_plate, steel_plate_b=None)</code>","text":"<p>Post-initialization to ensure the bolt is of type Bolt.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def __init__(self,\n        bolt: Bolt,\n        steel_plate: SteelPlate,\n        steel_plate_b: SteelPlate | object = None) -&gt; None:\n    \"\"\"Post-initialization to ensure the bolt is of type Bolt.\"\"\"\n    self._plate_a = steel_plate\n    self._plate_b = steel_plate_b if steel_plate_b is not None else steel_plate\n    self._bolt = bolt\n    self._e1 = REC_E1 * self.bolt.d0\n    self._p1 = REC_P2 * self.bolt.d0\n    self._e2 = REC_E2 * self.bolt.d0\n    self._p2 = REC_P2 * self.bolt.d0\n    self._result = None\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the bolted connection.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of the bolted connection.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the bolted connection.\n\n    Returns:\n        str: String representation of the bolted connection.\n\n    \"\"\"\n    s: str = (\n        f\"\\nBOLTED CONNECTION\\n\"\n        f\"\\nGeometry and materials: mm\\n\"\n        f\"End distance e1: {self.e1} mm\\n\"\n        f\"Spacing parallel p1: {self.p1} mm\\n\"\n        f\"Edge distance e2: {self.e2} mm\\n\"\n        f\"Spacing perpendicular p2: {self.p2} mm\\n\"\n        f\"Number of bolts in parallel n1: {self.n1}\\n\"\n        f\"Number of bolts in series n2: {self.n2}\\n\"\n        f\"Bolt diameter: {self.bolt.d} mm\\n\"\n        f\"Bolt grade: {self.bolt.fub}\\n\"\n        f\"Bolt area: {self.bolt.A} cm^2\\n\"\n        f\"Bolt area thread: {self.bolt.Athread} cm^2\\n\"\n        f\"Bolt hole diameter: {self.bolt.d0} mm\\n\"\n        f\"Bolt nut 'diameter': {self.bolt.dnut} mm\\n\"\n        f\"Steel plate A thickness: {self.steel_plate.thickness} mm\\n\"\n        f\"Steel plate A grade: {self.steel_plate.steel.ClassType}\\n\"\n        f\"Steel plate B thickness: {self.steel_plate_b.thickness} mm\\n\"\n        f\"Steel plate B grade: {self.steel_plate_b.steel.ClassType}\\n\"\n        f\"\\nGeometry and materials:\\n\"\n        f\"Shear strength: {self.Fv_Rd(threaded=True)} kN\\n\"\n        f\"Bearing strength: {self.Fb_Rd()} kN\\n\"\n        f\"Tensile strength: {self.Ft_Rd()} kN\\n\"\n        f\"Punching strength: {self.Bp_Rd()} kN\\n\"\n        f\"\\nDesign checks:\\n\"\n    )\n\n    if self._result is not None:\n        t: str = (\n        f\"Shear ratios: {self._result['ShearRatios']}\\n\"\n        f\"Bearing ratios: {self._result['BearingRatios']}\\n\"\n        f\"Tensile ratios: {self._result['TensileRatios']}\\n\"\n        f\"Punching ratios: {self._result['PunchingRatios']}\\n\"\n        f\"Combined ratios: {self._result['CombinedRatios']}\\n\"\n        f\"Shear ratio: {self._result['ShearRatio']}\\n\"\n        f\"Bearing ratio: {self._result['BearingRatio']}\\n\"\n        f\"Tensile ratio: {self._result['TensileRatio']}\\n\"\n        f\"Punching ratio: {self._result['PunchingRatio']}\\n\"\n        f\"Combined ratio: {self._result['CombinedRatio']}\\n\"\n        f\"Shear check: {self._result['ShearCheck']}\\n\"\n        f\"Bearing check: {self._result['BearingCheck']}\\n\"\n        f\"Tensile check: {self._result['TensileCheck']}\\n\"\n        f\"Punching check: {self._result['PunchingCheck']}\\n\"\n        f\"Combined check: {self._result['CombinedCheck']}\\n\"\n        f\"Check: {self._result['Check']}\")\n    else:\n        t: str = \"WARNING: No results available. Run 'Check' method first.\"\n\n    return s + t\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection.check","title":"<code>check(Fv_Ed, Ft_Ed, threaded=True, countersunk=False)</code>","text":"<p>Perform design checks for the bolted connection.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection.check--parameters","title":"Parameters","text":"<p>Fv_Ed : np.ndarray     Array of applied shear forces. Ft_Ed : np.ndarray     Array of applied tensile forces. threaded : bool, optional     Whether shear occurs in the threaded part of the bolt (default is True). countersunk : bool, optional     Whether the bolts are countersunk (default is False).</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.BoltedConnection.check--returns","title":"Returns","text":"<p>dict     Dictionary containing the results of the design checks.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def check(self, Fv_Ed: np.ndarray, Ft_Ed: np.ndarray,  # noqa: N803\n            threaded: bool = True, countersunk: bool = False) -&gt; dict:  # noqa: FBT001, FBT002\n    \"\"\"Perform design checks for the bolted connection.\n\n    Parameters\n    ----------\n    Fv_Ed : np.ndarray\n        Array of applied shear forces.\n    Ft_Ed : np.ndarray\n        Array of applied tensile forces.\n    threaded : bool, optional\n        Whether shear occurs in the threaded part of the bolt (default is True).\n    countersunk : bool, optional\n        Whether the bolts are countersunk (default is False).\n\n    Returns\n    -------\n    dict\n        Dictionary containing the results of the design checks.\n\n    \"\"\"\n    self.Fv_Ed = Fv_Ed\n    self.Fb_Ed = Fv_Ed\n    self.Ft_Ed = Ft_Ed\n    shear_ratio = np.round(self.Fv_Ed / self.Fv_Rd(), 2)\n    shear_check = np.all(shear_ratio &lt;= 1)\n    bearing_ratio = np.round(self.Fv_Ed / self.Fb_Rd(), 2)\n    bearing_check = np.all(bearing_ratio &lt;= 1)\n    tensile_ratio = np.round(self.Ft_Ed / self.Ft_Rd(), 2)\n    tensile_check = np.all(tensile_ratio &lt;= 1)\n    punching_ratio = np.round(self.Ft_Ed / self.Bp_Rd(), 2)\n    punching_check = np.all(punching_ratio &lt;= 1)\n    combined_ratio = np.round(self.Fv_Ed / self.Fv_Rd() + self.Ft_Ed / 1.4 / self.Ft_Rd(), 2)\n    combined_check = np.all(combined_ratio &lt;= 1)\n\n    self._result = {\n        \"ShearRatios\": shear_ratio,\n        \"ShearRatio\": np.max(shear_ratio),\n        \"ShearCheck\": shear_check,\n        \"BearingRatios\": bearing_ratio,\n        \"BearingRatio\": np.max(bearing_ratio),\n        \"BearingCheck\": bearing_check,\n        \"TensileRatios\": tensile_ratio,\n        \"TensileRatio\": np.max(tensile_ratio),\n        \"TensileCheck\": tensile_check,\n        \"PunchingRatios\": punching_ratio,\n        \"PunchingRatio\": np.max(punching_ratio),\n        \"PunchingCheck\": punching_check,\n        \"CombinedRatios\": combined_ratio,\n        \"CombinedRatio\": np.max(combined_ratio),\n        \"CombinedCheck\": combined_check,\n        \"Check\": shear_check &amp; bearing_check &amp; tensile_check &amp; combined_check,\n    }\n\n    return self._result\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.PinnedConnection","title":"<code>PinnedConnection</code>","text":"<p>               Bases: <code>BoltedConnection</code></p> <p>Represents a pinned connection in a steel structure.</p> <p>Inherits from BoltedConnection and uses the same properties and methods. Plate A are the outer plates, plate B are the inner plate.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>class PinnedConnection(BoltedConnection):\n    \"\"\"Represents a pinned connection in a steel structure.\n\n    Inherits from BoltedConnection and uses the same properties and methods.\n    Plate A are the outer plates, plate B are the inner plate.\n\n    \"\"\"\n\n    _g: float = 0.0  # gap between plates in mm\n    _pin_type: str = \"simple\"\n\n    def __init__(self,\n            bolt: Bolt,\n            steel_plate: SteelPlate,\n            steel_plate_b: SteelPlate | object = None,\n            gap: float = 0) -&gt; None:\n        \"\"\"Post-initialization to ensure the bolt is of type Bolt.\"\"\"\n        super().__init__(bolt, steel_plate, steel_plate_b)\n        self._g = gap  # default gap\n        self._p1 = 0.0\n        self._p2 = 0.0\n        self._e1 = MIN_E1_PIN * self.bolt.d0\n        self._e2 = MIN_E2_PIN * self.bolt.d0\n\n    @property\n    def g(self) -&gt; float:\n        \"\"\"Returns the gap between plates in mm.\"\"\"\n        return self._g\n\n    @g.setter\n    def g(self, value: float) -&gt; None:\n        \"\"\"Set the gap between plates in mm.\"\"\"  # noqa: DOC501\n        if value &lt; 0:\n            msg = \"Gap between plates must be &gt;= 0.\"\n            raise ValueError(msg)\n        self._g = value\n\n    def Fv_Rd(self) -&gt; float:\n        \"\"\"Return shear strength.\n\n        Args:\n            threaded (bool, optional): Shear occurs in threaded part. Defaults to True.\n\n        Returns:\n            float: shear strength\n\n        \"\"\"\n        self._Fv_Rd = np.round(0.6 * self.bolt.fub * self.bolt.A / self.bolt.gamma_M2 / 10.0, 2)\n        return self._Fv_Rd\n\n    def Fb_Rd(self) -&gt; tuple:  # noqa: N802\n        \"\"\"Return bearing strength.\n\n        Args:\n            thread (bool, optional): Shear occurs in thread. Defaults to True.\n\n        Returns:\n            float: 0.0\n\n        \"\"\"\n        fy: float = min(self.steel_plate.steel.fyk, self.bolt.fyb)\n        self._Fb_Rd_A = 1.5 * self.steel_plate.thickness * self.bolt.d * fy / self.bolt.gamma_M0 / 1000.0\n        fy: float = min(self.steel_plate_b.steel.fyk, self.bolt.fyb)\n        self._Fb_Rd_B = 1.5 * self.steel_plate_b.thickness * self.bolt.d * fy / self.bolt.gamma_M0 / 1000.0\n        return (self._Fb_Rd_A, self._Fb_Rd_B)\n\n    def M_Rd(self) -&gt; float:\n        \"\"\"Return the moment resistant of the pin.\n\n        Returns:\n            float: resitant moment\n\n        \"\"\"\n        w_ell = (self.bolt.d / 1000.0)**3 * np.pi / 32.0\n        self._M_Rd = np.round(1.5 * self.bolt.fyb * 1000.0 * w_ell / self.bolt.gamma_M0, 2)\n        return self._M_Rd\n\n    def Ft_Rd(self) -&gt; float:\n        \"\"\"Return tensile strength of the pin (0.0).\n\n        Returns:\n            float: 0.0\n\n        \"\"\"\n        return 0.0\n\n    def Bp_Rd(self) -&gt; float:\n        \"\"\"Return punching strength of the pin (0.0).\n\n        Returns:\n            float: 0.0\n\n        \"\"\"\n        return 0.0\n\n    def check(self, F_Ed: np.ndarray) -&gt; dict:  # noqa: N803\n        \"\"\"Check the design of the pinned connection.\n\n        Returns:\n            dict: Result of the design checks.\n\n        \"\"\"\n        # Calculate design forces\n        self.Fv_Ed = F_Ed / 2.0\n        self.Fb_Ed_A = F_Ed / 2.0\n        self.Fb_Ed_B = F_Ed\n        self.M_Ed = F_Ed * (\n            2.0 * self.steel_plate.thickness +\n            self.steel_plate_b.thickness +\n            4.0 * self.g\n        ) / 8.0 / 1000.0\n        # Perform checks on geometry\n        t = min(self.steel_plate.thickness, self.steel_plate_b.thickness)\n        fy = min(self.steel_plate.steel.fyk, self.bolt.fyb)\n        e1_lim = F_Ed / 2.0 / t * self.bolt.gamma_M0 / fy + 7.0 * self.bolt.d0 / 6.0\n        self._e1 = e1_lim\n        e2_lim = F_Ed / 2.0 / t * self.bolt.gamma_M0 / fy + 5.0 * self.bolt.d0 / 6.0\n        self._e2 = e2_lim\n        # Perform checks on stresses\n        shear_ratio = np.round(self.Fv_Ed / self.Fv_Rd(), 2)\n        shear_check = np.all(shear_ratio &lt; 1)\n        moment_ratio = np.round(self.M_Ed / self.M_Rd(), 2)\n        moment_check = np.all(moment_ratio &lt;= 1)\n        self.Fb_Rd()\n        bearing_ratio_a = np.round(self.Fb_Ed_A / self._Fb_Rd_A, 2)\n        bearing_check_a = np.all(bearing_ratio_a &lt;= 1)\n        bearing_ratio_b = np.round(self.Fb_Ed_B / self._Fb_Rd_B, 2)\n        bearing_check_b = np.all(bearing_ratio_b &lt;= 1)\n        combined_ratio = np.round(\n            (self.Fv_Ed / self._Fv_Rd)**2 + (self.M_Ed / self._M_Rd)**2, 2)\n        combined_check = np.all(combined_ratio &lt;= 1)\n\n        self._result = {\n            \"ShearRatios\": shear_ratio,\n            \"ShearRatio\": np.max(shear_ratio),\n            \"ShearCheck\": shear_check,\n            \"MomentRatios\": moment_ratio,\n            \"MomentRatio\": np.max(moment_ratio),\n            \"MomentCheck\": moment_check,\n            \"BearingRatiosA\": bearing_ratio_a,\n            \"BearingRatioA\": np.max(bearing_ratio_a),\n            \"BearingCheckA\": bearing_check_a,\n            \"BearingRatiosB\": bearing_ratio_b,\n            \"BearingRatioB\": np.max(bearing_ratio_b),\n            \"BearingCheckB\": bearing_check_b,\n            \"CombinedRatios\": combined_ratio,\n            \"CombinedRatio\": np.max(combined_ratio),\n            \"CombinedCheck\": combined_check,\n            \"Check\": shear_check &amp; bearing_check_a &amp; bearing_check_b &amp; combined_check,\n        }\n\n        return self._result\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the bolted connection.\n\n        Returns:\n            str: String representation of the bolted connection.\n\n        \"\"\"\n\n        base_text: str = (\n                \"\\nPINNED CONNECTION (simple)\\n\"\n                \"Pinned connection with one central element and two side elements.\\n\"\n            ) if self._pin_type == \"simple\" else (\n                \"\\nPINNED CONNECTION (double)\\n\"\n                \"Pinned connection with two central elements and two side elements.\\n\"\n            )\n\n        geom_text: str = (\n            f\"\\nGeometry and materials:\\n\"\n            f\"End distance e1: {self.e1}\\n\"\n            f\"Edge distance e2: {self.e2}\\n\"\n            # f\"Number of bolts in parallel n1: {self.n1}\\n\"\n            # f\"Number of bolts in series n2: {self.n2}\\n\"\n            f\"Pin diameter: {self.bolt.d} mm\\n\"\n            f\"Pin grade: {self.bolt.steel}\\n\"\n            f\"Pin area: {self.bolt.A:.2f} cm^2\\n\"\n            f\"Pin hole diameter: {self.bolt.d0} mm\\n\"\n            f\"Steel plate A thickness: {self.steel_plate.thickness} mm\\n\"\n            f\"Steel plate A grade: {self.steel_plate.steel.ClassType}\\n\"\n            f\"Steel plate B thickness: {self.steel_plate_b.thickness} mm\\n\"\n            f\"Steel plate B grade: {self.steel_plate_b.steel.ClassType}\\n\"\n            f\"\\nStrength:\\n\"\n            f\"Shear strength: {self._Fv_Rd} kN\\n\"\n            f\"Moment strength: {self._M_Rd} kNm\\n\"\n            f\"Bearing strength (side): {self._Fb_Rd_A} kN\\n\"\n            f\"Bearing strength (centre): {self._Fb_Rd_B} kN\\n\"\n            f\"\\nDesign checks:\\n\"\n        )\n\n        if self._result is not None:\n            check_text: str = (\n            f\"Shear ratios: {self._result['ShearRatios']}\\n\"\n            f\"Moment ratios: {self._result['MomentRatios']}\\n\"\n            f\"Bearing ratios (side): {self._result['BearingRatiosA']}\\n\"\n            f\"Bearing ratios (centre): {self._result['BearingRatiosB']}\\n\"\n            f\"Combined ratios: {self._result['CombinedRatios']}\\n\"\n            f\"Shear ratio: {self._result['ShearRatio']}\\n\"\n            f\"Moment ratio: {self._result['MomentRatio']}\\n\"\n            f\"Bearing ratio (side): {self._result['BearingRatioA']}\\n\"\n            f\"Bearing ratio (centre): {self._result['BearingRatioB']}\\n\"\n            f\"Combined ratio: {self._result['CombinedRatio']}\\n\"\n            f\"Shear check: {self._result['ShearCheck']}\\n\"\n            f\"Moment check: {self._result['MomentCheck']}\\n\"\n            f\"Bearing check (side): {self._result['BearingCheckA']}\\n\"\n            f\"Bearing check (centre): {self._result['BearingCheckB']}\\n\"\n            f\"Combined check: {self._result['CombinedCheck']}\\n\"\n            f\"Check: {self._result['Check']}\")\n        else:\n            check_text: str  = \"WARNING: No results available. Run 'check' method first.\"\n\n        return base_text + geom_text + check_text\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.PinnedConnection.g","title":"<code>g</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the gap between plates in mm.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.PinnedConnection.Bp_Rd","title":"<code>Bp_Rd()</code>","text":"<p>Return punching strength of the pin (0.0).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>0.0</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def Bp_Rd(self) -&gt; float:\n    \"\"\"Return punching strength of the pin (0.0).\n\n    Returns:\n        float: 0.0\n\n    \"\"\"\n    return 0.0\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.PinnedConnection.Fb_Rd","title":"<code>Fb_Rd()</code>","text":"<p>Return bearing strength.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>bool</code> <p>Shear occurs in thread. Defaults to True.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>tuple</code> <p>0.0</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def Fb_Rd(self) -&gt; tuple:  # noqa: N802\n    \"\"\"Return bearing strength.\n\n    Args:\n        thread (bool, optional): Shear occurs in thread. Defaults to True.\n\n    Returns:\n        float: 0.0\n\n    \"\"\"\n    fy: float = min(self.steel_plate.steel.fyk, self.bolt.fyb)\n    self._Fb_Rd_A = 1.5 * self.steel_plate.thickness * self.bolt.d * fy / self.bolt.gamma_M0 / 1000.0\n    fy: float = min(self.steel_plate_b.steel.fyk, self.bolt.fyb)\n    self._Fb_Rd_B = 1.5 * self.steel_plate_b.thickness * self.bolt.d * fy / self.bolt.gamma_M0 / 1000.0\n    return (self._Fb_Rd_A, self._Fb_Rd_B)\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.PinnedConnection.Ft_Rd","title":"<code>Ft_Rd()</code>","text":"<p>Return tensile strength of the pin (0.0).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>0.0</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def Ft_Rd(self) -&gt; float:\n    \"\"\"Return tensile strength of the pin (0.0).\n\n    Returns:\n        float: 0.0\n\n    \"\"\"\n    return 0.0\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.PinnedConnection.Fv_Rd","title":"<code>Fv_Rd()</code>","text":"<p>Return shear strength.</p> <p>Parameters:</p> Name Type Description Default <code>threaded</code> <code>bool</code> <p>Shear occurs in threaded part. Defaults to True.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>shear strength</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def Fv_Rd(self) -&gt; float:\n    \"\"\"Return shear strength.\n\n    Args:\n        threaded (bool, optional): Shear occurs in threaded part. Defaults to True.\n\n    Returns:\n        float: shear strength\n\n    \"\"\"\n    self._Fv_Rd = np.round(0.6 * self.bolt.fub * self.bolt.A / self.bolt.gamma_M2 / 10.0, 2)\n    return self._Fv_Rd\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.PinnedConnection.M_Rd","title":"<code>M_Rd()</code>","text":"<p>Return the moment resistant of the pin.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>resitant moment</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def M_Rd(self) -&gt; float:\n    \"\"\"Return the moment resistant of the pin.\n\n    Returns:\n        float: resitant moment\n\n    \"\"\"\n    w_ell = (self.bolt.d / 1000.0)**3 * np.pi / 32.0\n    self._M_Rd = np.round(1.5 * self.bolt.fyb * 1000.0 * w_ell / self.bolt.gamma_M0, 2)\n    return self._M_Rd\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.PinnedConnection.__init__","title":"<code>__init__(bolt, steel_plate, steel_plate_b=None, gap=0)</code>","text":"<p>Post-initialization to ensure the bolt is of type Bolt.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def __init__(self,\n        bolt: Bolt,\n        steel_plate: SteelPlate,\n        steel_plate_b: SteelPlate | object = None,\n        gap: float = 0) -&gt; None:\n    \"\"\"Post-initialization to ensure the bolt is of type Bolt.\"\"\"\n    super().__init__(bolt, steel_plate, steel_plate_b)\n    self._g = gap  # default gap\n    self._p1 = 0.0\n    self._p2 = 0.0\n    self._e1 = MIN_E1_PIN * self.bolt.d0\n    self._e2 = MIN_E2_PIN * self.bolt.d0\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.PinnedConnection.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the bolted connection.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of the bolted connection.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the bolted connection.\n\n    Returns:\n        str: String representation of the bolted connection.\n\n    \"\"\"\n\n    base_text: str = (\n            \"\\nPINNED CONNECTION (simple)\\n\"\n            \"Pinned connection with one central element and two side elements.\\n\"\n        ) if self._pin_type == \"simple\" else (\n            \"\\nPINNED CONNECTION (double)\\n\"\n            \"Pinned connection with two central elements and two side elements.\\n\"\n        )\n\n    geom_text: str = (\n        f\"\\nGeometry and materials:\\n\"\n        f\"End distance e1: {self.e1}\\n\"\n        f\"Edge distance e2: {self.e2}\\n\"\n        # f\"Number of bolts in parallel n1: {self.n1}\\n\"\n        # f\"Number of bolts in series n2: {self.n2}\\n\"\n        f\"Pin diameter: {self.bolt.d} mm\\n\"\n        f\"Pin grade: {self.bolt.steel}\\n\"\n        f\"Pin area: {self.bolt.A:.2f} cm^2\\n\"\n        f\"Pin hole diameter: {self.bolt.d0} mm\\n\"\n        f\"Steel plate A thickness: {self.steel_plate.thickness} mm\\n\"\n        f\"Steel plate A grade: {self.steel_plate.steel.ClassType}\\n\"\n        f\"Steel plate B thickness: {self.steel_plate_b.thickness} mm\\n\"\n        f\"Steel plate B grade: {self.steel_plate_b.steel.ClassType}\\n\"\n        f\"\\nStrength:\\n\"\n        f\"Shear strength: {self._Fv_Rd} kN\\n\"\n        f\"Moment strength: {self._M_Rd} kNm\\n\"\n        f\"Bearing strength (side): {self._Fb_Rd_A} kN\\n\"\n        f\"Bearing strength (centre): {self._Fb_Rd_B} kN\\n\"\n        f\"\\nDesign checks:\\n\"\n    )\n\n    if self._result is not None:\n        check_text: str = (\n        f\"Shear ratios: {self._result['ShearRatios']}\\n\"\n        f\"Moment ratios: {self._result['MomentRatios']}\\n\"\n        f\"Bearing ratios (side): {self._result['BearingRatiosA']}\\n\"\n        f\"Bearing ratios (centre): {self._result['BearingRatiosB']}\\n\"\n        f\"Combined ratios: {self._result['CombinedRatios']}\\n\"\n        f\"Shear ratio: {self._result['ShearRatio']}\\n\"\n        f\"Moment ratio: {self._result['MomentRatio']}\\n\"\n        f\"Bearing ratio (side): {self._result['BearingRatioA']}\\n\"\n        f\"Bearing ratio (centre): {self._result['BearingRatioB']}\\n\"\n        f\"Combined ratio: {self._result['CombinedRatio']}\\n\"\n        f\"Shear check: {self._result['ShearCheck']}\\n\"\n        f\"Moment check: {self._result['MomentCheck']}\\n\"\n        f\"Bearing check (side): {self._result['BearingCheckA']}\\n\"\n        f\"Bearing check (centre): {self._result['BearingCheckB']}\\n\"\n        f\"Combined check: {self._result['CombinedCheck']}\\n\"\n        f\"Check: {self._result['Check']}\")\n    else:\n        check_text: str  = \"WARNING: No results available. Run 'check' method first.\"\n\n    return base_text + geom_text + check_text\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.PinnedConnection.check","title":"<code>check(F_Ed)</code>","text":"<p>Check the design of the pinned connection.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Result of the design checks.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def check(self, F_Ed: np.ndarray) -&gt; dict:  # noqa: N803\n    \"\"\"Check the design of the pinned connection.\n\n    Returns:\n        dict: Result of the design checks.\n\n    \"\"\"\n    # Calculate design forces\n    self.Fv_Ed = F_Ed / 2.0\n    self.Fb_Ed_A = F_Ed / 2.0\n    self.Fb_Ed_B = F_Ed\n    self.M_Ed = F_Ed * (\n        2.0 * self.steel_plate.thickness +\n        self.steel_plate_b.thickness +\n        4.0 * self.g\n    ) / 8.0 / 1000.0\n    # Perform checks on geometry\n    t = min(self.steel_plate.thickness, self.steel_plate_b.thickness)\n    fy = min(self.steel_plate.steel.fyk, self.bolt.fyb)\n    e1_lim = F_Ed / 2.0 / t * self.bolt.gamma_M0 / fy + 7.0 * self.bolt.d0 / 6.0\n    self._e1 = e1_lim\n    e2_lim = F_Ed / 2.0 / t * self.bolt.gamma_M0 / fy + 5.0 * self.bolt.d0 / 6.0\n    self._e2 = e2_lim\n    # Perform checks on stresses\n    shear_ratio = np.round(self.Fv_Ed / self.Fv_Rd(), 2)\n    shear_check = np.all(shear_ratio &lt; 1)\n    moment_ratio = np.round(self.M_Ed / self.M_Rd(), 2)\n    moment_check = np.all(moment_ratio &lt;= 1)\n    self.Fb_Rd()\n    bearing_ratio_a = np.round(self.Fb_Ed_A / self._Fb_Rd_A, 2)\n    bearing_check_a = np.all(bearing_ratio_a &lt;= 1)\n    bearing_ratio_b = np.round(self.Fb_Ed_B / self._Fb_Rd_B, 2)\n    bearing_check_b = np.all(bearing_ratio_b &lt;= 1)\n    combined_ratio = np.round(\n        (self.Fv_Ed / self._Fv_Rd)**2 + (self.M_Ed / self._M_Rd)**2, 2)\n    combined_check = np.all(combined_ratio &lt;= 1)\n\n    self._result = {\n        \"ShearRatios\": shear_ratio,\n        \"ShearRatio\": np.max(shear_ratio),\n        \"ShearCheck\": shear_check,\n        \"MomentRatios\": moment_ratio,\n        \"MomentRatio\": np.max(moment_ratio),\n        \"MomentCheck\": moment_check,\n        \"BearingRatiosA\": bearing_ratio_a,\n        \"BearingRatioA\": np.max(bearing_ratio_a),\n        \"BearingCheckA\": bearing_check_a,\n        \"BearingRatiosB\": bearing_ratio_b,\n        \"BearingRatioB\": np.max(bearing_ratio_b),\n        \"BearingCheckB\": bearing_check_b,\n        \"CombinedRatios\": combined_ratio,\n        \"CombinedRatio\": np.max(combined_ratio),\n        \"CombinedCheck\": combined_check,\n        \"Check\": shear_check &amp; bearing_check_a &amp; bearing_check_b &amp; combined_check,\n    }\n\n    return self._result\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.PinnedConnectionDouble","title":"<code>PinnedConnectionDouble</code>","text":"<p>               Bases: <code>PinnedConnection</code></p> <p>Represents a double pinned connection in a steel structure.</p> <p>Inherits from PinnedConnection and uses the same properties and methods. Plate A are the outer plates, plate B are the inner plate.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>class PinnedConnectionDouble(PinnedConnection):\n    \"\"\"Represents a double pinned connection in a steel structure.\n\n    Inherits from PinnedConnection and uses the same properties and methods.\n    Plate A are the outer plates, plate B are the inner plate.\n\n    \"\"\"\n\n    _pin_type: str = \"double\"\n\n    def __init__(self,\n            bolt: Bolt,\n            steel_plate: SteelPlate,\n            steel_plate_b: SteelPlate | object = None,\n            gap: float = 0) -&gt; None:\n        \"\"\"Post-initialization to ensure the bolt is of type Bolt.\"\"\"\n        super().__init__(bolt, steel_plate, steel_plate_b, gap)\n\n    def check(self, F_Ed: np.ndarray) -&gt; dict:\n        self.Fv_Ed = F_Ed / 2.0\n        self.Fb_Ed_A = F_Ed / 2.0\n        self.Fb_Ed_B = F_Ed / 2.0\n        self.M_Ed = F_Ed * (\n            2.0 * self.steel_plate.thickness +\n            2.0 * self.steel_plate_b.thickness +\n            4.0 * self.g\n        ) / 8.0 / 1000.0\n        shear_ratio = np.round(self.Fv_Ed / self.Fv_Rd(), 2)\n        shear_check = np.all(shear_ratio &lt;= 1)\n        moment_ratio = np.round(self.M_Ed / self.M_Rd(), 2)\n        moment_check = np.all(moment_ratio &lt;= 1)\n        self.Fb_Rd()\n        bearing_ratio_a = np.round(self.Fb_Ed_A / self._Fb_Rd_A, 2)\n        bearing_check_a = np.all(bearing_ratio_a &lt;= 1)\n        bearing_ratio_b = np.round(self.Fb_Ed_B / self._Fb_Rd_B, 2)\n        bearing_check_b = np.all(bearing_ratio_b &lt;= 1)\n        combined_ratio = np.round(\n            (self.Fv_Ed / self._Fv_Rd)**2 + (self.M_Ed / self._M_Rd)**2, 2)\n        combined_check = np.all(combined_ratio &lt;= 1)\n\n        self._result = {\n            \"ShearRatios\": shear_ratio,\n            \"ShearRatio\": np.max(shear_ratio),\n            \"ShearCheck\": shear_check,\n            \"MomentRatios\": moment_ratio,\n            \"MomentRatio\": np.max(moment_ratio),\n            \"MomentCheck\": moment_check,\n            \"BearingRatiosA\": bearing_ratio_a,\n            \"BearingRatioA\": np.max(bearing_ratio_a),\n            \"BearingCheckA\": bearing_check_a,\n            \"BearingRatiosB\": bearing_ratio_b,\n            \"BearingRatioB\": np.max(bearing_ratio_b),\n            \"BearingCheckB\": bearing_check_b,\n            \"CombinedRatios\": combined_ratio,\n            \"CombinedRatio\": np.max(combined_ratio),\n            \"CombinedCheck\": combined_check,\n            \"Check\": shear_check &amp; bearing_check_a &amp; bearing_check_b &amp; combined_check,\n        }\n\n        return self._result\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.PinnedConnectionDouble.__init__","title":"<code>__init__(bolt, steel_plate, steel_plate_b=None, gap=0)</code>","text":"<p>Post-initialization to ensure the bolt is of type Bolt.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def __init__(self,\n        bolt: Bolt,\n        steel_plate: SteelPlate,\n        steel_plate_b: SteelPlate | object = None,\n        gap: float = 0) -&gt; None:\n    \"\"\"Post-initialization to ensure the bolt is of type Bolt.\"\"\"\n    super().__init__(bolt, steel_plate, steel_plate_b, gap)\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.ProfileCHS","title":"<code>ProfileCHS</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SteelSection</code></p> <p>CHS-shaped steel profile according to Eurocode 3.</p> <p>Parameters:</p> Name Type Description Default <code>SteelSection</code> <code>SteelSection</code> <p>geometric and mechanical properties of the section.</p> required Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>@dataclass\nclass ProfileCHS(SteelSection):\n    \"\"\"CHS-shaped steel profile according to Eurocode 3.\n\n    Args:\n        SteelSection (SteelSection): geometric and mechanical properties of the section.\n\n    \"\"\"\n\n    Section: str\n    h: float\n    b: float\n    tw: float\n    tf: float\n    r: float\n    m: float\n    P: float\n    A: float\n    Av_z: float\n    Av_y: float\n    Iy: float\n    iy: float\n    Wel_y: float\n    Wpl_y: float\n    Iz: float\n    iz: float\n    Wel_z: float\n    Wpl_z: float\n    IT: float\n    WT: float\n    Iw: float\n    Ww: float\n    Npl_Rd: float\n    Vpl_Rd_z: float\n    Vpl_Rd_y: float\n    Mel_Rd_y: float\n    Mpl_Rd_y: float\n    Mel_Rd_z: float\n    Mpl_Rd_z: float\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.ProfileI","title":"<code>ProfileI</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SteelSection</code></p> <p>I-shaped steel profile according to Eurocode 3.</p> <p>Parameters:</p> Name Type Description Default <code>SteelSection</code> <code>SteelSection</code> <p>geometric and mechanical properties of the section.</p> required Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>@dataclass\nclass ProfileI(SteelSection):\n    \"\"\"I-shaped steel profile according to Eurocode 3.\n\n    Args:\n        SteelSection (SteelSection): geometric and mechanical properties of the section.\n\n    \"\"\"\n\n    Section: str\n    h: float\n    b: float\n    tw: float\n    tf: float\n    r: float = 0.0  # Fillet radius, default is 0.0\n    m: float = 0.0\n    P: float = 0.0\n    A: float = 0.0\n    Av_z: float = 0.0\n    Av_y: float = 0.0\n    Iy: float = 0.0\n    iy: float = 0.0\n    Wel_y: float = 0.0\n    Wpl_y: float = 0.0\n    Iz: float = 0.0\n    iz: float = 0.0\n    Wel_z: float = 0.0\n    Wpl_z: float = 0.0\n    IT: float = 0.0\n    WT: float = 0.0\n    Iw: float = 0.0\n    Ww: float = 0.0\n    Npl_Rd: float = 0.0\n    Vpl_Rd_z: float = 0.0\n    Vpl_Rd_y: float = 0.0\n    Mel_Rd_y: float = 0.0\n    Mpl_Rd_y: float = 0.0\n    Mel_Rd_z: float = 0.0\n    Mpl_Rd_z: float = 0.0\n    CurveA: str = \"a\"\n    CurveB: str = \"b\"\n    UserDefined: bool = False\n    fyd: float = 235.0  # Design yield strength (MPa)\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Post-initialization to ensure the section type is set correctly.\n\n        Raises:\n            ValueError: If the section type is not 'I'.\n\n        \"\"\"\n        if self.type != \"I\":\n            msg = f\"Invalid section type: {self.type}. Expected 'I'.\"\n            raise ValueError(msg)\n\n        if self.UserDefined:\n            self._initialize_user_defined_properties()\n\n    def _initialize_user_defined_properties(self) -&gt; None:\n        \"\"\"Initialize properties for user-defined sections.\"\"\"\n        self.A = self.tf * self.b * 2 + (self.h - 2 * self.tf) * self.tw\n        self.Av_z = self.tw * self.h\n        self.Av_y = 2.0 * self.tf * self.b\n        self.Iy = (self.b * self.h**3 - (self.tw * (self.h - 2 * self.tf)**3)) / 12.0\n        self.Wel_y = self.Iy / (self.h / 2.0)\n        self.Wpl_y = self.Iy / (self.h / 2.0)\n        self.iy = np.sqrt(self.Iy / self.A)\n        self.Iz = (\n            (self.h * self.b**3) / 12.0 -\n            (self.tf * (self.b - 2 * self.tw)**3) / 12.0)\n        self.Wel_z = self.Iz / (self.b / 2.0)\n        self.Wpl_z = self.Iz / (self.b / 2.0)\n        self.iz = np.sqrt(self.Iz / self.A)\n        self.IT = (\n            (2.0 * self.hf**3 * self.b +\n            self.tw**3 * (self.h - 2.0 * self.hf)) / 3.0\n            )\n        self.WT = 0.0\n        self.Iw = (\n            self.h**2 / 2.0 *\n            (self.b**3 * self.tf / 12.0))\n        self.Ww = 0.0\n        self.Npl_Rd = self.A * 235.0 * 0.1\n        self.Vpl_Rd_z = self.Av_z * 235.0 * 0.1\n        self.Vpl_Rd_y = self.Av_y * 235.0 * 0.1\n        self.Mel_Rd_y = self.Wel_y * 235.0 * 1.0e-3\n        self.Mpl_Rd_y = self.Wpl_y * 235.0 * 1.0e-3\n        self.Mel_Rd_z = self.Wel_z * 235.0 * 1.0e-3\n        self.Mpl_Rd_z = self.Wpl_z * 235.0 * 1.0e-3\n\n    def update_strength(self, fyd: float, gamma_M0: float = 1.0) -&gt; None:  # noqa: D417, N803\n        \"\"\"Update the design strength based on a new yield strength.\n\n        Args:\n            fyk (float): New characteristic yield strength (MPa).\n            gamma_M0 (float, optional): Partial safety factor for material strength.\n            Defaults to 1.0.\n\n        \"\"\"\n        conversion_factor: float = fyd / self.fyd / gamma_M0\n        self.Npl_Rd *= conversion_factor\n        self.Mel_Rd_y *= conversion_factor\n        self.Mpl_Rd_y *= conversion_factor\n        self.Mel_Rd_z *= conversion_factor\n        self.Mpl_Rd_z *= conversion_factor\n        self.Vpl_Rd_y *= conversion_factor\n        self.Vpl_Rd_z *= conversion_factor\n        self.fyd = fyd\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the ProfileI instance.\n\n        Returns:\n            str: A string describing the ProfileI instance.\n\n        \"\"\"\n        return (\n            f\"Geometry: {self.Section}\\n\"\n            f\"User Defined: {self.UserDefined}\\n\"\n            f\"Type: {self.type}\\n\"\n            f\"GEOMETRY:\\n\"\n            f\"Height (h): {self.h} cm\\n\"\n            f\"Width (b): {self.b} cm\\n\"\n            f\"Web thickness (tw): {self.tw} cm\\n\"\n            f\"Flange thickness (tf): {self.tf} cm\\n\"\n            f\"Fillet radius (r): {self.r} cm\\n\"\n            f\"PROPERTIES:\\n\"\n            f\"Mass per unit length (m): {self.m} kg/m\\n\"\n            f\"Perimeter (P): {self.P} m\\n\"\n            f\"Cross-sectional area (A): {self.A} cm\u00b2\\n\"\n            f\"Shear area in z-direction (Av_z): {self.Av_z} cm\u00b2\\n\"\n            f\"Shear area in y-direction (Av_y): {self.Av_y} cm\u00b2\\n\"\n            f\"Moment of inertia about y-axis (Iy): {self.Iy} cm\u2074\\n\"\n            f\"Radius of gyration about y-axis (iy): {self.iy} cm\\n\"\n            f\"Elastic section modulus about y-axis (Wel_y): {self.Wel_y} cm\u00b3\\n\"\n            f\"Plastic section modulus about y-axis (Wpl_y): {self.Wpl_y} cm\u00b3\\n\"\n            f\"Moment of inertia about z-axis (Iz): {self.Iz} cm\u2074\\n\"\n            f\"Radius of gyration about z-axis (iz): {self.iz} cm\\n\"\n            f\"Elastic section modulus about z-axis (Wel_z): {self.Wel_z} cm\u00b3\\n\"\n            f\"Plastic section modulus about z-axis (Wpl_z): {self.Wpl_z} cm\u00b3\\n\"\n            f\"Torsional moment of inertia (IT): {self.IT} cm\u2074\\n\"\n            f\"Torsional section modulus (WT): {self.WT} cm\u00b3\\n\"\n            f\"Warping constant (Iw): {self.Iw} cm\u2076\\n\"\n            f\"Warping section modulus (Ww): {self.Ww} cm\u00b3\\n\"\n            f\"STRENGTH:\\n\"\n            f\"Design yield strength (fyd): {self.fyd} MPa\\n\"\n            f\"Design axial strength (Npl_Rd): {self.Npl_Rd:.2f} kN\\n\"\n            f\"Design shear strength in z-direction (Vpl_Rd_z): {self.Vpl_Rd_z:.2f} kN\\n\"\n            f\"Design shear strength in y-direction (Vpl_Rd_y): {self.Vpl_Rd_y:.2f} kN\\n\"\n            f\"Design elastic moment about y-axis (Mel_Rd_y): {self.Mel_Rd_y:.2f} kNm\\n\"\n            f\"Design plastic moment about y-axis (Mpl_Rd_y): {self.Mpl_Rd_y:.2f} kNm\\n\"\n            f\"Design elastic moment about z-axis (Mel_Rd_z): {self.Mel_Rd_z:.2f} kNm\\n\"\n            f\"Design plastic moment about z-axis (Mpl_Rd_z): {self.Mpl_Rd_z:.2f} kNm\\n\"\n            f\"OTHER DATA:\\n\"\n            f\"Curve A: {self.CurveA}\\n\"\n            f\"Curve B: {self.CurveB}\\n\"\n        )\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.ProfileI.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-initialization to ensure the section type is set correctly.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the section type is not 'I'.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Post-initialization to ensure the section type is set correctly.\n\n    Raises:\n        ValueError: If the section type is not 'I'.\n\n    \"\"\"\n    if self.type != \"I\":\n        msg = f\"Invalid section type: {self.type}. Expected 'I'.\"\n        raise ValueError(msg)\n\n    if self.UserDefined:\n        self._initialize_user_defined_properties()\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.ProfileI.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the ProfileI instance.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string describing the ProfileI instance.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the ProfileI instance.\n\n    Returns:\n        str: A string describing the ProfileI instance.\n\n    \"\"\"\n    return (\n        f\"Geometry: {self.Section}\\n\"\n        f\"User Defined: {self.UserDefined}\\n\"\n        f\"Type: {self.type}\\n\"\n        f\"GEOMETRY:\\n\"\n        f\"Height (h): {self.h} cm\\n\"\n        f\"Width (b): {self.b} cm\\n\"\n        f\"Web thickness (tw): {self.tw} cm\\n\"\n        f\"Flange thickness (tf): {self.tf} cm\\n\"\n        f\"Fillet radius (r): {self.r} cm\\n\"\n        f\"PROPERTIES:\\n\"\n        f\"Mass per unit length (m): {self.m} kg/m\\n\"\n        f\"Perimeter (P): {self.P} m\\n\"\n        f\"Cross-sectional area (A): {self.A} cm\u00b2\\n\"\n        f\"Shear area in z-direction (Av_z): {self.Av_z} cm\u00b2\\n\"\n        f\"Shear area in y-direction (Av_y): {self.Av_y} cm\u00b2\\n\"\n        f\"Moment of inertia about y-axis (Iy): {self.Iy} cm\u2074\\n\"\n        f\"Radius of gyration about y-axis (iy): {self.iy} cm\\n\"\n        f\"Elastic section modulus about y-axis (Wel_y): {self.Wel_y} cm\u00b3\\n\"\n        f\"Plastic section modulus about y-axis (Wpl_y): {self.Wpl_y} cm\u00b3\\n\"\n        f\"Moment of inertia about z-axis (Iz): {self.Iz} cm\u2074\\n\"\n        f\"Radius of gyration about z-axis (iz): {self.iz} cm\\n\"\n        f\"Elastic section modulus about z-axis (Wel_z): {self.Wel_z} cm\u00b3\\n\"\n        f\"Plastic section modulus about z-axis (Wpl_z): {self.Wpl_z} cm\u00b3\\n\"\n        f\"Torsional moment of inertia (IT): {self.IT} cm\u2074\\n\"\n        f\"Torsional section modulus (WT): {self.WT} cm\u00b3\\n\"\n        f\"Warping constant (Iw): {self.Iw} cm\u2076\\n\"\n        f\"Warping section modulus (Ww): {self.Ww} cm\u00b3\\n\"\n        f\"STRENGTH:\\n\"\n        f\"Design yield strength (fyd): {self.fyd} MPa\\n\"\n        f\"Design axial strength (Npl_Rd): {self.Npl_Rd:.2f} kN\\n\"\n        f\"Design shear strength in z-direction (Vpl_Rd_z): {self.Vpl_Rd_z:.2f} kN\\n\"\n        f\"Design shear strength in y-direction (Vpl_Rd_y): {self.Vpl_Rd_y:.2f} kN\\n\"\n        f\"Design elastic moment about y-axis (Mel_Rd_y): {self.Mel_Rd_y:.2f} kNm\\n\"\n        f\"Design plastic moment about y-axis (Mpl_Rd_y): {self.Mpl_Rd_y:.2f} kNm\\n\"\n        f\"Design elastic moment about z-axis (Mel_Rd_z): {self.Mel_Rd_z:.2f} kNm\\n\"\n        f\"Design plastic moment about z-axis (Mpl_Rd_z): {self.Mpl_Rd_z:.2f} kNm\\n\"\n        f\"OTHER DATA:\\n\"\n        f\"Curve A: {self.CurveA}\\n\"\n        f\"Curve B: {self.CurveB}\\n\"\n    )\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.ProfileI.update_strength","title":"<code>update_strength(fyd, gamma_M0=1.0)</code>","text":"<p>Update the design strength based on a new yield strength.</p> <p>Parameters:</p> Name Type Description Default <code>fyk</code> <code>float</code> <p>New characteristic yield strength (MPa).</p> required <code>gamma_M0</code> <code>float</code> <p>Partial safety factor for material strength.</p> <code>1.0</code> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def update_strength(self, fyd: float, gamma_M0: float = 1.0) -&gt; None:  # noqa: D417, N803\n    \"\"\"Update the design strength based on a new yield strength.\n\n    Args:\n        fyk (float): New characteristic yield strength (MPa).\n        gamma_M0 (float, optional): Partial safety factor for material strength.\n        Defaults to 1.0.\n\n    \"\"\"\n    conversion_factor: float = fyd / self.fyd / gamma_M0\n    self.Npl_Rd *= conversion_factor\n    self.Mel_Rd_y *= conversion_factor\n    self.Mpl_Rd_y *= conversion_factor\n    self.Mel_Rd_z *= conversion_factor\n    self.Mpl_Rd_z *= conversion_factor\n    self.Vpl_Rd_y *= conversion_factor\n    self.Vpl_Rd_z *= conversion_factor\n    self.fyd = fyd\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.ProfileRHS","title":"<code>ProfileRHS</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SteelSection</code></p> <p>RHS-shaped steel profile according to Eurocode 3.</p> <p>Parameters:</p> Name Type Description Default <code>SteelSection</code> <code>SteelSection</code> <p>geometric and mechanical properties of the section.</p> required Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>@dataclass\nclass ProfileRHS(SteelSection):\n    \"\"\"RHS-shaped steel profile according to Eurocode 3.\n\n    Args:\n        SteelSection (SteelSection): geometric and mechanical properties of the section.\n\n    \"\"\"\n\n    Section: str\n    h: float\n    b: float\n    tw: float\n    tf: float\n    r: float\n    m: float\n    P: float\n    A: float\n    Av_z: float\n    Av_y: float\n    Iy: float\n    iy: float\n    Wel_y: float\n    Wpl_y: float\n    Iz: float\n    iz: float\n    Wel_z: float\n    Wpl_z: float\n    IT: float\n    WT: float\n    Iw: float\n    Ww: float\n    Npl_Rd: float\n    Vpl_Rd_z: float\n    Vpl_Rd_y: float\n    Mel_Rd_y: float\n    Mpl_Rd_y: float\n    Mel_Rd_z: float\n    Mpl_Rd_z: float\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.ProfileSHS","title":"<code>ProfileSHS</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SteelSection</code></p> <p>SHS-shaped steel profile according to Eurocode 3.</p> <p>Parameters:</p> Name Type Description Default <code>SteelSection</code> <code>SteelSection</code> <p>geometric and mechanical properties of the section.</p> required Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>@dataclass\nclass ProfileSHS(SteelSection):\n    \"\"\"SHS-shaped steel profile according to Eurocode 3.\n\n    Args:\n        SteelSection (SteelSection): geometric and mechanical properties of the section.\n\n    \"\"\"\n\n    Section: str\n    h: float\n    b: float\n    tw: float\n    tf: float\n    r: float\n    m: float\n    P: float\n    A: float\n    Av_z: float\n    Av_y: float\n    Iy: float\n    iy: float\n    Wel_y: float\n    Wpl_y: float\n    Iz: float\n    iz: float\n    Wel_z: float\n    Wpl_z: float\n    IT: float\n    WT: float\n    Iw: float\n    Ww: float\n    Npl_Rd: float\n    Vpl_Rd_z: float\n    Vpl_Rd_y: float\n    Mel_Rd_y: float\n    Mpl_Rd_y: float\n    Mel_Rd_z: float\n    Mpl_Rd_z: float\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.Steel","title":"<code>Steel</code>","text":"<p>Eurocode 3 steel reinforcement properties.</p> <p>:param type_label: Steel type label (e.g., 'S235', 'S275', 'S355', 'S460') :raises ValueError: If the steel type is not found in the database.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>class Steel:\n    \"\"\"Eurocode 3 steel reinforcement properties.\n\n    :param type_label: Steel type label (e.g., 'S235', 'S275', 'S355', 'S460')\n    :raises ValueError: If the steel type is not found in the database.\n    \"\"\"\n\n    def __init__(self, type_label: str = \"S275\") -&gt; None:\n        \"\"\"Initialize a Steel instance with properties from the specified steel label.\n\n        Args:\n        type_label (str): Steel type label (e.g., 'S235', 'S275', 'S355', 'S460')\n\n        Raises:\n        ValueError: If the steel type is not found in the database.\n\n        \"\"\"\n        if type_label not in dbase.SteelGrades:\n            msg = (\n                f\"Steel type '{type_label}' not found in database. \"\n                f\"Steel type must be one of {list(dbase.SteelGrades.keys())}\"\n            )\n            raise ValueError(msg)\n\n        reinf = dbase.SteelGrades[type_label]\n        self.fyk = reinf[\"fyk\"]  # Characteristic yield strength (MPa)\n        self.fuk = reinf[\"fuk\"]  # Characteristic ultimate strength (MPa)\n        self.fyk40 = reinf[\"fyk40\"]  # Characteristic yield strength for 40 mm bar (MPa)\n        self.fuk40 = reinf[\"fuk40\"]  # Charac. ultimate strength for 40 mm bar (MPa)\n        self.Es = reinf[\"Es\"]  # Modulus of elasticity (MPa)\n        self.ClassType = type_label\n\n        gamma_s = dbase.SteelParams[\"gamma_M0\"]  # Partial safety factor\n        self.gamma_M0 = dbase.SteelParams[\"gamma_M0\"]  # Partial safety factor\n        self.gamma_M1 = dbase.SteelParams[\"gamma_M1\"]  # Partial safety factor\n        self.gamma_M2 = dbase.SteelParams[\"gamma_M2\"]  # Partial safety factor\n        self.fyd = round(self.fyk / gamma_s, 1)  # Design yield strength (MPa)\n        self.fyd40 = round(self.fyk40 / gamma_s, 1)  # Design yield strength (MPa)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the Steel instance.\n\n        Returns:\n            str: A string describing the steel properties.\n\n        \"\"\"\n        return (\n            f\"Steel Type: {self.fyk}\\n\"\n            f\"Characteristic Yield Strength (fyk): {self.fyk} MPa\\n\"\n            f\"Characteristic Ultimate Strength (fuk): {self.fuk} MPa\\n\"\n            f\"Design Yield Strength (fyd): {self.fyd} MPa\\n\"\n            f\"Modulus of Elasticity (Es): {self.Es} MPa\\n\"\n            f\"Partial Safety Factor (gamma_M0): {self.gamma_M0}\\n\"\n            f\"Partial Safety Factor (gamma_M1): {self.gamma_M1}\\n\"\n            f\"Partial Safety Factor (gamma_M2): {self.gamma_M2}\\n\"\n        )\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the Steel instance for debugging.\n\n        Returns:\n            str: A string representation of the Steel instance.\n\n        \"\"\"\n        return (\n            f\"Steel(type_label={self.fyk}, \"\n            f\"fyk={self.fyk}, fuk={self.fuk}, \"\n            f\"fyd={self.fyd}, Es={self.Es})\"\n        )\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.Steel.__init__","title":"<code>__init__(type_label='S275')</code>","text":"<p>Initialize a Steel instance with properties from the specified steel label.</p> <p>Args: type_label (str): Steel type label (e.g., 'S235', 'S275', 'S355', 'S460')</p> <p>Raises: ValueError: If the steel type is not found in the database.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def __init__(self, type_label: str = \"S275\") -&gt; None:\n    \"\"\"Initialize a Steel instance with properties from the specified steel label.\n\n    Args:\n    type_label (str): Steel type label (e.g., 'S235', 'S275', 'S355', 'S460')\n\n    Raises:\n    ValueError: If the steel type is not found in the database.\n\n    \"\"\"\n    if type_label not in dbase.SteelGrades:\n        msg = (\n            f\"Steel type '{type_label}' not found in database. \"\n            f\"Steel type must be one of {list(dbase.SteelGrades.keys())}\"\n        )\n        raise ValueError(msg)\n\n    reinf = dbase.SteelGrades[type_label]\n    self.fyk = reinf[\"fyk\"]  # Characteristic yield strength (MPa)\n    self.fuk = reinf[\"fuk\"]  # Characteristic ultimate strength (MPa)\n    self.fyk40 = reinf[\"fyk40\"]  # Characteristic yield strength for 40 mm bar (MPa)\n    self.fuk40 = reinf[\"fuk40\"]  # Charac. ultimate strength for 40 mm bar (MPa)\n    self.Es = reinf[\"Es\"]  # Modulus of elasticity (MPa)\n    self.ClassType = type_label\n\n    gamma_s = dbase.SteelParams[\"gamma_M0\"]  # Partial safety factor\n    self.gamma_M0 = dbase.SteelParams[\"gamma_M0\"]  # Partial safety factor\n    self.gamma_M1 = dbase.SteelParams[\"gamma_M1\"]  # Partial safety factor\n    self.gamma_M2 = dbase.SteelParams[\"gamma_M2\"]  # Partial safety factor\n    self.fyd = round(self.fyk / gamma_s, 1)  # Design yield strength (MPa)\n    self.fyd40 = round(self.fyk40 / gamma_s, 1)  # Design yield strength (MPa)\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.Steel.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the Steel instance for debugging.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the Steel instance.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the Steel instance for debugging.\n\n    Returns:\n        str: A string representation of the Steel instance.\n\n    \"\"\"\n    return (\n        f\"Steel(type_label={self.fyk}, \"\n        f\"fyk={self.fyk}, fuk={self.fuk}, \"\n        f\"fyd={self.fyd}, Es={self.Es})\"\n    )\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.Steel.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the Steel instance.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string describing the steel properties.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the Steel instance.\n\n    Returns:\n        str: A string describing the steel properties.\n\n    \"\"\"\n    return (\n        f\"Steel Type: {self.fyk}\\n\"\n        f\"Characteristic Yield Strength (fyk): {self.fyk} MPa\\n\"\n        f\"Characteristic Ultimate Strength (fuk): {self.fuk} MPa\\n\"\n        f\"Design Yield Strength (fyd): {self.fyd} MPa\\n\"\n        f\"Modulus of Elasticity (Es): {self.Es} MPa\\n\"\n        f\"Partial Safety Factor (gamma_M0): {self.gamma_M0}\\n\"\n        f\"Partial Safety Factor (gamma_M1): {self.gamma_M1}\\n\"\n        f\"Partial Safety Factor (gamma_M2): {self.gamma_M2}\\n\"\n    )\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.SteelPlate","title":"<code>SteelPlate</code>  <code>dataclass</code>","text":"<p>Represents a steel plate with specified thickness, width, and steel grade.</p>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.SteelPlate--attributes","title":"Attributes","text":"<p>thickness : float     Plate thickness in mm. width : float     Plate width in mm. steel : ec.ec3.Steel     Steel grade of the plate.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>@dataclass\nclass SteelPlate:\n    \"\"\"Represents a steel plate with specified thickness, width, and steel grade.\n\n    Attributes\n    ----------\n    thickness : float\n        Plate thickness in mm.\n    width : float\n        Plate width in mm.\n    steel : ec.ec3.Steel\n        Steel grade of the plate.\n\n    \"\"\"\n\n    thickness: float\n    steel: Steel\n    width: float = 1000.0\n    Length: float = 1000.0\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.SteelSection","title":"<code>SteelSection</code>  <code>dataclass</code>","text":"<p>Represents a Eurocode 3 steel profile with geometric and mechanical properties.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>Section type (e.g., 'I', 'L', 'T', etc.).</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>@dataclass\nclass SteelSection:\n    \"\"\"Represents a Eurocode 3 steel profile with geometric and mechanical properties.\n\n    Attributes:\n        type (str): Section type (e.g., 'I', 'L', 'T', etc.).\n\n    \"\"\"\n\n    type: str        # 'IPE', 'HEA', etc.\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.Weld","title":"<code>Weld</code>  <code>dataclass</code>","text":"<p>Represents a weld according to Eurocode 3.</p> <p>Attributes:</p> Name Type Description <code>a</code> <code>float</code> <p>Weld width (mm).</p> <code>length</code> <code>float</code> <p>Weld length (mm).</p> <code>grade</code> <code>str</code> <p>Weld grade (e.g., 'A', 'B', etc.).</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>@dataclass\nclass Weld:\n    \"\"\"Represents a weld according to Eurocode 3.\n\n    Attributes:\n        a (float): Weld width (mm).\n        length (float): Weld length (mm).\n        grade (str): Weld grade (e.g., 'A', 'B', etc.).\n    \"\"\"\n\n    a: float\n    length: float\n    steel_grade: str\n    x: float = 0.0\n    y: float = 0.0\n    orientation: float = 0.0\n    weldtype: WeldTypeEnum = WeldTypeEnum.SLIDENORMAL\n    x_max: float = 0.0\n    y_max: float = 0.0\n    x_min: float = 0.0\n    y_min: float = 0.0\n    cos: float = 1.0\n    sin: float = 0.0\n    xg: float = 0.0\n    yg: float = 0.0\n\n    def __post_init__(self):\n        self.steel_grade = self.steel_grade.upper()\n        if self.steel_grade not in dbase.SteelGrades:\n            msg = (\n                f\"Weld grade '{self.steel_grade}' not found in database. \"\n                f\"Weld grade must be one of {list(dbase.SteelGrades.keys())}\"\n            )\n            raise ValueError(msg)\n\n        steel = dbase.SteelGrades[self.steel_grade]\n        self.fu = steel[\"fuk\"]\n        self.fy = steel[\"fyk\"]\n        grade = extract_steel(self.steel_grade)\n        self.beta_w = 0.8 if grade == \"S235\" else 0.85 if grade == \"S275\" else 0.9 if grade == \"S355\" else 1.00\n        self.gamma_M0 = dbase.SteelParams[\"gamma_M0\"]  # Partial safety factor\n        self.gamma_M1 = dbase.SteelParams[\"gamma_M1\"]  # Partial safety factor\n        self.gamma_M2 = dbase.SteelParams[\"gamma_M2\"]  # Partial safety factor\n        self.fv_wd = self.fu / (np.sqrt(3.0) * self.gamma_M2 * self.beta_w)\n        # Fillet width for shear full strength (should be mukltiplied by t)\n        self.a_full_shear = 0.7 * self.fy / self.gamma_M0 / self.fv_wd  \n        # Fillet width for tension full strength (should be mukltiplied by t)\n        self.a_full_tension = 0.5 * self.fy / self.gamma_M0 / self.fv_wd\n        self.fw_vrd = self.fu / self.gamma_M2 / self.beta_w\n        self.fw_trd = 0.9 * self.fu / self.gamma_M2\n\n        self.cos = np.cos(self.orientation)\n        self.sin = np.sin(self.orientation)\n        self.x_max = self.x + 0.5 * self.length * self.cos\n        self.y_max = self.y + 0.5 * self.length * self.sin\n        self.x_min = self.x - 0.5 * self.length * self.cos\n        self.y_min = self.y - 0.5 * self.length * self.sin\n        i_xx = (self.a**3 * self.length) / 12.0\n        i_yy = (self.a * self.length**3) / 12.0\n        i_xy = 0.5 * (i_xx + i_yy)\n        i_yx = 0.5 * (i_xx - i_yy)\n        cos_2a = np.cos(2 * self.orientation)\n        sin_2a = np.sin(2 * self.orientation)\n        self.inertia_xx = i_xy + i_yx * cos_2a\n        self.inertia_yy = i_xy - i_yx * cos_2a\n        self.inertia_xy = i_yx * sin_2a\n        self.area = self.a * self.length\n        self.area_xx = self.area * np.round(self.cos**2, 2)\n        self.area_yy = self.area * np.round(self.sin**2, 2)\n\n\n    def __repr__(self):\n        return f\"Weld(a='{self.a}', length={self.length}, steel grade='{self.steel_grade}')\"\n</code></pre>"},{"location":"reference/eurocodepy/ec3/#eurocodepy.ec3.WeldTypeEnum","title":"<code>WeldTypeEnum</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration for weld types according to Eurocode 3.</p> Source code in <code>eurocodepy/ec3/__init__.py</code> <pre><code>class WeldTypeEnum(Enum):\n    \"\"\"Enumeration for weld types according to Eurocode 3.\"\"\"\n    SLIDE = 0\n    SHEAR = 1\n    NORMAL = 2\n    SHEARNORMAL = 3\n    SLIDENORMAL = 4\n    SLIDESHEAR = 4\n    SLINESHEARNORMAL = 5\n</code></pre>"},{"location":"reference/eurocodepy/ec3/uls/","title":"uls","text":"<p>Eurocode 3 ULS (Ultimate Limit State) checks.</p> <p>This package provides functions for combined checks and buckling checks according to Eurocode 3.</p>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.SectionCheckResult","title":"<code>SectionCheckResult</code>  <code>dataclass</code>","text":"<p>Result of Eurocode 3 combined check for a section.</p>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.SectionCheckResult--attributes","title":"Attributes","text":"<p>N_Ed: float                     # Design axial force (kN) M_Ed: float                     # Design bending moment (kNm) V_Ed: float                     # Design shear force (kN) N_Rd: float                     # Design axial resistance (kN) M_Rd: float                     # Design bending resistance (kNm) V_pl_Rd: float                  # Design shear resistance (kN) axial_utilization: float        # Utilization ratio for axial force bending_utilization: float      # Utilization ratio for bending moment shear_utilization: float        # Utilization ratio for shear force interaction_utilization: float  # Combined interaction ratio shear_reduction_applied: bool   # True if shear reduction was applied passed: bool                    # True if all checks pass</p> Source code in <code>eurocodepy/ec3/uls/__init__.py</code> <pre><code>@dataclass\nclass SectionCheckResult:\n    \"\"\"Result of Eurocode 3 combined check for a section.\n\n    Attributes\n    ----------\n    N_Ed: float                     # Design axial force (kN)\n    M_Ed: float                     # Design bending moment (kNm)\n    V_Ed: float                     # Design shear force (kN)\n    N_Rd: float                     # Design axial resistance (kN)\n    M_Rd: float                     # Design bending resistance (kNm)\n    V_pl_Rd: float                  # Design shear resistance (kN)\n    axial_utilization: float        # Utilization ratio for axial force\n    bending_utilization: float      # Utilization ratio for bending moment\n    shear_utilization: float        # Utilization ratio for shear force\n    interaction_utilization: float  # Combined interaction ratio\n    shear_reduction_applied: bool   # True if shear reduction was applied\n    passed: bool                    # True if all checks pass\n\n    \"\"\"\n\n    N_Ed: float                     # Axial force (kN)\n    M_Ed: float                     # Bending moment (kNm)\n    V_Ed: float                     # Shear force (kN)\n    N_Rd: float                     # Axial resistance (kN)\n    M_Rd: float                     # Bending resistance (kNm)\n    V_pl_Rd: float                  # Shear resistance (kN)\n    axial_utilization: float        # Utilization ratio for axial force\n    bending_utilization: float      # Utilization ratio for bending\n    shear_utilization: float        # Utilization ratio for shear\n    interaction_utilization: float  # Combined interaction ratio\n    shear_reduction_applied: bool   # True if shear reduction was applied\n    passed: bool                    # True if all checks pass\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the SectionCheckResult object.\n\n        Returns\n        -------\n        str\n            String representation of the SectionCheckResult object.\n\n        \"\"\"\n        return (\n            f\"Forces:\\n\"\n            f\"  Axial (N_Ed): {self.N_Ed:.2f} kN\\n\"\n            f\"  Bending (M_Ed): {self.M_Ed:.2f} kNm\\n\"\n            f\"  Shear (V_Ed): {self.V_Ed:.2f} kN\\n\"\n            f\"Design Resistances:\\n\"\n            f\"  Axial (N_Rd): {self.N_Rd:.2f} kN\\n\"\n            f\"  Bending (M_Rd): {self.M_Rd:.2f} kNm\\n\"\n            f\"  Shear (V_pl_Rd): {self.V_pl_Rd:.2f} kN\\n\"\n            f\"Utilization Ratios:\\n\"\n            f\"  Axial: {self.axial_utilization:.3f}\\n\"\n            f\"  Bending: {self.bending_utilization:.3f}\\n\"\n            f\"  Shear: {self.shear_utilization:.3f}\\n\"\n            f\"  Interaction: {self.interaction_utilization:.3f}\\n\"\n            f\"Shear Reduction Applied: {self.shear_reduction_applied}\\n\"\n            f\"Pass: {'\u2705' if self.passed else '\u274c'}\"\n        )\n</code></pre>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.SectionCheckResult.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the SectionCheckResult object.</p>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.SectionCheckResult.__str__--returns","title":"Returns","text":"<p>str     String representation of the SectionCheckResult object.</p> Source code in <code>eurocodepy/ec3/uls/__init__.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the SectionCheckResult object.\n\n    Returns\n    -------\n    str\n        String representation of the SectionCheckResult object.\n\n    \"\"\"\n    return (\n        f\"Forces:\\n\"\n        f\"  Axial (N_Ed): {self.N_Ed:.2f} kN\\n\"\n        f\"  Bending (M_Ed): {self.M_Ed:.2f} kNm\\n\"\n        f\"  Shear (V_Ed): {self.V_Ed:.2f} kN\\n\"\n        f\"Design Resistances:\\n\"\n        f\"  Axial (N_Rd): {self.N_Rd:.2f} kN\\n\"\n        f\"  Bending (M_Rd): {self.M_Rd:.2f} kNm\\n\"\n        f\"  Shear (V_pl_Rd): {self.V_pl_Rd:.2f} kN\\n\"\n        f\"Utilization Ratios:\\n\"\n        f\"  Axial: {self.axial_utilization:.3f}\\n\"\n        f\"  Bending: {self.bending_utilization:.3f}\\n\"\n        f\"  Shear: {self.shear_utilization:.3f}\\n\"\n        f\"  Interaction: {self.interaction_utilization:.3f}\\n\"\n        f\"Shear Reduction Applied: {self.shear_reduction_applied}\\n\"\n        f\"Pass: {'\u2705' if self.passed else '\u274c'}\"\n    )\n</code></pre>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.SectionProperties","title":"<code>SectionProperties</code>  <code>dataclass</code>","text":"<p>Section properties for Eurocode 3 combined check.</p> Source code in <code>eurocodepy/ec3/uls/__init__.py</code> <pre><code>@dataclass\nclass SectionProperties:\n    \"\"\"Section properties for Eurocode 3 combined check.\"\"\"\n\n    A: float        # Cross-sectional area [mm^2]\n    W_el: float     # Elastic section modulus [mm^3]\n    fy: float       # Yield strength [MPa]\n</code></pre>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.calc_Ncr","title":"<code>calc_Ncr(E, I, L, K=1.0)</code>","text":"<p>Calculate Euler's critical buckling force Ncr.</p> <p>The Euler critical load is the minimum force required to cause buckling of a column. The critical load depends on the column's length, cross-sectional properties, and the material's Young's modulus.</p>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.calc_Ncr--parameters","title":"Parameters","text":"<p>E : float     Young's modulus (MPa) I : float     Moment of inertia about buckling axis (mm^4) L : float     Actual length of the column (mm) K : float, optional     Buckling length factor (dimensionless), by default 1.0</p>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.calc_Ncr--returns","title":"Returns","text":"<p>float     Euler critical load in Newtons (N)</p>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.calc_Ncr--notes","title":"Notes","text":"<p>The buckling length factor depends on the end conditions of the column. For example, for a column fixed at both ends, K = 0.5, while for a column pinned at both ends, K = 1.0.</p> Source code in <code>eurocodepy/ec3/uls/__init__.py</code> <pre><code>def calc_Ncr(E: float, I: float, L: float, K: float = 1.0) -&gt; float:\n    \"\"\"Calculate Euler's critical buckling force Ncr.\n\n    The Euler critical load is the minimum force required to cause buckling\n    of a column. The critical load depends on the column's length, cross-sectional\n    properties, and the material's Young's modulus.\n\n    Parameters\n    ----------\n    E : float\n        Young's modulus (MPa)\n    I : float\n        Moment of inertia about buckling axis (mm^4)\n    L : float\n        Actual length of the column (mm)\n    K : float, optional\n        Buckling length factor (dimensionless), by default 1.0\n\n    Returns\n    -------\n    float\n        Euler critical load in Newtons (N)\n\n    Notes\n    -----\n    The buckling length factor depends on the end conditions of the column.\n    For example, for a column fixed at both ends, K = 0.5, while for a column\n    pinned at both ends, K = 1.0.\n\n    \"\"\"\n    Leff = K * L\n    Ncr = (np.pi ** 2 * E * I) / (Leff ** 2)  # in N\n    return Ncr\n</code></pre>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.calc_Ncr_T","title":"<code>calc_Ncr_T(E, G, I_w, I_t, L)</code>","text":"<p>Calculate torsional buckling load Ncr,T.</p>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.calc_Ncr_T--parameters","title":"Parameters","text":"<p>E (float): Young's modulus [Pa] G (float): Shear modulus [Pa] I_w (float): Warping constant [m^6] I_t (float): Torsional constant [m^4] L (float): Effective length [m]</p>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.calc_Ncr_T--returns","title":"Returns","text":"<p>float: Torsional buckling load [N]</p> Source code in <code>eurocodepy/ec3/uls/__init__.py</code> <pre><code>def calc_Ncr_T(\n    E: float,  # Young's modulus [Pa]\n    G: float,  # Shear modulus [Pa]\n    I_w: float,  # Warping constant [m^6]\n    I_t: float,  # Torsional constant [m^4]\n    L: float  # Effective length [m]\n) -&gt; float:\n    \"\"\"Calculate torsional buckling load Ncr,T.\n\n    Parameters\n    ----------\n    E (float): Young's modulus [Pa]\n    G (float): Shear modulus [Pa]\n    I_w (float): Warping constant [m^6]\n    I_t (float): Torsional constant [m^4]\n    L (float): Effective length [m]\n\n    Returns\n    -------\n    float: Torsional buckling load [N]\n\n    \"\"\"\n    pi = np.pi\n    return (pi**2 * E * I_w) / (L**2) + G * I_t\n</code></pre>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.calc_Ncr_TF","title":"<code>calc_Ncr_TF(E, G, L, Iy, It, Iw, A, ey, Ky=1.0, Kt=1.0)</code>","text":"<p>Compute critical torsional-flexural buckling force (Ncr,TF) per Eurocode 3.</p>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.calc_Ncr_TF--parameters","title":"Parameters","text":"<p>E : float     Young's modulus (MPa) G : float     Shear modulus (MPa) L : float     Length of the member (mm) Iy : float     Minor-axis second moment of area (mm^4) It : float     Torsional constant (mm^4) Iw : float     Warping constant (mm^6) A : float     Cross-sectional area (mm^2) ey : float     Distance between shear center and centroid (mm) Ky : float, optional     Buckling length factor for y-axis (default 1.0) Kt : float, optional     Buckling length factor for torsion (default 1.0)</p>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.calc_Ncr_TF--returns","title":"Returns","text":"<p>Ncr_TF : float     Critical load in N (Newtons)</p>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.calc_Ncr_TF--notes","title":"Notes","text":"<p>Eurocode 3 Part 1-1, Section 6.3.1.4</p> Source code in <code>eurocodepy/ec3/uls/__init__.py</code> <pre><code>def calc_Ncr_TF(\n    E: float,  # Young's modulus (MPa)\n    G: float,  # Shear modulus (MPa)\n    L: float,  # Length of the member (mm)\n    Iy: float,  # Minor-axis second moment of area (mm^4)\n    It: float,  # Torsional constant (mm^4)\n    Iw: float,  # Warping constant (mm^6)\n    A: float,  # Cross-sectional area (mm^2)\n    ey: float,  # Distance between shear center and centroid (mm)\n    Ky: float = 1.0,  # Buckling length factor for y-axis (default 1.0)\n    Kt: float = 1.0  # Buckling length factor for torsion (default 1.0)\n) -&gt; float:\n    \"\"\"Compute critical torsional-flexural buckling force (Ncr,TF) per Eurocode 3.\n\n    Parameters\n    ----------\n    E : float\n        Young's modulus (MPa)\n    G : float\n        Shear modulus (MPa)\n    L : float\n        Length of the member (mm)\n    Iy : float\n        Minor-axis second moment of area (mm^4)\n    It : float\n        Torsional constant (mm^4)\n    Iw : float\n        Warping constant (mm^6)\n    A : float\n        Cross-sectional area (mm^2)\n    ey : float\n        Distance between shear center and centroid (mm)\n    Ky : float, optional\n        Buckling length factor for y-axis (default 1.0)\n    Kt : float, optional\n        Buckling length factor for torsion (default 1.0)\n\n    Returns\n    -------\n    Ncr_TF : float\n        Critical load in N (Newtons)\n\n    Notes\n    -----\n    Eurocode 3 Part 1-1, Section 6.3.1.4\n\n    \"\"\"\n    # Effective lengths\n    Ly = Ky * L\n    Lt = Kt * L\n\n    # Euler buckling about y-axis\n    Ncr_y = (np.pi**2 * E * Iy) / (Ly**2)\n\n    # Torsional buckling component\n    Ncr_T = (G * It * (np.pi**2) / (Lt**2)) + (E * Iw * (np.pi**4) / (Lt**4))\n\n    # Combined torsional-flexural buckling\n    return 1 / ((1 / Ncr_y) + (1 / Ncr_T))\n</code></pre>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.check_ltb_resistance","title":"<code>check_ltb_resistance(f_y, E, G, gamma_M1, I_y, I_z, W_el_z, I_w, I_t, L, M_Ed, C1=1.0, alpha_LT=0.34)</code>","text":"<p>Check lateral torsional buckling resistance for an I-section beam.</p>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.check_ltb_resistance--parameters","title":"Parameters","text":"<pre><code>f_y:     Yield strength [Pa]\nE:       Young\u2019s modulus [Pa]\nG:       Shear modulus [Pa]\ngamma_M1: Partial safety factor (usually 1.0)\nI_y:     Minor axis moment of inertia [m^4]\nI_z:     Major axis moment of inertia [m^4]\nW_el_z:  Elastic section modulus about major axis [m^3]\nI_w:     Warping constant [m^6]\nI_t:     Torsional constant [m^4]\nL:       Buckling length [m]\nM_Ed:    Design moment acting on the beam [Nm]\nC1:      Moment distribution factor (default = 1.0)\nalpha_LT: Imperfection factor (default = 0.34 for rolled sections)\n</code></pre>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.check_ltb_resistance--returns","title":"Returns","text":"<pre><code>A dictionary with:\n    - M_cr: Critical moment [Nm]\n    - lambda_bar_LT: Non-dimensional slenderness\n    - chi_LT: Reduction factor\n    - M_b_Rd: Design moment resistance [Nm]\n    - Utilization: M_Ed / M_b_Rd\n    - Status: \"PASS\" or \"FAIL\"\n</code></pre> Source code in <code>eurocodepy/ec3/uls/__init__.py</code> <pre><code>def check_ltb_resistance(\n    f_y: float,\n    E: float,\n    G: float,\n    gamma_M1: float,\n    I_y: float,\n    I_z: float,\n    W_el_z: float,\n    I_w: float,\n    I_t: float,\n    L: float,\n    M_Ed: float,\n    C1: float = 1.0,\n    alpha_LT: float = 0.34\n) -&gt; dict:\n    \"\"\"Check lateral torsional buckling resistance for an I-section beam.\n\n    Parameters\n    ----------\n        f_y:     Yield strength [Pa]\n        E:       Young\u2019s modulus [Pa]\n        G:       Shear modulus [Pa]\n        gamma_M1: Partial safety factor (usually 1.0)\n        I_y:     Minor axis moment of inertia [m^4]\n        I_z:     Major axis moment of inertia [m^4]\n        W_el_z:  Elastic section modulus about major axis [m^3]\n        I_w:     Warping constant [m^6]\n        I_t:     Torsional constant [m^4]\n        L:       Buckling length [m]\n        M_Ed:    Design moment acting on the beam [Nm]\n        C1:      Moment distribution factor (default = 1.0)\n        alpha_LT: Imperfection factor (default = 0.34 for rolled sections)\n\n    Returns\n    -------\n        A dictionary with:\n            - M_cr: Critical moment [Nm]\n            - lambda_bar_LT: Non-dimensional slenderness\n            - chi_LT: Reduction factor\n            - M_b_Rd: Design moment resistance [Nm]\n            - Utilization: M_Ed / M_b_Rd\n            - Status: \"PASS\" or \"FAIL\"\n\n    \"\"\"\n    # Elastic critical moment (Annex F)\n    pi = np.pi\n    M_cr = (C1 * pi**2 * E * I_z / (L**2)) * np.sqrt(\n        (G * I_t * L**2) / (pi**2 * E * I_z) + (pi**2 * I_w) / (L**2 * I_z)\n    )\n\n    # Design resistance without LTB\n    M_y_Rd = f_y * W_el_z / gamma_M1\n\n    # Slenderness\n    lambda_bar_LT = np.sqrt(W_el_z * f_y / M_cr)\n\n    # Reduction factor chi_LT (EN 1993-1-1, Eq. 6.56)\n    phi_LT = 0.5 * (1 + alpha_LT * (lambda_bar_LT - 0.2) + lambda_bar_LT**2)\n    chi_LT = min(1.0, 1.0 / (phi_LT + np.sqrt(phi_LT**2 - lambda_bar_LT**2)))\n\n    # LTB design resistance\n    M_b_Rd = chi_LT * M_y_Rd\n\n    # Check utilization\n    utilization = M_Ed / M_b_Rd\n    status = \"PASS\" if utilization &lt;= 1.0 else \"FAIL\"\n\n    return {\n        \"M_cr [kNm]\": M_cr / 1e3,\n        \"\u03bb\u0304_LT\": lambda_bar_LT,\n        \"\u03c7_LT\": chi_LT,\n        \"M_b,Rd [kNm]\": M_b_Rd / 1e3,\n        \"Utilization\": utilization,\n        \"Status\": status,\n    }\n</code></pre>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.eurocode3_buckling_check","title":"<code>eurocode3_buckling_check(*, N_Ed, params, buckling_curve='b', gamma_M1=1.0)</code>","text":"<p>Verifica a resist\u00eancia \u00e0 flambagem de acordo com o Eurocode 3 (EN 1993-1-1).</p> <p>Args: N_Ed : for\u00e7a axial de projeto [kN] params : BucklingParameters (A, fy, L_cr, i) buckling_curve : curva de flambagem ('a', 'b', 'c', 'd') gamma_M1 : coeficiente de seguran\u00e7a parcial</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, float]</code> <p>Um dicion\u00e1rio com os resultados da verifica\u00e7\u00e3o, incluindo lambda_bar, chi, N_pl_Rd, N_b_Rd, utilization e pass.</p> Source code in <code>eurocodepy/ec3/uls/__init__.py</code> <pre><code>def eurocode3_buckling_check(\n    *,\n    N_Ed: float,\n    params: BucklingParameters,\n    buckling_curve: str = 'b',\n    gamma_M1: float = 1.0\n) -&gt; dict[str, float]:\n    \"\"\"Verifica a resist\u00eancia \u00e0 flambagem de acordo com o Eurocode 3 (EN 1993-1-1).\n\n    Args:\n    N_Ed : for\u00e7a axial de projeto [kN]\n    params : BucklingParameters (A, fy, L_cr, i)\n    buckling_curve : curva de flambagem ('a', 'b', 'c', 'd')\n    gamma_M1 : coeficiente de seguran\u00e7a parcial\n\n    Returns:\n        dict: Um dicion\u00e1rio com os resultados da verifica\u00e7\u00e3o, incluindo lambda_bar, chi, N_pl_Rd, N_b_Rd, utilization e pass.\n\n    \"\"\"\n    # Limite de escoamento convertido para kN/mm\u00b2\n    fy_kN = params.fy / 1000\n\n    # Resist\u00eancia pl\u00e1stica \u00e0 compress\u00e3o (sem flambagem)\n    N_pl_Rd = params.A * fy_kN / gamma_M1  # [kN]\n\n    # Esbeltez adimensional (lambda-bar)\n    slenderness = params.L_cr / params.i\n    lambda_bar = slenderness * np.sqrt(fy_kN / (np.pi**2 * 210e3))  # E = 210000 MPa\n\n    # Par\u00e2metros alfa da curva de flambagem\n    alpha_dict = {\n        'a': 0.21,\n        'b': 0.34,\n        'c': 0.49,\n        'd': 0.76\n    }\n    alpha = alpha_dict.get(buckling_curve, 0.34)\n\n    # Par\u00e2metros de flambagem\n    phi = 0.5 * (1 + alpha * (lambda_bar - 0.2) + lambda_bar**2)\n    chi = min(1 / (phi + np.sqrt(phi**2 - lambda_bar**2)), 1.0)\n\n    # Resist\u00eancia de c\u00e1lculo com flambagem\n    N_b_Rd = chi * N_pl_Rd  # [kN]\n\n    # Utiliza\u00e7\u00e3o\n    utilization = N_Ed / N_b_Rd\n\n    return {\n        \"lambda_bar\": round(lambda_bar, 3),\n        \"chi\": round(chi, 3),\n        \"N_pl_Rd [kN]\": round(N_pl_Rd, 2),\n        \"N_b_Rd [kN]\": round(N_b_Rd, 2),\n        \"utilization\": round(utilization, 3),\n        \"pass\": utilization &lt;= 1,\n    }\n</code></pre>"},{"location":"reference/eurocodepy/ec3/uls/#eurocodepy.ec3.uls.eurocode3_combined_check","title":"<code>eurocode3_combined_check(N_Ed, M_Ed, V_Ed, area, area_v, W_el, fy, gamma_M0=1.0, gamma_M1=1.0)</code>","text":"<p>Eurocode 3 combined check for axial force, bending and shear.</p> <p>This function performs a Eurocode 3 combined check for axial force, bending and  shear. It takes the design axial force, bending moment, shear force, and the section  properties as input. It returns a dictionary with the utilization ratios and a pass/fail status.</p> <p>Parameters:</p> Name Type Description Default <code>N_Ed</code> <code>float</code> <p>Axial design force [kN]</p> required <code>M_Ed</code> <code>float</code> <p>Bending moment design value [kNm]</p> required <code>V_Ed</code> <code>float</code> <p>Shear force design value [kN]</p> required <code>section</code> <code>SectionProperties</code> <p>Section properties (A, W_el, fy)</p> required <code>gamma_M0</code> <code>float</code> <p>Partial safety factor for resistance of</p> <code>1.0</code> <code>gamma_M1</code> <code>float</code> <p>Partial safety factor for resistance of members to</p> <code>1.0</code> <code>gamma_M2</code> <code>float</code> <p>Partial safety factor for resistance of</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>SectionCheckResult</code> <p>Dictionary with utilization ratios and pass/fail status.</p> <code>SectionCheckResult</code> <ul> <li>N_Rd: Axial resistance [kN]</li> </ul> <code>SectionCheckResult</code> <ul> <li>M_Rd: Bending resistance [kNm]</li> </ul> <code>SectionCheckResult</code> <ul> <li>V_pl_Rd: Shear resistance [kN]</li> </ul> <code>SectionCheckResult</code> <ul> <li>axial_utilization: Utilization ratio for axial force</li> </ul> <code>SectionCheckResult</code> <ul> <li>bending_utilization: Utilization ratio for bending moment</li> </ul> <code>SectionCheckResult</code> <ul> <li>shear_utilization: Utilization ratio for shear force</li> </ul> <code>SectionCheckResult</code> <ul> <li>interaction_utilization: Combined utilization ratio</li> </ul> <code>SectionCheckResult</code> <ul> <li>shear_reduction_applied: Whether shear reduction was applied</li> </ul> <code>SectionCheckResult</code> <ul> <li>pass: True if all checks pass, False otherwise</li> </ul> Source code in <code>eurocodepy/ec3/uls/__init__.py</code> <pre><code>def eurocode3_combined_check(  # noqa: D417, PLR0913, PLR0917\n    N_Ed: float,\n    M_Ed: float,\n    V_Ed: float,\n    area: float,\n    area_v: float,\n    W_el: float,\n    fy: float,\n    gamma_M0: float = 1.0,\n    gamma_M1: float = 1.0,\n) -&gt; SectionCheckResult:\n    \"\"\"Eurocode 3 combined check for axial force, bending and shear.\n\n    This function performs a Eurocode 3 combined check for axial force, bending and \n    shear.\n    It takes the design axial force, bending moment, shear force, and the section \n    properties as input. It returns a dictionary with the utilization ratios\n    and a pass/fail status.\n\n    Args:\n        N_Ed (float): Axial design force [kN]\n        M_Ed (float): Bending moment design value [kNm]\n        V_Ed (float): Shear force design value [kN]\n        section (SectionProperties): Section properties (A, W_el, fy)\n        gamma_M0 (float, optional): Partial safety factor for resistance of\n        cross-sections to yielding. Default is 1.0.\n        gamma_M1 (float, optional): Partial safety factor for resistance of members to\n        instability. Default is 1.0.\n        gamma_M2 (float, optional): Partial safety factor for resistance of\n        cross-sections to rupture. Default is 1.25.\n\n    Returns:\n        dict: Dictionary with utilization ratios and pass/fail status.\n        - N_Rd: Axial resistance [kN]\n        - M_Rd: Bending resistance [kNm]\n        - V_pl_Rd: Shear resistance [kN]\n        - axial_utilization: Utilization ratio for axial force\n        - bending_utilization: Utilization ratio for bending moment\n        - shear_utilization: Utilization ratio for shear force\n        - interaction_utilization: Combined utilization ratio\n        - shear_reduction_applied: Whether shear reduction was applied\n        - pass: True if all checks pass, False otherwise\n\n    \"\"\"\n    # Convert fy to kN/mm^2\n    fy_kN = fy * 1000\n\n    # Resistances\n    N_Rd = area * fy_kN / gamma_M0  # kN\n    M_Rd = W_el * fy_kN / gamma_M1  # kNm\n    V_pl_Rd = 0.5 * area_v * fy_kN / gamma_M0  # kN (approx. for I-beams in shear)\n\n    # Checks\n    axial_util = N_Ed / N_Rd\n    bending_util = M_Ed / M_Rd\n    shear_util = V_Ed / V_pl_Rd\n\n    interaction_util = axial_util + bending_util\n\n    shear_reduction = V_Ed / V_pl_Rd &gt; 0.5\n    if shear_reduction:\n        # Simplified reduction\n        M_Rd_red = M_Rd * (1 - 0.5 * (V_Ed / V_pl_Rd - 0.5))\n        bending_util = M_Ed / M_Rd_red\n        interaction_util = axial_util + bending_util\n\n    return SectionCheckResult(\n        N_Ed=N_Ed,\n        M_Ed=M_Ed,\n        V_Ed=V_Ed,\n        N_Rd=N_Rd,\n        M_Rd=M_Rd,\n        V_pl_Rd=V_pl_Rd,\n        axial_utilization=axial_util,\n        bending_utilization=bending_util,\n        shear_utilization=shear_util,\n        interaction_utilization=interaction_util,\n        shear_reduction_applied=shear_reduction,\n        passed=interaction_util &lt;= 1 and shear_util &lt;= 1)\n</code></pre>"},{"location":"reference/eurocodepy/ec5/","title":"ec5","text":"<p>Eurocode 5 Timber Module.</p> <p>This module provides classes and functions for Eurocode 5 timber design. It includes properties for different timber grades and types, as well as calculations for serviceability and ultimate limit states. it also includes vibration and deformation calculations.</p>"},{"location":"reference/eurocodepy/ec5/materials/","title":"materials","text":""},{"location":"reference/eurocodepy/ec5/materials/#eurocodepy.ec5.materials.CLT","title":"<code>CLT</code>","text":"<p>               Bases: <code>Timber</code></p> <p>Eurocode 5 Cross-Laminated Timber (CLT) properties. Not implemented.</p> Source code in <code>eurocodepy/ec5/materials.py</code> <pre><code>class CLT(Timber):\n    \"\"\"Eurocode 5 Cross-Laminated Timber (CLT) properties. Not implemented.\"\"\"\n</code></pre>"},{"location":"reference/eurocodepy/ec5/materials/#eurocodepy.ec5.materials.Glulam","title":"<code>Glulam</code>","text":"<p>               Bases: <code>Timber</code></p> <p>Eurocode 5 glulam properties.</p> <p>Properties read from the database for the given type_label.</p> <p>Parameters:</p> Name Type Description Default <code>type_label</code> <code>str</code> <p>Glulam type label (e.g., 'GL24h', 'GL28c').</p> <code>'GL24h'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the type_label does not start with 'GL' or</p> Source code in <code>eurocodepy/ec5/materials.py</code> <pre><code>class Glulam(Timber):\n    \"\"\"Eurocode 5 glulam properties.\n\n    Properties read from the database for the given type_label.\n\n    Args:\n        type_label (str, optional): Glulam type label (e.g., 'GL24h', 'GL28c').\n        Defaults to 'GL24h'.\n\n    Raises:\n        ValueError: If the type_label does not start with 'GL' or\n        is not found in the database.\n    \"\"\"\n\n    def __init__(self, type_label: str = \"GL24h\") -&gt; None:\n        grades_list = [item for item in dbase.TimberGrades if item.startswith(\"GL\")]\n\n        if not type_label.startswith(\"GL\"):\n            msg = (\n                f\"Glulam type '{type_label}' must start with 'GL'. \"\n                f\"Glulam type must be one of {grades_list}\"\n            )\n            raise ValueError(msg)\n        if type_label not in grades_list:\n            msg = (\n                f\"Glulam type '{type_label}' not found in database. \"\n                f\"Glulam type must be one of {grades_list}\"\n            )\n            raise ValueError(msg)\n\n        super().__init__(type_label)\n\n        self.fvrefk = dbase.TimberParams[\"fvrefk\"][self.type]\n        self.theta_twist = dbase.TimberParams[\"theta_twist\"][self.type]\n        self.kred = dbase.TimberParams[\"kred\"][self.type]\n</code></pre>"},{"location":"reference/eurocodepy/ec5/materials/#eurocodepy.ec5.materials.LVL","title":"<code>LVL</code>","text":"<p>               Bases: <code>Timber</code></p> <p>Eurocode 5 Laminated Veneer Lumber (LVL) properties. Not implemented.</p> Source code in <code>eurocodepy/ec5/materials.py</code> <pre><code>class LVL(Timber):\n    \"\"\"Eurocode 5 Laminated Veneer Lumber (LVL) properties. Not implemented.\"\"\"\n</code></pre>"},{"location":"reference/eurocodepy/ec5/materials/#eurocodepy.ec5.materials.SolidTimber","title":"<code>SolidTimber</code>","text":"<p>               Bases: <code>Timber</code></p> <p>Class represents Eurocode 5 solid timber properties.</p> <p>It includes both softwood and hardwood types. Properties read from the database for the given type_label.</p> <p>Parameters:</p> Name Type Description Default <code>type_label</code> <code>str</code> <p>Timber grade label (e.g., 'C24', 'D30').</p> <code>'C24'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the type_label is not found in the database.</p> Source code in <code>eurocodepy/ec5/materials.py</code> <pre><code>class SolidTimber(Timber):\n    \"\"\"Class represents Eurocode 5 solid timber properties.\n\n    It includes both softwood and hardwood types.\n    Properties read from the database for the given type_label.\n\n    Args:\n        type_label (str, optional): Timber grade label (e.g., 'C24', 'D30').\n        Defaults to 'C24'.\n\n    Raises:\n        ValueError: If the type_label is not found in the database.\n\n    \"\"\"\n\n    def __init__(self, type_label: str = \"C24\") -&gt; None:\n        grades_list = [item for item in dbase.TimberGrades\n                    if (item.startswith((\"C\", \"D\")))]\n        if type_label not in grades_list:\n            msg = (\n                f\"Softwood type '{type_label}' not found in database. \"\n                f\"Softwood type must be one of {grades_list}\"\n            )\n            raise ValueError(msg)\n\n        super().__init__(type_label)\n\n        self.fvrefk = dbase.TimberParams[\"fvrefk\"][self.type]\n        self.theta_twist = dbase.TimberParams[\"theta_twist\"][self.type]\n        self.kred = dbase.TimberParams[\"kred\"][self.type]\n</code></pre>"},{"location":"reference/eurocodepy/ec5/materials/#eurocodepy.ec5.materials.Timber","title":"<code>Timber</code>","text":"<p>Initialize Timber object.</p> <p>Properties are derived from the database for the given type_label.</p> <p>Parameters:</p> Name Type Description Default <code>type_label</code> <code>str</code> <p>Timber grade label (e.g., 'C24').</p> <code>'C24'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the type_label is not found in the database.</p> Source code in <code>eurocodepy/ec5/materials.py</code> <pre><code>class Timber:\n    \"\"\"Initialize Timber object.\n\n    Properties are derived from the database for the given type_label.\n\n    Args:\n        type_label (str, optional): Timber grade label (e.g., 'C24').\n        Defaults to 'C24'.\n\n    Raises:\n        ValueError: If the type_label is not found in the database.\n\n    \"\"\"\n\n    def __init__(self, type_label: str = \"C24\") -&gt; None:\n        if type_label not in dbase.TimberGrades:\n            msg = (\n                f\"Timber type '{type_label}' not found in database. \"\n                f\"Timber type must be one of {list(dbase.TimberGrades)}\"\n            )\n            raise ValueError(msg)\n\n        timber = dbase.TimberGrades[type_label]\n        self.fmk = timber[\"fmk\"]  # Characteristic strength in MPa\n        self.ft0k = timber[\"ft0k\"]  # Charact. strength in tension // to grain (MPa)\n        self.ft90k = timber[\"ft90k\"]  # Charact. strength in tensio perp. to grain (MPa)\n        self.fc0k = timber[\"fc0k\"]  # Charact. strength in compression // to grain (MPa)\n        self.fc90k = timber[\"fc90k\"]  # Charact. strength in compr. perp. to grain (MPa)\n        self.fvk = timber[\"fvk\"]  # Characteristic shear strength (MPa)\n        self.E0mean = timber[\"E0mean\"]  # Mean modulus elasticity in MPa\n        self.E0k = timber[\"E0k\"]  # Characteristic modulus elasticity in MPa\n        self.E90k = timber[\"E90k\"]  # Charact. modulus elasticity perp. to grain (MPa)\n        self.Gmean = timber[\"Gmean\"]  # Mean shear modulus in MPa\n        self.rhok = timber[\"rhok\"]  # Characteristic density in kg/m\u00b3\n        self.rhom = timber[\"rhom\"]  # Mean density in kg/m\u00b3\n        self.type_label = type_label\n        self.type = timber[\"Type\"]\n\n        self.safety = dbase.TimberParams[\"safety\"][self.type]  # Partial safety factor\n        self.kmod = dbase.TimberParams[\"kmod\"][self.type]\n        self.kdef = dbase.TimberParams[\"kmod\"][self.type]\n        self.kh = dbase.TimberParams[\"kh\"][self.type]\n\n    def k_mod(\n        self,\n        service_class: ServiceClass = ServiceClass.SC1,\n        load_duratiom: LoadDuration = LoadDuration.Medium,\n    ) -&gt; float:\n        \"\"\"Return the kmod value for serviceability limit state.\n\n        Args:\n            service_class (ServiceClass, optional): Service class (SC1, SC2, or SC3).\n                Defaults to ServiceClass.SC1.\n            load_duratiom (LoadDuration, optional): Load duration (Perm, Long,\n            Medium, Short, Inst).\n                Defaults to LoadDuration.Medium.\n\n        Returns:\n            float: kmod value for the specified service class and load duration.\n\n        \"\"\"\n        return self.kmod[service_class.name][load_duratiom.value]\n\n    def k_def(self, service_class: ServiceClass = ServiceClass.SC1) -&gt; float:\n        \"\"\"Return the kdef value for serviceability limit state.\n\n        Args:\n            service_class (ServiceClass, optional): Service class (SC1, SC2, or SC3).\n                Defaults to ServiceClass.SC1.\n\n        Returns:\n            float: kmod value for the specified service class.\n\n        \"\"\"\n        return self.kdef[service_class.name]\n</code></pre>"},{"location":"reference/eurocodepy/ec5/materials/#eurocodepy.ec5.materials.Timber.k_def","title":"<code>k_def(service_class=ServiceClass.SC1)</code>","text":"<p>Return the kdef value for serviceability limit state.</p> <p>Parameters:</p> Name Type Description Default <code>service_class</code> <code>ServiceClass</code> <p>Service class (SC1, SC2, or SC3). Defaults to ServiceClass.SC1.</p> <code>SC1</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>kmod value for the specified service class.</p> Source code in <code>eurocodepy/ec5/materials.py</code> <pre><code>def k_def(self, service_class: ServiceClass = ServiceClass.SC1) -&gt; float:\n    \"\"\"Return the kdef value for serviceability limit state.\n\n    Args:\n        service_class (ServiceClass, optional): Service class (SC1, SC2, or SC3).\n            Defaults to ServiceClass.SC1.\n\n    Returns:\n        float: kmod value for the specified service class.\n\n    \"\"\"\n    return self.kdef[service_class.name]\n</code></pre>"},{"location":"reference/eurocodepy/ec5/materials/#eurocodepy.ec5.materials.Timber.k_mod","title":"<code>k_mod(service_class=ServiceClass.SC1, load_duratiom=LoadDuration.Medium)</code>","text":"<p>Return the kmod value for serviceability limit state.</p> <p>Parameters:</p> Name Type Description Default <code>service_class</code> <code>ServiceClass</code> <p>Service class (SC1, SC2, or SC3). Defaults to ServiceClass.SC1.</p> <code>SC1</code> <code>load_duratiom</code> <code>LoadDuration</code> <p>Load duration (Perm, Long,</p> <code>Medium</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>kmod value for the specified service class and load duration.</p> Source code in <code>eurocodepy/ec5/materials.py</code> <pre><code>def k_mod(\n    self,\n    service_class: ServiceClass = ServiceClass.SC1,\n    load_duratiom: LoadDuration = LoadDuration.Medium,\n) -&gt; float:\n    \"\"\"Return the kmod value for serviceability limit state.\n\n    Args:\n        service_class (ServiceClass, optional): Service class (SC1, SC2, or SC3).\n            Defaults to ServiceClass.SC1.\n        load_duratiom (LoadDuration, optional): Load duration (Perm, Long,\n        Medium, Short, Inst).\n            Defaults to LoadDuration.Medium.\n\n    Returns:\n        float: kmod value for the specified service class and load duration.\n\n    \"\"\"\n    return self.kmod[service_class.name][load_duratiom.value]\n</code></pre>"},{"location":"reference/eurocodepy/ec5/materials/#eurocodepy.ec5.materials.WoodBasedPanels","title":"<code>WoodBasedPanels</code>","text":"<p>               Bases: <code>Timber</code></p> <p>Eurocode 5 Wood-Based Panels properties. Not implemented.</p> Source code in <code>eurocodepy/ec5/materials.py</code> <pre><code>class WoodBasedPanels(Timber):\n    \"\"\"Eurocode 5 Wood-Based Panels properties. Not implemented.\"\"\"\n</code></pre>"},{"location":"reference/eurocodepy/ec5/sls/","title":"sls","text":""},{"location":"reference/eurocodepy/ec5/sls/deformation/","title":"deformation","text":""},{"location":"reference/eurocodepy/ec5/sls/vibration/","title":"vibration","text":""},{"location":"reference/eurocodepy/ec5/sls/vibration/#eurocodepy.ec5.sls.vibration.a_from_b","title":"<code>a_from_b(b)</code>","text":"<p>Interpolates and returns the corresponding 'a' value for a given 'b' using predefined arrays.</p>"},{"location":"reference/eurocodepy/ec5/sls/vibration/#eurocodepy.ec5.sls.vibration.a_from_b--parameters","title":"Parameters","text":"<p>b : float     The input value for which to interpolate the corresponding 'a'.</p>"},{"location":"reference/eurocodepy/ec5/sls/vibration/#eurocodepy.ec5.sls.vibration.a_from_b--returns","title":"Returns","text":"<p>float     The interpolated 'a' value.</p> Source code in <code>eurocodepy/ec5/sls/vibration.py</code> <pre><code>def a_from_b(b: float) -&gt; float:\n    \"\"\"Interpolates and returns the corresponding 'a' value for a given 'b' using predefined arrays.\n\n    Parameters\n    ----------\n    b : float\n        The input value for which to interpolate the corresponding 'a'.\n\n    Returns\n    -------\n    float\n        The interpolated 'a' value.\n\n    \"\"\"\n    return np.interp(b, np.flip(bval), aval)\n</code></pre>"},{"location":"reference/eurocodepy/ec5/sls/vibration/#eurocodepy.ec5.sls.vibration.b_from_a","title":"<code>b_from_a(a)</code>","text":"<p>Interpolates and returns the corresponding 'b' value for a given 'a' using predefined arrays.</p>"},{"location":"reference/eurocodepy/ec5/sls/vibration/#eurocodepy.ec5.sls.vibration.b_from_a--parameters","title":"Parameters","text":"<p>a : float     The input value for which to interpolate the corresponding 'b'.</p>"},{"location":"reference/eurocodepy/ec5/sls/vibration/#eurocodepy.ec5.sls.vibration.b_from_a--returns","title":"Returns","text":"<p>float     The interpolated 'b' value.</p> Source code in <code>eurocodepy/ec5/sls/vibration.py</code> <pre><code>def b_from_a(a: float) -&gt; float:\n    \"\"\"Interpolates and returns the corresponding 'b' value for a given 'a' using predefined arrays.\n\n    Parameters\n    ----------\n    a : float\n        The input value for which to interpolate the corresponding 'b'.\n\n    Returns\n    -------\n    float\n        The interpolated 'b' value.\n\n    \"\"\"\n    return np.interp(a, aval, bval)\n</code></pre>"},{"location":"reference/eurocodepy/ec5/sls/vibration/#eurocodepy.ec5.sls.vibration.floor_freq","title":"<code>floor_freq(l, EI, m)</code>","text":"<p>Calculate the floor fundamental frequency.</p>"},{"location":"reference/eurocodepy/ec5/sls/vibration/#eurocodepy.ec5.sls.vibration.floor_freq--parameters","title":"Parameters","text":"<p>l : float     Span length. EI : float     Flexural rigidity. m : float     Mass per unit length.</p>"},{"location":"reference/eurocodepy/ec5/sls/vibration/#eurocodepy.ec5.sls.vibration.floor_freq--returns","title":"Returns","text":"<p>float     The fundamental frequency of the floor.</p> Source code in <code>eurocodepy/ec5/sls/vibration.py</code> <pre><code>def floor_freq(l: float, EI: float, m: float) -&gt; float:\n    \"\"\"Calculate the floor fundamental frequency.\n\n    Parameters\n    ----------\n    l : float\n        Span length.\n    EI : float\n        Flexural rigidity.\n    m : float\n        Mass per unit length.\n\n    Returns\n    -------\n    float\n        The fundamental frequency of the floor.\n    \"\"\"\n    return (np.pi / 2 / l**2) * np.sqrt(EI / m)\n</code></pre>"},{"location":"reference/eurocodepy/ec5/sls/vibration/#eurocodepy.ec5.sls.vibration.vel","title":"<code>vel(f1, b, l, m, EIl, EIt)</code>","text":"<p>Calculate the velocity response factor for a floor subjected to vibration, based on Eurocode 5 SLS criteria.</p>"},{"location":"reference/eurocodepy/ec5/sls/vibration/#eurocodepy.ec5.sls.vibration.vel--parameters","title":"Parameters","text":"<pre><code>f1 (float): Fundamental frequency of the floor (Hz).\nb (float): Width of the floor (m).\nl (float): Span length of the floor (m).\nm (float): Mass per unit area of the floor (kg/m^2).\nEIl (float): Bending stiffness of the floor in the longitudinal direction (Nm^2).\nEIt (float): Bending stiffness of the floor in the transverse direction (Nm^2).\n</code></pre>"},{"location":"reference/eurocodepy/ec5/sls/vibration/#eurocodepy.ec5.sls.vibration.vel--returns","title":"Returns","text":"<pre><code>float: Velocity response factor (m/(Ns)), representing the floor's vibration response.\n</code></pre>"},{"location":"reference/eurocodepy/ec5/sls/vibration/#eurocodepy.ec5.sls.vibration.vel--notes","title":"Notes","text":"<pre><code>The formula is based on the simplified method for vibration assessment in Eurocode 5.\n</code></pre> Source code in <code>eurocodepy/ec5/sls/vibration.py</code> <pre><code>def vel(f1: float, b: float, l: float, m: float, EIl: float, EIt: float):\n    \"\"\"Calculate the velocity response factor for a floor subjected to vibration, based on Eurocode 5 SLS criteria.\n\n    Parameters\n    ----------\n        f1 (float): Fundamental frequency of the floor (Hz).\n        b (float): Width of the floor (m).\n        l (float): Span length of the floor (m).\n        m (float): Mass per unit area of the floor (kg/m^2).\n        EIl (float): Bending stiffness of the floor in the longitudinal direction (Nm^2).\n        EIt (float): Bending stiffness of the floor in the transverse direction (Nm^2).\n\n    Returns\n    -------\n        float: Velocity response factor (m/(Ns)), representing the floor's vibration response.\n\n    Notes\n    -----\n        The formula is based on the simplified method for vibration assessment in Eurocode 5.\n\n    \"\"\"\n    n40 = np.pow(((40 / f1)**2 - 1.0) * ((b / l)**4) * (EIl / EIt), 0.25)\n    return 4 * (0.4 + 0.6 * n40) / (m * b * l + 200)\n</code></pre>"},{"location":"reference/eurocodepy/ec5/sls/vibration/#eurocodepy.ec5.sls.vibration.vlim","title":"<code>vlim(f1, b, damp)</code>","text":"<p>Calculate the vibration limit value based on frequency, width, and damping.</p>"},{"location":"reference/eurocodepy/ec5/sls/vibration/#eurocodepy.ec5.sls.vibration.vlim--parameters","title":"Parameters","text":"<p>f1 : float     The fundamental frequency. b : float     The width parameter. damp : float     The damping factor.</p>"},{"location":"reference/eurocodepy/ec5/sls/vibration/#eurocodepy.ec5.sls.vibration.vlim--returns","title":"Returns","text":"<p>float     The calculated vibration limit value.</p> Source code in <code>eurocodepy/ec5/sls/vibration.py</code> <pre><code>def vlim(f1: float, b: float, damp: float) -&gt; float:\n    \"\"\"Calculate the vibration limit value based on frequency, width, and damping.\n\n    Parameters\n    ----------\n    f1 : float\n        The fundamental frequency.\n    b : float\n        The width parameter.\n    damp : float\n        The damping factor.\n\n    Returns\n    -------\n    float\n        The calculated vibration limit value.\n\n    \"\"\"\n    return np.pow(b, f1 * damp - 1.0)\n</code></pre>"},{"location":"reference/eurocodepy/ec7/","title":"ec7","text":"<p>Eurocode 7 - Geotechnical design module.</p> <p>This module provides functions and classes for geotechnical design according to Eurocode 7 (EN 1997-1:2004). It includes calculations for bearing capacity, earth pressures, and other geotechnical parameters.</p>"},{"location":"reference/eurocodepy/ec7/bearing_capacity/","title":"bearing_capacity","text":"<p>Soil Bearing Resistance Module.</p> <p>This module provides functions to calculate the ultimate bearing capacity and factor of safety for shallow foundations based on classical geotechnical engineering methods such as Terzaghi's theory.</p> <p>Currently supported:</p> <ul> <li>Ultimate bearing capacity using EC7 method</li> <li>Ultimate bearing capacity for seismic loads using EC7 method</li> </ul>"},{"location":"reference/eurocodepy/ec7/bearing_capacity/#eurocodepy.ec7.bearing_capacity.bearing_resistance","title":"<code>bearing_resistance(Bx, By, Hx, Hy, N, phi, gamma, q, c=0, drained=True)</code>","text":"<p>Calculate the bearing capacity of a shallow foundation (EN 1997-1:2004).</p> <p>Parameters:</p> Name Type Description Default <code>Bx</code> <code>float or ndarray</code> <p>effective width of the foundation</p> required <code>By</code> <code>float or ndarray</code> <p>effective length of the foundation</p> required <code>Hx</code> <code>float or ndarray</code> <p>horizontal load in X direction on the foundation</p> required <code>Hy</code> <code>float or ndarray</code> <p>horizontal load in Y direction on the foundation</p> required <code>q</code> <code>float or ndarray</code> <p>vertical load outside the foundation</p> required <code>phi</code> <code>float or ndarray</code> <p>effective soil friction angle</p> required <code>gamma</code> <code>float or ndarray</code> <p>unit weight of the soil</p> required <code>N</code> <code>float or ndarray</code> <p>vertical load on the foundation</p> required <code>c</code> <code>int or ndarray</code> <p>effective cohesion. Defaults to 0.</p> <code>0</code> <code>drained</code> <code>bool</code> <p>drained or undrained conditions. if undrained c = cu. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>float</code> <p>float or numpy.ndarray: the bearing capacity of the foundation</p> Source code in <code>eurocodepy/ec7/bearing_capacity.py</code> <pre><code>def bearing_resistance(Bx: float, By: float, Hx: float, Hy: float, N: float,\n            phi: float, gamma: float, q: float, c: float = 0,\n            drained: bool = True) -&gt; float:\n    \"\"\"Calculate the bearing capacity of a shallow foundation (EN 1997-1:2004).\n\n    Args:\n        Bx (float or numpy.ndarray): effective width of the foundation\n        By (float or numpy.ndarray): effective length of the foundation\n        Hx (float or numpy.ndarray): horizontal load in X direction on the foundation\n        Hy (float or numpy.ndarray): horizontal load in Y direction on the foundation\n        q (float or numpy.ndarray): vertical load outside the foundation\n        phi (float or numpy.ndarray): effective soil friction angle\n        gamma (float or numpy.ndarray): unit weight of the soil\n        N (float or numpy.ndarray): vertical load on the foundation\n        c (int or numpy.ndarray, optional): effective cohesion. Defaults to 0.\n        drained (bool, optional): drained or undrained conditions. if undrained c = cu. Defaults to True.\n\n    Returns:\n        float or numpy.ndarray: the bearing capacity of the foundation \n\n    \"\"\"\n    bearing = 0.0\n    area = Bx * By\n\n    B = np.where(Bx &lt;= By, Bx, By)\n    L = np.where(Bx &lt;= By, By, Bx)\n    theta = np.where(Bx &lt;= By, np.arctan2(Hx, Hy), np.arctan2(Hy, Hx))\n    H = np.sqrt(Hx**2 + Hy**2)\n\n    if drained:\n        mb = (2 + B / L) / (1 + B / L)\n        ml = (2 + L / B) / (1 + L / B)\n        m = ml * np.cos(theta)**2 + mb * np.sin(theta)**2\n\n        tanphi = np.tan(phi)\n        sinphi = np.sin(phi)\n\n        Nq = np.exp(np.pi * tanphi) * np.tan(np.pi / 4 + phi / 2)**2\n        Nc = (Nq - 1.0) / tanphi\n        Ng = 2.0 * (Nq - 1.0) * tanphi\n\n        sq = 1.0 + (B / L) * sinphi\n        sg = 1.0 - 0.3 * (B / L)\n        sc = (sq * Nq - 1.0) / (Nq - 1.0)\n\n        aux = (1.0 - H / (N + area * c / tanphi))\n        iq = aux ** m\n        ig = aux**(m + 1)\n        ic = iq - (1.0 - iq) / (Nc * tanphi)\n\n        bearing = c * Nc * sc * ic + q * Nq * sq * iq + 0.5 * gamma * B * Ng * sg * ig\n\n    else:\n        sc = 1.0 + 0.2 * (B / L)\n        aux = H / (area * c)\n        aux = min(1.0, aux)\n        ic = 0.5 * (1.0 + np.sqrt(1.0 - aux))\n        bearing = (np.pi + 2.0) * c * sc * ic + q\n\n    return bearing\n</code></pre>"},{"location":"reference/eurocodepy/ec7/bearing_capacity/#eurocodepy.ec7.bearing_capacity.seismic_bearing_resistance","title":"<code>seismic_bearing_resistance(ag, avg_ahg, S, B, H, N, M, phi, gamma_s, cu=0.0, gamma_c=1.0, gamma_rd=1.5, soil_type='incoherent')</code>","text":"<p>Calculate the bearing capacity of a shallow foundation under seismic conditioons.</p> <p>According with Eurocode 7 (EN 1997-5:2004).</p> <p>Parameters:</p> Name Type Description Default <code>ag</code> <code>float or ndarray</code> <p>soil acceleration</p> required <code>avg_ahg</code> <code>float or ndarray</code> <p>ratio between the vertical and horizontal accelerations</p> required <code>S</code> <code>float or ndarray</code> <p>seismic soil coefficient</p> required <code>B</code> <code>float or ndarray</code> <p>width of the foundation</p> required <code>H</code> <code>float or ndarray</code> <p>horizontal load in Y direction on the foundation</p> required <code>N</code> <code>float or ndarray</code> <p>vertical load on the foundation</p> required <code>M</code> <code>float or ndarray</code> <p>moment on the foundation</p> required <code>phi</code> <code>float or ndarray</code> <p>effective soil friction angle</p> required <code>gamma_s</code> <code>float or ndarray</code> <p>unit weight of the soil</p> required <code>cu</code> <code>float or ndarray</code> <p>effective cohesion. Defaults to 0.</p> <code>0.0</code> <code>gamma_c</code> <code>float or ndarray</code> <p>safety coefficient for coehesion. Defaults to 1.0</p> <code>1.0</code> <code>gamma_rd</code> <code>float or ndarray</code> <p>safety coefficient for bearing capacity. Defaults to 1.5</p> <code>1.5</code> <code>soil_type</code> <code>str</code> <p>type of soil.</p> <code>'incoherent'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: values of the bearing capacity ratio</p> Source code in <code>eurocodepy/ec7/bearing_capacity.py</code> <pre><code>def seismic_bearing_resistance(ag: float, avg_ahg: float, S: float, B: float, H: float, N: float, M: float,\n        phi: float, gamma_s: float, cu: float = 0.0, gamma_c: float = 1.0, \n        gamma_rd: float = 1.5, soil_type: str = \"incoherent\") -&gt; np.ndarray:\n    \"\"\"Calculate the bearing capacity of a shallow foundation under seismic conditioons.\n\n    According with Eurocode 7 (EN 1997-5:2004).\n\n    Args:\n        ag (float or numpy.ndarray): soil acceleration\n        avg_ahg (float or numpy.ndarray): ratio between the vertical and horizontal accelerations\n        S (float or numpy.ndarray): seismic soil coefficient\n        B (float or numpy.ndarray): width of the foundation\n        H (float or numpy.ndarray): horizontal load in Y direction on the foundation\n        N (float or numpy.ndarray): vertical load on the foundation\n        M (float or numpy.ndarray): moment on the foundation\n        phi (float or numpy.ndarray): effective soil friction angle\n        gamma_s (float or numpy.ndarray): unit weight of the soil\n        cu (float or numpy.ndarray, optional): effective cohesion. Defaults to 0.\n        gamma_c (float or numpy.ndarray, optional): safety coefficient for coehesion. Defaults to 1.0\n        gamma_rd (float or numpy.ndarray, optional): safety coefficient for bearing capacity. Defaults to 1.5\n        soil_type (str, optional): type of soil.\n\n    Returns:\n        np.ndarray: values of the bearing capacity ratio\n\n    \"\"\"\n    g = 9.80665\n    tanphi = np.tan(phi)\n    Nmax = np.array([0.0, 0.0])\n    F_ = 0.0\n\n    if soil_type == \"coherent\":\n        a = 0.7\n        b = 1.29\n        c = 2.14\n        d = 1.81\n        e = 0.21\n        f = 0.44\n        m = 0.21\n        k = 1.22\n        k_ = 1.0\n        ct = 2.0\n        cm = 2.0\n        c_m = 1.0\n        beta = 2.57\n        gamma = 1.87\n\n        F_ = gamma_s * ag * S * B / cu\n        Nq = np.exp(np.pi*tanphi)*np.tan(np.pi/4 + phi/2)**2\n        Ng = 2.0*(Nq-1.0)*tanphi\n        Nmax = np.array([(np.pi+2.0) * c * B / gamma_c])\n\n    elif soil_type == \"incoherent\":\n        a = 0.92\n        b = 1.25\n        c = 0.92\n        d = 1.25\n        e = 0.41\n        f = 0.32\n        m = 0.96\n        k = 1.0\n        k_ = 0.39\n        ct = 1.14\n        cm = 1.01\n        c_m = 1.01\n        beta = 2.9\n        gamma = 2.8\n\n        F_ = ag / (g * tanphi)\n        Nq = np.exp(np.pi*tanphi)*np.tan(np.pi/4 + phi/2)**2\n        Ng = 2.0*(Nq-1.0)*tanphi\n        Nmax = np.array([   0.5 * gamma_s * g * (1.0 + avg_ahg * ag / g) * B**2 * Ng,\n                            0.5 * gamma_s * g * (1.0 - avg_ahg * ag / g) * B**2 * Ng])\n\n    ratio = np.array([])\n    for n in Nmax:\n        N_ = gamma_rd * N / n\n        V_ = gamma_rd * H / n\n        M_ = gamma_rd * M / n\n\n        if (N_ &lt; 0.0 or (\n            (soil_type == \"incoherent\" and (1.0 - m * F_)**k_ &lt;= N_) or\n            (soil_type == \"coherent\" and N_ &gt;= 1.0))):\n            ratio.append(-1)\n            continue\n\n        val1 = (1.0 - e * F_)**ct * (beta * V_)**ct\n        val2 = N_**a * ((1.0 - m * F_**k)**k_ - N_)**b\n        val3 = (1.0 - f * F_)**c_m * (gamma * M_)**cm\n        val4 = N_**c * ((1.0 - m * F_**k)**k_ - N_)**d\n\n        ratio.append(val1 / val2 + val3 / val4 - 1.0)\n\n    return np.where(ratio &lt; 0.0, True, False)  # noqa: FBT003\n</code></pre>"},{"location":"reference/eurocodepy/ec7/earth_pressures/","title":"earth_pressures","text":""},{"location":"reference/eurocodepy/ec7/earth_pressures/#eurocodepy.ec7.earth_pressures.EarthPressureModels","title":"<code>EarthPressureModels</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of earth pressure calculation models.</p> Source code in <code>eurocodepy/ec7/earth_pressures.py</code> <pre><code>class EarthPressureModels(Enum):\n    \"\"\"Enumeration of earth pressure calculation models.\"\"\"\n\n    RANKINE = \"rankine\"\n    COULOMB = \"coulomb\"\n    EC7 = \"ec7\"\n    INREST = \"inrest\"\n</code></pre>"},{"location":"reference/eurocodepy/ec7/earth_pressures/#eurocodepy.ec7.earth_pressures.pressure_coefficients","title":"<code>pressure_coefficients(phi, delta, theta, beta, method='ec7', seismic=None, k_quake_water=1.0)</code>","text":"<p>Calculate earth pressure coefficients based on the specified method.</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>float</code> <p>friction angle of the soil (radians).</p> required <code>delta</code> <code>float</code> <p>friction angle of the wall (radians).</p> required <code>theta</code> <code>float</code> <p>slope angle of the backfill (radians).</p> required <code>betha</code> <code>float</code> <p>slope angle of the wall (radians).</p> required <code>method</code> <code>str</code> <p>calculation method for earth pressures.</p> <code>'ec7'</code> <code>seismic</code> <code>SoilSeismicParameters</code> <p>Seismic horizontal/vertical seismic</p> <code>None</code> <code>k_quake_water</code> <code>float</code> <p>water earthquake coefficient (g_d/(g-g_w)).</p> <code>1.0</code> <code>Defaults</code> <code>to 1.0</code> <p>no water.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Method not found.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>list</code> <p>pressure coefficients (Ka, Kp, Kaq, Kpq, dkas1, dkps1, dkas2, dkps2).</p> <code>list</code> <ul> <li>Ka: Active earth pressure coefficient.</li> </ul> <code>list</code> <ul> <li>Kp: Passive earth pressure coefficient.</li> </ul> <code>list</code> <ul> <li>Kaq: Active earth pressure coefficient at rest.</li> </ul> <code>list</code> <ul> <li>Kpq: Passive earth pressure coefficient at rest.</li> </ul> <code>list</code> <ul> <li>dkas1: Difference in active earth pressure coefficient for seismic case 1.</li> </ul> <code>list</code> <ul> <li>dkps1: Difference in passive earth pressure coefficient for seismic case 1.</li> </ul> <code>list</code> <ul> <li>dkas2: Difference in active earth pressure coefficient for seismic case 2.</li> </ul> <code>list</code> <ul> <li>dkps2: Difference in passive earth pressure coefficient for seismic case 2.</li> </ul> Source code in <code>eurocodepy/ec7/earth_pressures.py</code> <pre><code>def pressure_coefficients(phi: float, delta: float, theta: float,\n                beta: float, method: str | EarthPressureModels = \"ec7\",\n                seismic: SoilSeismicParameters | None = None,\n                k_quake_water: float = 1.0) -&gt; list:\n    \"\"\"Calculate earth pressure coefficients based on the specified method.\n\n    Args:\n        phi (float): friction angle of the soil (radians).\n        delta (float): friction angle of the wall (radians).\n        theta (float): slope angle of the backfill (radians).\n        betha (float): slope angle of the wall (radians).\n        method (str, optional): calculation method for earth pressures.\n        Defaults to \"ec7\".\n        seismic (SoilSeismicParameters, optional): Seismic horizontal/vertical seismic\n        coefficients. Defaults to None.\n        k_quake_water (float, optional): water earthquake coefficient (g_d/(g-g_w)).\n        Defaults to 1.0: no water.\n\n    Raises:\n        ValueError: Method not found.\n\n    Returns:\n        tuple: pressure coefficients (Ka, Kp, Kaq, Kpq, dkas1, dkps1, dkas2, dkps2).\n        - Ka: Active earth pressure coefficient.\n        - Kp: Passive earth pressure coefficient.\n        - Kaq: Active earth pressure coefficient at rest.\n        - Kpq: Passive earth pressure coefficient at rest.\n        - dkas1: Difference in active earth pressure coefficient for seismic case 1.\n        - dkps1: Difference in passive earth pressure coefficient for seismic case 1.\n        - dkas2: Difference in active earth pressure coefficient for seismic case 2.\n        - dkps2: Difference in passive earth pressure coefficient for seismic case 2.\n\n    \"\"\"\n    method = method.lower() if isinstance(method, str) else method.value\n    if method == \"ec7\":\n        Ka, Kp, Kaq, Kpq, Kac, Kpc = _ec7_coefficient(phi, delta, theta, beta)\n    elif method == \"rankine\":\n        Ka, Kp = _rankine_coefficient(phi, beta)\n        Kaq = Ka\n        Kpq = Kp\n    elif method == \"coulomb\":\n        Ka, Kp = _coulomb_coefficient(phi, delta, theta, beta)\n        Kaq = Ka\n        Kpq = Kp\n    elif method == \"inrest\":\n        Ka, Kp = _inrest_coefficient(phi, beta)\n        Kaq = Ka\n        Kpq = Kp\n    else:\n        msg = \"Method not found\"\n        raise ValueError(msg)\n\n    kas1 = 0.0\n    kas2 = 0.0\n    kps1 = 0.0\n    kps2 = 0.0\n    dkas1 = 0.0\n    dkas2 = 0.0\n    dkps1 = 0.0\n    dkps2 = 0.0\n    if seismic is not None:\n        kas1, kps1, kas2, kps2 = _earthquake_coefficient(phi, delta, theta, beta, seismic.kh, seismic.kv, k_quake_water)\n        dkas1 = (1.0 + seismic.kv) * kas1 - Ka\n        dkas2 = (1.0 - seismic.kv) * kas2 - Ka\n        dkps1 = Kp - (1.0 + seismic.kv) * kps1\n        dkps2 = Kp - (1.0 - seismic.kv) * kps2\n\n    return [Ka, Kp, Kaq, Kpq, dkas1, dkps1, dkas2, dkps2]\n</code></pre>"},{"location":"reference/eurocodepy/ec7/materials/","title":"materials","text":""},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.Soil","title":"<code>Soil</code>  <code>dataclass</code>","text":"<p>Soil class to hold soil properties for geotechnical calculations.</p> <p>Attributes:</p> Name Type Description <code>unit_weight</code> <code>float</code> <p>Unit weight of the soil in kN/m\u00b3.</p> <code>friction_angle</code> <code>float</code> <p>Effective angle of internal friction in degrees</p> <code>conc_friction_angle</code> <code>float</code> <p>Angle of soil/concrete friction in degrees</p> <code>sig_adm</code> <code>float</code> <p>Admissible stress in kPa. Defaults to 200 kPa.</p> <code>c</code> <code>int or ndarray</code> <p>effective cohesion. Defaults to 0.</p> <code>drained</code> <code>bool</code> <p>drained or undrained conditions.</p> Source code in <code>eurocodepy/ec7/materials.py</code> <pre><code>@dataclass\nclass Soil:\n    \"\"\"Soil class to hold soil properties for geotechnical calculations.\n\n    Attributes:\n        unit_weight (float): Unit weight of the soil in kN/m\u00b3.\n        friction_angle (float): Effective angle of internal friction in degrees\n        (converted to radians).\n        conc_friction_angle (float): Angle of soil/concrete friction in degrees\n        (converted to radians).\n        sig_adm (float): Admissible stress in kPa. Defaults to 200 kPa.\n        c (int or numpy.ndarray): effective cohesion. Defaults to 0.\n        drained (bool, optional): drained or undrained conditions.\n        if undrained c = cu. Defaults to True.\n\n    \"\"\"\n\n    name: str = \"Soil\"\n    unit_weight: float = 18.0  # Unit weight in kN/m\u00b3, default is 18 kN/m\u00b3\n    friction_angle: float = 30.0  # Input in degrees, default is 30 degrees\n    conc_friction_angle: float = 20.0  # Input in degrees, default is 20 degrees\n    sig_adm: float = 200.0  # Admissible stress in kPa, default is 200 kPa\n    sig_rd: float = 300.0  # Maximum design resistance stress in kPa, default is 300 kPa\n    cohesion: float = 0.0  # Effective cohesion in kPa, default is 0\n    is_drained: bool = True  # Drained condition, default is True\n    is_coherent: bool = False  # Whether the soil is cohesive, default is False\n    young: float = 30.0  # Young modulus in MPa\n    poiss: float = 0.3  # Poisson coefficient\n    ks: float = 30000  # modulus of subgrade reaction kN/m3\n\n    def __post_init__(self) -&gt; None:\n        self.friction_angle = np.radians(self.friction_angle)\n        self.conc_friction_angle = np.radians(self.conc_friction_angle)\n        if self.cohesion &gt; 0:\n            self.is_coherent = True\n\n    @staticmethod\n    def get_es_from_spt(nspt: float) -&gt; float:\n        \"\"\"Estimate Young's modulus (Es) from SPT value.\n\n        Parameters\n        ----------\n        nspt : float\n            Standard Penetration Test (SPT) value.\n\n        Returns\n        -------\n        float\n            Estimated Young's modulus (Es).\n\n        \"\"\"\n        return nspt\n\n    @staticmethod\n    def get_sigadm_from_spt(nspt: float) -&gt; float:\n        \"\"\"Estimate admissible stress from SPT (Standard Penetration Test) value.\n\n        Parameters\n        ----------\n        nspt : float\n            Standard Penetration Test (SPT) value.\n\n        Returns\n        -------\n        float\n            Estimated admissible stress in kPa.\n\n        \"\"\"\n        return nspt\n\n    @staticmethod\n    def get_sigadm_from_cpt(nspt: float) -&gt; float:\n        \"\"\"Estimate admissible stress from CPT (Cone Penetration Test) value.\n\n        Parameters\n        ----------\n        nspt : float\n            CPT value.\n\n        Returns\n        -------\n        float\n            Estimated admissible stress in kPa.\n\n        \"\"\"\n        return nspt\n\n    @staticmethod\n    def get_ks_from_spt(nspt: float) -&gt; float:\n        \"\"\"Estimate modulus of subgrade reaction (ks) from SPT value.\n\n        Parameters\n        ----------\n        nspt : float\n            Standard Penetration Test (SPT) value.\n\n        Returns\n        -------\n        float\n            Estimated modulus of subgrade reaction in kN/m\u00b3.\n\n        \"\"\"\n        return nspt\n\n    @staticmethod\n    def get_ks_from_es(es: float) -&gt; float:\n        \"\"\"Estimate modulus of subgrade reaction (ks) from Young's modulus (Es).\n\n        Parameters\n        ----------\n        es : float\n            Young's modulus in MPa.\n\n        Returns\n        -------\n        float\n            Estimated modulus of subgrade reaction in kN/m\u00b3.\n\n        \"\"\"\n        return es\n</code></pre>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.Soil.get_es_from_spt","title":"<code>get_es_from_spt(nspt)</code>  <code>staticmethod</code>","text":"<p>Estimate Young's modulus (Es) from SPT value.</p>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.Soil.get_es_from_spt--parameters","title":"Parameters","text":"<p>nspt : float     Standard Penetration Test (SPT) value.</p>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.Soil.get_es_from_spt--returns","title":"Returns","text":"<p>float     Estimated Young's modulus (Es).</p> Source code in <code>eurocodepy/ec7/materials.py</code> <pre><code>@staticmethod\ndef get_es_from_spt(nspt: float) -&gt; float:\n    \"\"\"Estimate Young's modulus (Es) from SPT value.\n\n    Parameters\n    ----------\n    nspt : float\n        Standard Penetration Test (SPT) value.\n\n    Returns\n    -------\n    float\n        Estimated Young's modulus (Es).\n\n    \"\"\"\n    return nspt\n</code></pre>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.Soil.get_ks_from_es","title":"<code>get_ks_from_es(es)</code>  <code>staticmethod</code>","text":"<p>Estimate modulus of subgrade reaction (ks) from Young's modulus (Es).</p>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.Soil.get_ks_from_es--parameters","title":"Parameters","text":"<p>es : float     Young's modulus in MPa.</p>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.Soil.get_ks_from_es--returns","title":"Returns","text":"<p>float     Estimated modulus of subgrade reaction in kN/m\u00b3.</p> Source code in <code>eurocodepy/ec7/materials.py</code> <pre><code>@staticmethod\ndef get_ks_from_es(es: float) -&gt; float:\n    \"\"\"Estimate modulus of subgrade reaction (ks) from Young's modulus (Es).\n\n    Parameters\n    ----------\n    es : float\n        Young's modulus in MPa.\n\n    Returns\n    -------\n    float\n        Estimated modulus of subgrade reaction in kN/m\u00b3.\n\n    \"\"\"\n    return es\n</code></pre>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.Soil.get_ks_from_spt","title":"<code>get_ks_from_spt(nspt)</code>  <code>staticmethod</code>","text":"<p>Estimate modulus of subgrade reaction (ks) from SPT value.</p>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.Soil.get_ks_from_spt--parameters","title":"Parameters","text":"<p>nspt : float     Standard Penetration Test (SPT) value.</p>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.Soil.get_ks_from_spt--returns","title":"Returns","text":"<p>float     Estimated modulus of subgrade reaction in kN/m\u00b3.</p> Source code in <code>eurocodepy/ec7/materials.py</code> <pre><code>@staticmethod\ndef get_ks_from_spt(nspt: float) -&gt; float:\n    \"\"\"Estimate modulus of subgrade reaction (ks) from SPT value.\n\n    Parameters\n    ----------\n    nspt : float\n        Standard Penetration Test (SPT) value.\n\n    Returns\n    -------\n    float\n        Estimated modulus of subgrade reaction in kN/m\u00b3.\n\n    \"\"\"\n    return nspt\n</code></pre>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.Soil.get_sigadm_from_cpt","title":"<code>get_sigadm_from_cpt(nspt)</code>  <code>staticmethod</code>","text":"<p>Estimate admissible stress from CPT (Cone Penetration Test) value.</p>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.Soil.get_sigadm_from_cpt--parameters","title":"Parameters","text":"<p>nspt : float     CPT value.</p>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.Soil.get_sigadm_from_cpt--returns","title":"Returns","text":"<p>float     Estimated admissible stress in kPa.</p> Source code in <code>eurocodepy/ec7/materials.py</code> <pre><code>@staticmethod\ndef get_sigadm_from_cpt(nspt: float) -&gt; float:\n    \"\"\"Estimate admissible stress from CPT (Cone Penetration Test) value.\n\n    Parameters\n    ----------\n    nspt : float\n        CPT value.\n\n    Returns\n    -------\n    float\n        Estimated admissible stress in kPa.\n\n    \"\"\"\n    return nspt\n</code></pre>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.Soil.get_sigadm_from_spt","title":"<code>get_sigadm_from_spt(nspt)</code>  <code>staticmethod</code>","text":"<p>Estimate admissible stress from SPT (Standard Penetration Test) value.</p>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.Soil.get_sigadm_from_spt--parameters","title":"Parameters","text":"<p>nspt : float     Standard Penetration Test (SPT) value.</p>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.Soil.get_sigadm_from_spt--returns","title":"Returns","text":"<p>float     Estimated admissible stress in kPa.</p> Source code in <code>eurocodepy/ec7/materials.py</code> <pre><code>@staticmethod\ndef get_sigadm_from_spt(nspt: float) -&gt; float:\n    \"\"\"Estimate admissible stress from SPT (Standard Penetration Test) value.\n\n    Parameters\n    ----------\n    nspt : float\n        Standard Penetration Test (SPT) value.\n\n    Returns\n    -------\n    float\n        Estimated admissible stress in kPa.\n\n    \"\"\"\n    return nspt\n</code></pre>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.SoilEnum","title":"<code>SoilEnum</code>","text":"<p>Enumeration of typical soil types with predefined properties.</p> <p>Attributes:</p> Name Type Description <code>Sand</code> <code>Soil</code> <p>Typical sand soil properties.</p> <code>Clay</code> <code>Soil</code> <p>Typical clay soil properties.</p> <code>Gravel</code> <code>Soil</code> <p>Typical gravel soil properties.</p> <code>Rock</code> <code>Soil</code> <p>Typical rock soil properties.</p> Source code in <code>eurocodepy/ec7/materials.py</code> <pre><code>class SoilEnum:\n    \"\"\"Enumeration of typical soil types with predefined properties.\n\n    Attributes:\n        Sand (Soil): Typical sand soil properties.\n        Clay (Soil): Typical clay soil properties.\n        Gravel (Soil): Typical gravel soil properties.\n        Rock (Soil): Typical rock soil properties.\n\n    \"\"\"\n\n    Sand = Soil(name=\"Sand\", unit_weight=18.0, friction_angle=30.0,\n                conc_friction_angle=20.0, sig_adm=200.0, cohesion=0.0, is_drained=True)\n    Clay = Soil(name=\"Clay\", unit_weight=18.0, friction_angle=20.0,\n                conc_friction_angle=15.0, sig_adm=200., cohesion=50.0, is_drained=False)\n    Gravel = Soil(name=\"Gravel\", unit_weight=20.0, friction_angle=35.0,\n                conc_friction_angle=25.0, sig_adm=250.0, cohesion=0.0, is_drained=True)\n    Rock = Soil(name=\"Rock\", unit_weight=25.0, friction_angle=40.0,\n                conc_friction_angle=30.0, sig_adm=500., cohesion=100.0, is_drained=True)\n</code></pre>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.SoilSafetyFactors","title":"<code>SoilSafetyFactors</code>  <code>dataclass</code>","text":"<p>Soil safety factors for geotechnical design.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>name of the soil safety factor set (\"STR/GEO\", \"EQU\", \"ACC STR/GEO\")</p> <code>casetype</code> <code>str</code> <p>type of case (e.g., \"SLS\", \"ULS\", \"ACC\")</p> <code>case</code> <code>str</code> <p>specific case description (e.g., \"STR/GEO\", \"EQU\", \"ACC\")</p> <code>gamma</code> <code>float</code> <p>partial safety factor for weight</p> <code>phi</code> <code>float</code> <p>partial safety factor for angle of internal friction</p> <code>c</code> <code>float</code> <p>partial safety factor for effective cohesion</p> <code>cu</code> <code>float</code> <p>partial safety factor for undrained shear strength</p> <code>perm_unfav</code> <code>float</code> <p>unfavourable permanent load factor</p> <code>perm_fav</code> <code>float</code> <p>favourable permanent load factor</p> <code>var_unfav</code> <code>float</code> <p>unfavourable variable load factor</p> <code>var_fav</code> <code>float</code> <p>favourable variable load factor</p> <code>slide</code> <code>float</code> <p>sliding resistance factor</p> <code>bearing</code> <code>float</code> <p>bearing resistance factor</p> Source code in <code>eurocodepy/ec7/materials.py</code> <pre><code>@dataclass\nclass SoilSafetyFactors:\n    \"\"\"Soil safety factors for geotechnical design.\n\n    Attributes:\n        name (str): name of the soil safety factor set (\"STR/GEO\", \"EQU\", \"ACC STR/GEO\")\n        casetype (str): type of case (e.g., \"SLS\", \"ULS\", \"ACC\")\n        case (str): specific case description (e.g., \"STR/GEO\", \"EQU\", \"ACC\")\n        gamma (float): partial safety factor for weight\n        phi (float): partial safety factor for angle of internal friction\n        c (float): partial safety factor for effective cohesion\n        cu (float): partial safety factor for undrained shear strength\n        perm_unfav (float): unfavourable permanent load factor\n        perm_fav (float): favourable permanent load factor\n        var_unfav (float): unfavourable variable load factor\n        var_fav (float): favourable variable load factor\n        slide (float): sliding resistance factor\n        bearing (float): bearing resistance factor\n\n    \"\"\"\n\n    name: str\n    casetype: str\n    case: str\n    gamma: float\n    phi: float\n    c: float\n    cu: float\n    perm_unfav: float\n    perm_fav: float\n    var_unfav: float\n    var_fav: float\n    slide: float\n    bearing: float\n</code></pre>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.SoilSafetyFactorsEnum","title":"<code>SoilSafetyFactorsEnum</code>","text":"<p>Enum for soil safety factors based on Eurocode 7.</p> Source code in <code>eurocodepy/ec7/materials.py</code> <pre><code>class SoilSafetyFactorsEnum:\n    \"\"\"Enum for soil safety factors based on Eurocode 7.\"\"\"\n\n    STRGEO_SLS = SoilSafetyFactors(\"STR/GEO\", \"SLS\", \"STR/GEO\",\n        1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0)\n    STRGEO_A1 = SoilSafetyFactors(\"STR/GEO A1\", \"ULS\", \"STR/GEO\",\n        1.0, 1.0, 1.0, 1.0, 1.35, 1.0, 1.5, 0.0, 1.0, 1.0)\n    STRGEO_A2 = SoilSafetyFactors(\"STR/GEO A2\", \"ULS\", \"STR/GEO\",\n        1.0, 1.25, 1.25, 1.4, 1.0, 1.0, 1.3, 0.0, 1.0, 1.0)\n    STRGEO_B = SoilSafetyFactors(\"STR/GEO B\", \"ULS\", \"STR/GEO\",\n        1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.5, 0.0, 1.1, 1.4)\n    STRGEO_C = SoilSafetyFactors(\"STR/GEO C\", \"ULS\", \"STR/GEO\",\n        1.0, 1.25, 1.25, 1.4, 1.0, 1.0, 1.5, 0.0, 1.0, 1.0)\n    STRGEO_ACC = SoilSafetyFactors(\"ACC STR/GEO\", \"ACC\", \"STR/GEO\",\n        1.0, 1.1, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0)\n    EQU = SoilSafetyFactors(\"EQU\", \"ULS\", \"EQU\",\n        1.0, 1.25, 1.25, 1.4, 1.1, 0.9, 1.5, 0.0, 1.0, 1.0)\n    EQU_ACC = SoilSafetyFactors(\"ACC EQU\", \"ACC\", \"EQU\",\n        1.0, 1.0, 1.0, 1.25, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0)\n</code></pre>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.SoilSeismicParameters","title":"<code>SoilSeismicParameters</code>","text":"<p>Seismic parameters for soil based on Eurocode 8.</p> <p>Parameters:</p> Name Type Description Default <code>spectrum</code> <code>str</code> <p>name of the seismic spectrum (e.g., \"PT1\", \"PT2\", \"CEN1\", ...)</p> required <code>agR</code> <code>float</code> <p>ground acceleration in m/s\u00b2</p> required <code>s_max</code> <code>float</code> <p>maximum spectral acceleration</p> required <code>importance_coeff</code> <code>float</code> <p>importance coefficient for the structure</p> required <code>avg_ahg</code> <code>float</code> <p>ratio vertical/horizontal acceleration</p> required <code>r</code> <code>float</code> <p>response reduction factor. Defaults to 1.0.</p> <code>1.0</code> Notes <p>r=2.0 - Free gravity walls that can accept a displacement dr = 300 a\u22c5S (mm) r=1.5 - Free gravity walls that can accept a displacement dr = 200 a\u22c5S (mm) r=1.0 - Flexural reinforced concrete walls, anchored or braced walls, reinforced concrete walls founded on vertical piles, restrained basement walls and bridge abutments</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>name of the seismic spectrum</p> <code>r</code> <code>float</code> <p>response reduction factor</p> <code>agr</code> <code>float</code> <p>ground acceleration in m/s\u00b2</p> <code>s_max</code> <code>float</code> <p>Maximum spectral acceleration.</p> <code>alpha</code> <code>float</code> <p>normalized ground acceleration (ag / 9.80665)</p> <code>smax</code> <code>float</code> <p>maximum spectral acceleration</p> <code>importance_coeff</code> <code>float</code> <p>importance coefficient</p> <code>avg_ahg</code> <code>float</code> <p>ratio of vertical to horizontal acceleration</p> <code>kh</code> <code>float</code> <p>horizontal seismic coefficient</p> <code>kv</code> <code>float</code> <p>vertical seismic coefficient</p> <code>r</code> <code>float</code> <p>Response reduction factor. Defaults to 1.0.</p> Source code in <code>eurocodepy/ec7/materials.py</code> <pre><code>class SoilSeismicParameters:\n    \"\"\"Seismic parameters for soil based on Eurocode 8.\n\n    Args:\n        spectrum (str): name of the seismic spectrum (e.g., \"PT1\", \"PT2\", \"CEN1\", ...)\n        agR (float): ground acceleration in m/s\u00b2\n        s_max (float): maximum spectral acceleration\n        importance_coeff (float): importance coefficient for the structure\n        avg_ahg (float): ratio vertical/horizontal acceleration\n        r (float, optional): response reduction factor. Defaults to 1.0.\n\n    Notes:\n        r=2.0 - Free gravity walls that can accept a displacement dr = 300 a\u22c5S (mm)\n        r=1.5 - Free gravity walls that can accept a displacement dr = 200 a\u22c5S (mm)\n        r=1.0 - Flexural reinforced concrete walls, anchored or braced walls, reinforced\n        concrete walls founded on vertical piles, restrained basement walls and bridge\n        abutments\n\n    Attributes:\n        name (str): name of the seismic spectrum\n        r (float): response reduction factor\n        agr (float): ground acceleration in m/s\u00b2\n        s_max (float): Maximum spectral acceleration.\n        alpha (float): normalized ground acceleration (ag / 9.80665)\n        smax (float): maximum spectral acceleration\n        importance_coeff (float): importance coefficient\n        avg_ahg (float): ratio of vertical to horizontal acceleration\n        kh (float): horizontal seismic coefficient\n        kv (float): vertical seismic coefficient\n        r (float, optional): Response reduction factor. Defaults to 1.0.\n\n    \"\"\"\n\n    def __init__(self, name: str, agr: float, s_max: float,\n                avg_ahg: float, r: float = 1.0) -&gt; None:\n        self.name = name\n        self.r = r\n        self._ag = agr\n        self.smax = s_max\n        self.avg_ahg = avg_ahg\n        self.alpha = agr / 9.80665\n        self._S = np.maximum(1, np.minimum(s_max, s_max - (s_max - 1) * (agr - 1) / 3))\n        self._kh = self.alpha * self.smax / self.r\n        self._kv = 0.5 * self.kh if self.avg_ahg &gt; 0.6 else 0.33 * self._kh\n\n    @property\n    def kh(self) -&gt; float:\n        \"\"\"Return the horizontal seismic coefficient (kh).\"\"\"\n        return self._kh\n\n    @property\n    def kv(self) -&gt; float:\n        \"\"\"Return the vertical seismic coefficient (kv).\"\"\"\n        return self._kv\n\n    @property\n    def ag(self) -&gt; float:\n        \"\"\"Return the ground acceleration (ag) in m/s\u00b2.\"\"\"\n        return self._ag\n\n    @property\n    def s(self) -&gt; float:\n        \"\"\"Return the soil spectral scale factor (S).\"\"\"\n        return self._S\n</code></pre>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.SoilSeismicParameters.ag","title":"<code>ag</code>  <code>property</code>","text":"<p>Return the ground acceleration (ag) in m/s\u00b2.</p>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.SoilSeismicParameters.kh","title":"<code>kh</code>  <code>property</code>","text":"<p>Return the horizontal seismic coefficient (kh).</p>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.SoilSeismicParameters.kv","title":"<code>kv</code>  <code>property</code>","text":"<p>Return the vertical seismic coefficient (kv).</p>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.SoilSeismicParameters.s","title":"<code>s</code>  <code>property</code>","text":"<p>Return the soil spectral scale factor (S).</p>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.SoilSurcharge","title":"<code>SoilSurcharge</code>  <code>dataclass</code>","text":"<p>Soil surcharge load parameters.</p> <p>Attributes:</p> Name Type Description <code>q</code> <code>float</code> <p>surcharge load in kN/m\u00b2</p> <code>psi0</code> <code>float</code> <p>coefficient for vertical stress at depth z=0</p> <code>psi1</code> <code>float</code> <p>coefficient for vertical stress at depth z=1</p> <code>psi2</code> <code>float</code> <p>coefficient for vertical stress at depth z=2</p> Source code in <code>eurocodepy/ec7/materials.py</code> <pre><code>@dataclass\nclass SoilSurcharge:\n    \"\"\"Soil surcharge load parameters.\n\n    Attributes:\n        q (float): surcharge load in kN/m\u00b2\n        psi0 (float): coefficient for vertical stress at depth z=0\n        psi1 (float): coefficient for vertical stress at depth z=1\n        psi2 (float): coefficient for vertical stress at depth z=2\n\n    \"\"\"\n\n    q: float = 10.0\n    psi0: float = 0.6\n    psi1: float = 0.4\n    psi2: float = 0.2\n</code></pre>"},{"location":"reference/eurocodepy/ec7/materials/#eurocodepy.ec7.materials.get_soil_seismic_parameters","title":"<code>get_soil_seismic_parameters(name, code, soil, imp_class, spectrum, zone)</code>","text":"<p>Set the parameters for the seismic action 1 and 2.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the seismic action (e.g., \"S1\", \"S2\")</p> required <code>code</code> <code>str</code> <p>country (EU, PT)</p> required <code>soil</code> <code>str</code> <p>type of soil (A, B, C, D, E)</p> required <code>imp_class</code> <code>str</code> <p>importance class (i, ii, iii, iv)</p> required <code>spectrum</code> <code>str</code> <p>spectrum name (for PT: PT1, PT2, PTA)                         (for EU: CEN1, CEN2)</p> required <code>zone</code> <code>str</code> <p>seismic zone 1 (for PT: 1_1, 1_2, 1_3, 2_4, 2_5, 2_6, ...)                         (for EU: _1g, _2g ...)</p> required <code>r</code> <code>float</code> <p>response reduction factor. Defaults to 1.0.</p> required <p>Returns:</p> Name Type Description <code>SoilSeismicParameters</code> <code>SoilSeismicParameters</code> <p>object containing seismic parameters</p> Notes <p>r=2.0 - Free gravity walls that can accept a displacement dr = 300 a\u22c5S (mm)</p> <p>return SoilSeismicParameters(     name=name,     agR=ag,     s_max=smax,     importance_coeff=impcoef,     avg_ahg=agvagh )     r=1.0 - Flexural reinforced concrete walls, anchored or braced walls, reinforced     concrete walls founded on vertical piles, restrained basement walls and bridge     abutments</p> Source code in <code>eurocodepy/ec7/materials.py</code> <pre><code>def get_soil_seismic_parameters(name: str, code: str, soil: str, imp_class: str,\n            spectrum: str, zone: str) -&gt; SoilSeismicParameters:\n    \"\"\"Set the parameters for the seismic action 1 and 2.\n\n    Args:\n        name (str): name of the seismic action (e.g., \"S1\", \"S2\")\n        code (str): country (EU, PT)\n        soil (str): type of soil (A, B, C, D, E)\n        imp_class (str): importance class (i, ii, iii, iv)\n        spectrum (str): spectrum name (for PT: PT1, PT2, PTA)\n                                    (for EU: CEN1, CEN2)\n        zone (str): seismic zone 1 (for PT: 1_1, 1_2, 1_3, 2_4, 2_5, 2_6, ...)\n                                    (for EU: _1g, _2g ...)\n        r (float, optional): response reduction factor. Defaults to 1.0.\n\n    Returns:\n        SoilSeismicParameters: object containing seismic parameters\n\n    Notes:\n        r=2.0 - Free gravity walls that can accept a displacement dr = 300 a\u22c5S (mm)\n    return SoilSeismicParameters(\n        name=name,\n        agR=ag,\n        s_max=smax,\n        importance_coeff=impcoef,\n        avg_ahg=agvagh\n    )\n        r=1.0 - Flexural reinforced concrete walls, anchored or braced walls, reinforced\n        concrete walls founded on vertical piles, restrained basement walls and bridge\n        abutments\n\n    \"\"\"\n    ag = dbase.Loads[\"Seismic\"][\"Locale\"][code][\"a_gR\"][spectrum][zone]\n    smax = dbase.Loads[\"Seismic\"][\"Locale\"][code][\"Spectrum\"][spectrum][soil][\"S_max\"]\n    impcoef = dbase.Loads[\"Seismic\"][\"Locale\"][code][\"ImportanceCoef\"][spectrum][imp_class]\n    agvagh = dbase.Loads[\"Seismic\"][\"Locale\"][code][\"avg_ahg\"][spectrum]\n\n    return SoilSeismicParameters(name, ag, smax, impcoef, agvagh)\n</code></pre>"},{"location":"reference/eurocodepy/ec8/","title":"ec8","text":"<p>Module that provides functions and classes for Eurocode 8 calculations.</p> <p>It includes functions for generating design response spectra, retrieving national annex parameters, and writing design response spectra to a file. It also includes classes for representing soil amplification, reference acceleration, and spectrum shape parameters.</p>"},{"location":"reference/eurocodepy/ec8/spectrum/","title":"spectrum","text":"<p>Module for Eurocode 8 Seismic Design Response Spectrum calculations.</p> <p>It includes functions for generating design response spectra, retrieving national annex parameters, and writing design response spectra to a file. It also includes classes for representing soil amplification, reference acceleration, and spectrum shape parameters.</p>"},{"location":"reference/eurocodepy/ec8/spectrum/#eurocodepy.ec8.spectrum.calc_spectrum","title":"<code>calc_spectrum(period, a_g, s_val, q, t_b, t_c, t_d, beta=0.2)</code>","text":"<p>Calculate the spectrum value for a given period, T.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>float</code> <p>period (s)</p> required <code>a_g</code> <code>float</code> <p>acceleration (m/s2)</p> required <code>s_val</code> <code>float</code> <p>soil amplification factor</p> required <code>q</code> <code>float</code> <p>behaviour factor</p> required <code>t_b</code> <code>float</code> <p>spectrum parameter</p> required <code>t_c</code> <code>float</code> <p>spectrum parameter</p> required <code>t_d</code> <code>float</code> <p>spectrum parameter</p> required <code>beta</code> <code>float</code> <p>the limiting value of the spectrum. Defaults to 0.2.</p> <code>0.2</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the spectrum value</p> Source code in <code>eurocodepy/ec8/spectrum.py</code> <pre><code>def calc_spectrum(period: float, a_g: float, s_val: float, q: float,  # noqa: PLR0913, PLR0917\n            t_b: float, t_c: float, t_d: float, beta: float = 0.2) -&gt; float:\n    \"\"\"Calculate the spectrum value for a given period, T.\n\n    Args:\n        period (float): period (s)\n        a_g (float): acceleration (m/s2)\n        s_val (float): soil amplification factor\n        q (float): behaviour factor\n        t_b (float): spectrum parameter\n        t_c (float): spectrum parameter\n        t_d (float): spectrum parameter\n        beta (float, optional): the limiting value of the spectrum. Defaults to 0.2.\n\n    Returns:\n        float: the spectrum value\n\n    \"\"\"\n    ag_s = a_g * s_val\n\n    if t_b &gt; period:\n        spec = ag_s * (2.0 / 3.0 + period / t_b * (2.5 / q - 2.0 / 3.0))\n    elif t_c &gt; period:\n        spec = ag_s * 2.5 / q\n    elif t_d &gt; period:\n        spec = max(ag_s * 2.5 / q * (t_c) / period, beta * ag_s)\n    else:\n        spec = max(ag_s * 2.5 / q * (t_c * t_d) / period**2, beta * ag_s)\n\n    return spec\n</code></pre>"},{"location":"reference/eurocodepy/ec8/spectrum/#eurocodepy.ec8.spectrum.draw_spectrum_ec8","title":"<code>draw_spectrum_ec8(spectrum, save=False, filename=None, show=True)</code>","text":"<p>Draw the spectrum using matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>spectrum</code> <code>DataFrame</code> <p>a pandas DataFrame with the spectrum data (columns: period, value)</p> required <code>save</code> <code>bool</code> <p>whether to save the plot as an image file</p> <code>False</code> <code>filename</code> <code>str | None</code> <p>the filename to use when saving the plot (if None, a default is used)</p> <code>None</code> <code>show</code> <code>bool</code> <p>whether to display the plot window</p> <code>True</code> Source code in <code>eurocodepy/ec8/spectrum.py</code> <pre><code>def draw_spectrum_ec8(spectrum: pd.DataFrame, save: bool = False,  # noqa: FBT001, FBT002\n            filename: str | None = None, show: bool = True) -&gt; None:  # noqa: FBT001, FBT002\n    \"\"\"Draw the spectrum using matplotlib.\n\n    Args:\n        spectrum (pd.DataFrame): a pandas DataFrame with the\n            spectrum data (columns: period, value)\n        save (bool): whether to save the plot as an image file\n        filename (str | None): the filename to use when saving the plot\n            (if None, a default is used)\n        show (bool): whether to display the plot window\n\n    \"\"\"\n    # plot the spectrum\n    plt.plot(spectrum[\"period\"].to_numpy(), spectrum[\"value\"].to_numpy())\n    s = (\n        spectrum.attrs[\"name\"]\n        + \":    S=\" + str(round(spectrum.attrs[\"S\"], 3))\n        + \" a_g=\" + str(round(spectrum.attrs[\"a_g\"], 3))\n        + \" q=\" + str(spectrum.attrs[\"q\"])\n    )\n    plt.title(s)\n    plt.xlabel(\"Period (s)\")\n    plt.ylabel(\"Spectrum value (m/s2)\")\n    if save:\n        if filename is None:\n            filename = s + \".png\"\n        plt.savefig(filename, dpi=300, bbox_inches=\"tight\")\n    if show:\n        plt.show()\n</code></pre>"},{"location":"reference/eurocodepy/ec8/spectrum/#eurocodepy.ec8.spectrum.get_spec_params","title":"<code>get_spec_params(locale, code, class_imp, soil, zone)</code>","text":"<p>Get the spectrum parameters.</p> <p>Parameters:</p> Name Type Description Default <code>locale</code> <code>str</code> <p>country code (EU, PT)</p> required <code>code</code> <code>str</code> <pre><code>CEN-1, CEN-2: standard Eurocode spectrums (EU)\nPT1, PT2, PTA: Portuguese National Annex spectrums (PT)\n(PT1 and PT2, for continent and Madeira, PTA for Azores)\n</code></pre> required <code>class_imp</code> <code>str</code> <p>importance class  (i, ii, iii, iv)</p> required <code>soil</code> <code>str</code> <p>soil type (A, B, C, D, E)</p> required <code>zone</code> <code>str</code> <p>(1_1, 1_2, 1_3, 1_4, 1_5, 1_6) for \"PT-1\"         (2.1, 2.2, 2.3, 2.4, 2.5) for \"PT-2\" and \"PT-A\"         (.1g, .2g, .3g, ..., .8g, .9g, 1_0g) for \"CEN-1\" and \"CEN-2\"</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if locale is not available</p> <code>ValueError</code> <p>if code is not available</p> <code>ValueError</code> <p>if class_imp is not available</p> <p>Returns:</p> Name Type Description <code>list</code> <code>tuple</code> <p>soil amplification factor, acceleration, T_B, T_C, T_D</p> Source code in <code>eurocodepy/ec8/spectrum.py</code> <pre><code>def get_spec_params(locale: str, code: str, class_imp: str,  # noqa: PLR0914\n                    soil: str, zone: str) -&gt; tuple:\n    \"\"\"Get the spectrum parameters.\n\n    Args:\n        locale (str): country code (EU, PT)\n        code (str):\n                CEN-1, CEN-2: standard Eurocode spectrums (EU)\n                PT1, PT2, PTA: Portuguese National Annex spectrums (PT)\n                (PT1 and PT2, for continent and Madeira, PTA for Azores)\n        class_imp (str): importance class  (i, ii, iii, iv)\n        soil (str): soil type (A, B, C, D, E)\n        zone (str): (1_1, 1_2, 1_3, 1_4, 1_5, 1_6) for \"PT-1\"\n                    (2.1, 2.2, 2.3, 2.4, 2.5) for \"PT-2\" and \"PT-A\"\n                    (.1g, .2g, .3g, ..., .8g, .9g, 1_0g) for \"CEN-1\" and \"CEN-2\"\n\n    Raises:\n        ValueError: if locale is not available\n        ValueError: if code is not available\n        ValueError: if class_imp is not available\n\n    Returns:\n        list: soil amplification factor, acceleration, T_B, T_C, T_D\n\n    \"\"\"\n    local = dbase.SeismicLoads[\"Locale\"][locale]\n\n    if code not in local[\"Types\"]:\n        msg = f\"Code {code} not available for locale {locale}\"\n        raise ValueError(msg)\n\n    class_imp = str.lower(class_imp)\n    if class_imp not in local[\"ImportanceClass\"]:\n        msg = f\"Class {class_imp} not available for locale {locale}\"\n        raise ValueError(msg)\n\n    zone = zone.replace(\".\", \"_\")\n    if zone not in local[\"a_gR\"][code]:\n        msg = f\"Zone {zone} not available for locale {locale}\"\n        raise ValueError(msg)\n\n    soil = str.upper(soil)\n    if soil not in local[\"SoilType\"]:\n        msg = f\"Soil {soil} not available for code {code}\"\n        raise ValueError(msg)\n\n    importance_coef = local[\"ImportanceCoef\"][code][class_imp]\n    a_gr = local[\"a_gR\"][code][zone]\n    a_g = a_gr * importance_coef\n\n    t_b = local[\"Spectrum\"][code][soil][\"T_B\"]\n    t_c = local[\"Spectrum\"][code][soil][\"T_C\"]\n    t_d = local[\"Spectrum\"][code][soil][\"T_D\"]\n    s_max = local[\"Spectrum\"][code][soil][\"S_max\"]\n    s_min = local[\"Spectrum\"][code][soil][\"S_min\"]\n    ag1 = local[\"Spectrum\"][code][soil][\"a_g1\"]\n    ag2 = local[\"Spectrum\"][code][soil][\"a_g2\"]\n    if a_g &lt;= ag1:\n        s_val = s_max\n    elif a_g &gt;= ag2:\n        s_val = s_min\n    else:\n        s_val = s_max - (s_max - s_min) * (a_g - ag1) / (ag2 - ag1)\n    return s_val, a_g, t_b, t_c, t_d\n</code></pre>"},{"location":"reference/eurocodepy/ec8/spectrum/#eurocodepy.ec8.spectrum.get_spectrum_ec8","title":"<code>get_spectrum_ec8(locale, code, imp_class, soil, zone, behaviour)</code>","text":"<p>Generate the spectrum DataFrame for the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>locale</code> <code>str</code> <p>country code (EU, PT)</p> required <code>code</code> <code>str</code> <p>the code of the spectrum (CEN-1, CEN-2, PT-1, PT-2, PT-A)</p> required <code>imp_class</code> <code>str</code> <p>importance class (I, II, III, IV)</p> required <code>soil</code> <code>str</code> <p>type of soil (A, B, C, D, E)</p> required <code>zone</code> <code>str</code> <p>seismic zone</p> required <code>behaviour</code> <code>float</code> <p>behaviour factor</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: the spectrum DataFrame</p> Source code in <code>eurocodepy/ec8/spectrum.py</code> <pre><code>def get_spectrum_ec8(locale: str, code: str, imp_class: str, soil: str, zone: str,  # noqa: PLR0913, PLR0917\n                behaviour: float) -&gt; pd.DataFrame:\n    \"\"\"Generate the spectrum DataFrame for the given parameters.\n\n    Args:\n        locale (str): country code (EU, PT)\n        code (str): the code of the spectrum (CEN-1, CEN-2, PT-1, PT-2, PT-A)\n        imp_class (str): importance class (I, II, III, IV)\n        soil (str): type of soil (A, B, C, D, E)\n        zone (str): seismic zone\n        behaviour (float): behaviour factor\n\n    Returns:\n        pd.DataFrame: the spectrum DataFrame\n\n    \"\"\"\n    txt = (\n        code + \"_\" + imp_class + \"_\" + soil + \"_\"\n        + str.replace(zone, \"_\", \".\") + \"_\" + str(behaviour)\n    )\n\n    s_val, a_g, t_b, t_c, t_d = get_spec_params(locale, code, imp_class, soil, zone)\n\n    perds = np.linspace(0.0, t_b, 10, endpoint=False)\n    perds = np.append(perds, np.linspace(t_b, t_c, 10, endpoint=False))\n    perds = np.append(perds, np.linspace(t_c, t_d, 10, endpoint=False))\n    perds = np.append(perds, np.linspace(t_d, 10, 30))\n\n    value = [calc_spectrum(T, a_g, s_val, behaviour, t_b, t_c, t_d, 0.2) for T in perds]\n    data = {\"period\": perds,\n            \"value\": value}\n\n    spec = pd.DataFrame(data)\n    spec.attrs[\"name\"] = txt\n    spec.attrs[\"S\"] = s_val\n    spec.attrs[\"a_g\"] = a_g\n    spec.attrs[\"q\"] = str(behaviour)\n\n    return spec\n</code></pre>"},{"location":"reference/eurocodepy/ec8/spectrum/#eurocodepy.ec8.spectrum.get_spectrum_parameters","title":"<code>get_spectrum_parameters(code, coef_imp, soil, zone)</code>","text":"<p>Get the spectrum parameters.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>code to be used (CEN-1, CEN-2, PT-1, PT-2, PT-A)     CEN-1, CEN-2: standard Eurocode spectrums     PT-1, PT-2, PT-A: Portuguese National Annex spectrums         (PT-1 and PT-2, for continent and Madeira, PT-A for Azores)</p> required <code>coef_imp</code> <code>str</code> <p>importance coefficient (i, ii, iii, iv)</p> required <code>soil</code> <code>str</code> <p>soil type (A, B, C, D, E)</p> required <code>zone</code> <code>str</code> <p>zone (1_1, 1_2, 1_3, 1_4, 1_5, 1_6, 2.1, 2.2, 2.3, 2.4, 2.5, .1g,</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>tuple</code> <p>soil amplification factor, acceleration, T_B, T_C, T_D</p> Source code in <code>eurocodepy/ec8/spectrum.py</code> <pre><code>def get_spectrum_parameters(code: str, coef_imp: str, soil: str, zone: str) -&gt; tuple:  # noqa: PLR0914\n    \"\"\"Get the spectrum parameters.\n\n    Args:\n        code (str): code to be used (CEN-1, CEN-2, PT-1, PT-2, PT-A)\n                CEN-1, CEN-2: standard Eurocode spectrums\n                PT-1, PT-2, PT-A: Portuguese National Annex spectrums\n                    (PT-1 and PT-2, for continent and Madeira, PT-A for Azores)\n        coef_imp (str): importance coefficient (i, ii, iii, iv)\n        soil (str): soil type (A, B, C, D, E)\n        zone (str): zone (1_1, 1_2, 1_3, 1_4, 1_5, 1_6, 2.1, 2.2, 2.3, 2.4, 2.5, .1g,\n        .2g, .3g, .4g, .5g, .6g, .7g, .8g, .9g, 1_0g)\n\n    Returns:\n        list: soil amplification factor, acceleration, T_B, T_C, T_D\n\n    \"\"\"\n    # accelarations\n    a_gr = {\"1_1\": 2.5, \"1_2\": 2.0, \"1_3\": 1_5, \"1_4\": 1_0, \"1_5\": 0.6, \"1_6\": 0.35,\n            \"2.1\": 2.5, \"2.2\": 2.0, \"2.3\": 1.7, \"2.4\": 1.1, \"2.5\": 0.8,\n            \".1g\": 0.980665, \".2g\": 1.96133, \".3g\":  2.941995, \".4g\": 3.92266,\n            \".5g\": 4.903325, \".6g\": 5.88399, \".7g\": 6.864655, \".8g\": 7.84532,\n            \".9g\": 8.825985, \"1_0g\": 9.80665}\n\n    index1 = [\"i\", \"ii\", \"iii\", \"iv\"]\n    gama_f = {\"CEN-1\": [0.8, 1.0, 1.2, 1.4],\n            \"CEN-2\": [0.8, 1.0, 1.2, 1.4],\n            \"PT-1\": [0.65, 1.0, 1.45, 1.95],\n            \"PT-2\": [0.75, 1.0, 1.25, 1.5],\n            \"PT-A\": [0.85, 1.0, 1.15, 1.35]}\n    coefs = pd.DataFrame(gama_f, index=index1)\n\n    coef_imp = str.lower(coef_imp)\n    a_g = a_gr[zone] * coefs.at[coef_imp, code]  # noqa: PD008\n\n    soil = str.upper(soil)\n    index = [\"A\", \"B\", \"C\", \"D\", \"E\"]\n    code = str.upper(code)\n    if code == \"CEN-1\":\n        data = {\"S_max\": [1.0, 1.2, 1.15, 1.35, 1.4],\n                \"T_B\": [0.15, 0.15, 0.2, 0.2, 0.15],\n                \"T_C\": [0.4, 0.5, 0.6, 0.8, 0.5],\n                \"T_D\": [2.0, 2.0, 2.0, 2.0, 2.0],\n                }\n    elif code == \"CEN-2\":\n        data = {\"S_max\": [1.0, 1.35, 1.5, 1.8, 1.6],\n                \"T_B\": [0.05, 0.05, 0.1, 0.1, 0.05],\n                \"T_C\": [0.25, 0.25, 0.25, 0.3, 0.25],\n                \"T_D\": [1.2, 1.2, 1.2, 1.2, 1.2],\n                }\n    elif code in {\"PT-2\", \"PT-A\"}:\n        data = {\"S_max\": [1.0, 1.35, 1.60, 2.0, 1.8],\n                \"T_B\": [0.1, 0.1, 0.1, 0.1, 0.1],\n                \"T_C\": [0.25, 0.25, 0.25, 0.3, 0.25],\n                \"T_D\": [2.0, 2.0, 2.0, 2.0, 2.0],\n                }\n    elif code == \"PT-1\":\n        data = {\"S_max\": [1.0, 1.35, 1.60, 2.0, 1.8],\n                \"T_B\": [0.1, 0.1, 0.1, 0.1, 0.1],\n                \"T_C\": [0.6, 0.6, 0.6, 0.8, 0.6],\n                \"T_D\": [2.0, 2.0, 2.0, 2.0, 2.0],\n                }\n    values = pd.DataFrame(data, index=index)\n\n    s_max = values.at[soil, \"S_max\"]  # noqa: PD008\n\n    if code in {\"CEN-1\", \"CEN-2\"} or a_g &lt;= 1.0:\n        s_val = s_max\n    elif a_g &gt;= 4.0:\n        s_val = 1.0\n    else:\n        s_val = s_max - (s_max - 1.0) * (a_g - 1.0) / 3.0\n\n    t_b = values.at[soil, \"T_B\"]  # noqa: PD008\n    t_c = values.at[soil, \"T_C\"]  # noqa: PD008\n    t_d = values.at[soil, \"T_D\"]  # noqa: PD008\n\n    return s_val, a_g, t_b, t_c, t_d\n</code></pre>"},{"location":"reference/eurocodepy/ec8/spectrum/#eurocodepy.ec8.spectrum.get_spectrum_user","title":"<code>get_spectrum_user(a_g, s_val, q, t_b, t_c, t_d, beta=0.2)</code>","text":"<p>Generate the spectrum DataFrame for the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>a_g</code> <code>float</code> <p>acceleration (m/s2)</p> required <code>s_val</code> <code>float</code> <p>soil amplification factor</p> required <code>q</code> <code>float</code> <p>behaviour factor</p> required <code>t_b</code> <code>float</code> <p>spectrum parameter</p> required <code>t_c</code> <code>float</code> <p>spectrum parameter</p> required <code>t_d</code> <code>float</code> <p>spectrum parameter</p> required <code>beta</code> <code>float</code> <p>the limiting value of the spectrum. Defaults to 0.2.</p> <code>0.2</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: description</p> Source code in <code>eurocodepy/ec8/spectrum.py</code> <pre><code>def get_spectrum_user(  # noqa: PLR0913, PLR0917\n    a_g: float,\n    s_val: float,\n    q: float,\n    t_b: float,\n    t_c: float,\n    t_d: float,\n    beta: float = 0.2,\n) -&gt; pd.DataFrame:\n    \"\"\"Generate the spectrum DataFrame for the given parameters.\n\n    Args:\n        a_g (float): acceleration (m/s2)\n        s_val (float): soil amplification factor\n        q (float): behaviour factor\n        t_b (float): spectrum parameter\n        t_c (float): spectrum parameter\n        t_d (float): spectrum parameter\n        beta (float, optional): the limiting value of the spectrum. Defaults to 0.2.\n\n    Returns:\n        pd.DataFrame: _description_\n\n    \"\"\"\n    txt = (\n        \"t_b_\" + str(t_b) + \"_t_c_\" + str(t_c) +\n        \"_t_d_\" + str(t_d) + \"_b_\" + str(beta)\n        )\n\n    periods = np.linspace(0.0, t_b, 10, endpoint=False)\n    periods = np.append(periods, np.linspace(t_b, t_c, 10, endpoint=False))\n    periods = np.append(periods, np.linspace(t_c, t_d, 10, endpoint=False))\n    periods = np.append(periods, np.linspace(t_d, 10, 30))\n\n    value = [calc_spectrum(T, a_g, s_val, q, t_b, t_c, t_d, beta) for T in periods]\n    data = {\"period\": periods,\n            \"value\": value}\n\n    spec = pd.DataFrame(data)\n    spec.attrs[\"name\"] = txt\n    spec.attrs[\"S\"] = s_val\n    spec.attrs[\"a_g\"] = round(a_g, 5)\n    spec.attrs[\"q\"] = q\n\n    return spec\n</code></pre>"},{"location":"reference/eurocodepy/ec8/spectrum/#eurocodepy.ec8.spectrum.write_spectrum_ec8","title":"<code>write_spectrum_ec8(spectrum, filename=None, separator=',')</code>","text":"<p>Generate a text file with the spectrum data.</p> <p>Parameters:</p> Name Type Description Default <code>spectrum</code> <code>DataFrame</code> <p>a pandas DataFrame with the</p> required <code>spectrum</code> <code>data (columns</code> <p>period, value)</p> required <code>filename</code> <code>str | None</code> <p>the filename to use when saving the spectrum data (if None, a default is used)</p> <code>None</code> <code>separator</code> <code>str</code> <p>a string with the separator to be used in the text file</p> <code>','</code> Source code in <code>eurocodepy/ec8/spectrum.py</code> <pre><code>def write_spectrum_ec8(spectrum: pd.DataFrame, filename: str | None = None,\n                        separator: str = \",\") -&gt; None:\n    \"\"\"Generate a text file with the spectrum data.\n\n    Args:\n        spectrum (pd.DataFrame): a pandas DataFrame with the\n        spectrum data (columns: period, value)\n        filename (str | None): the filename to use when saving the spectrum data\n            (if None, a default is used)\n        separator (str): a string with the separator to be used in the text file\n\n    \"\"\"\n    # separator was defined as \" \" (space) for SAP2000 compatibility.\n    # any other can be used\n    if filename is None:\n        filename = \"spectrum_\" + spectrum.attrs[\"name\"] + \".csv\"\n\n    spectrum.to_csv(filename, index=False, sep=separator)\n</code></pre>"},{"location":"reference/eurocodepy/utils/","title":"utils","text":""},{"location":"reference/eurocodepy/utils/dict_tools/","title":"dict_tools","text":""},{"location":"reference/eurocodepy/utils/plotly_templates/","title":"plotly_templates","text":""},{"location":"reference/eurocodepy/utils/section_properties/","title":"section_properties","text":""},{"location":"reference/eurocodepy/utils/section_properties/#eurocodepy.utils.section_properties.CrossSectionProperties","title":"<code>CrossSectionProperties</code>  <code>dataclass</code>","text":"<p>Represents the geometric and mechanical properties of a cross-section.</p> <p>Attributes:</p> Name Type Description <code>Area</code> <code>float</code> <p>Cross-sectional area.</p> <code>Inertia</code> <code>float</code> <p>Moment of inertia.</p> <code>G_inf</code> <code>float</code> <p>Some property at the bottom fiber (description needed).</p> <code>G_sup</code> <code>float</code> <p>Some property at the top fiber (description needed).</p> <code>NeutralAxis</code> <code>float</code> <p>Position of the neutral axis.</p> <code>W_inf</code> <code>float</code> <p>Section modulus at the bottom fiber.</p> <code>W_sup</code> <code>float</code> <p>Section modulus at the top fiber.</p> Source code in <code>eurocodepy/utils/section_properties.py</code> <pre><code>@dataclass\nclass CrossSectionProperties:\n    \"\"\"Represents the geometric and mechanical properties of a cross-section.\n\n    Attributes:\n        Area (float): Cross-sectional area.\n        Inertia (float): Moment of inertia.\n        G_inf (float): Some property at the bottom fiber (description needed).\n        G_sup (float): Some property at the top fiber (description needed).\n        NeutralAxis (float): Position of the neutral axis.\n        W_inf (float): Section modulus at the bottom fiber.\n        W_sup (float): Section modulus at the top fiber.\n\n    \"\"\"\n\n    Area: float\n    Inertia: float\n    G_inf: float\n    G_sup: float\n    NeutralAxis: float\n    W_inf: float\n    W_sup: float\n</code></pre>"},{"location":"reference/eurocodepy/utils/section_properties/#eurocodepy.utils.section_properties.calc_neutral_axis_cracked_T","title":"<code>calc_neutral_axis_cracked_T(h, b, bw, hf, A_s, A_sc, A_p, ds, dsc, dp, alpha_E_s, alpha_E_p, M, P, display=False)</code>","text":"<p>Calculate the neutral axis of a cracked T-section.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Total height of the section.</p> required <code>bw</code> <code>float</code> <p>Web width of the section.</p> required <code>bf</code> <code>float</code> <p>Flange width of the section.</p> required <code>hf</code> <code>float</code> <p>Flange height of the section.</p> required <code>A_s</code> <code>float[]</code> <p>Area of the tensioned reinforcement.</p> required <code>A_sc</code> <code>float[]</code> <p>Area of the compressed reinforcement.</p> required <code>A_p</code> <code>float[]</code> <p>Area of the prestressing tendon.</p> required <code>ds</code> <code>float[]</code> <p>Distance to the tensioned reinforcement from the top.</p> required <code>dsc</code> <code>float[]</code> <p>Distance to the compressed reinforcement from the top.</p> required <code>dp</code> <code>float[]</code> <p>Distance to the prestressing tendon from the top.</p> required <code>alpha_Es</code> <code>float</code> <p>Equivalence factor of the passive steel.</p> required <code>alpha_Ep</code> <code>float</code> <p>Equivalence factor of the prestressed steel.</p> required <code>M</code> <code>float</code> <p>Bending moment.</p> required <code>P</code> <code>float</code> <p>Prestressing normal force.</p> required <code>display</code> <code>bool</code> <p>If True, displays the calculated results. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the neutral axis depth of a cracked T section.</p> Source code in <code>eurocodepy/utils/section_properties.py</code> <pre><code>def calc_neutral_axis_cracked_T(h, b, bw, hf, A_s, A_sc, A_p, ds, dsc, dp,\n                alpha_E_s, alpha_E_p, M, P, display=False) -&gt; float:\n    \"\"\"Calculate the neutral axis of a cracked T-section.\n\n    Args:\n        h (float): Total height of the section.\n        bw (float): Web width of the section.\n        bf (float): Flange width of the section.\n        hf (float): Flange height of the section.\n        A_s (float[]): Area of the tensioned reinforcement.\n        A_sc (float[]): Area of the compressed reinforcement.\n        A_p (float[]): Area of the prestressing tendon.\n        ds (float[]): Distance to the tensioned reinforcement from the top.\n        dsc (float[]): Distance to the compressed reinforcement from the top.\n        dp (float[]): Distance to the prestressing tendon from the top.\n        alpha_Es (float): Equivalence factor of the passive steel.\n        alpha_Ep (float): Equivalence factor of the prestressed steel.\n        M (float): Bending moment.\n        P (float): Prestressing normal force.\n        display (bool, optional): If True, displays the calculated results. Defaults to False.\n\n    Returns:\n        float: the neutral axis depth of a cracked T section.\n\n    \"\"\"\n    ds_ref = np.max(ds)\n    dp_ref = np.sum(dp * A_p) / np.sum(A_p) if np.abs(np.sum(A_p)) &gt; 0 else dp[0]\n    es = -M / P - (ds_ref - dp_ref)  # Excentricidade\n\n    # Calcular os coeficientes da equa\u00e7\u00e3o c\u00fabica\n    a1 = -3 * np.sum(ds + es)\n    a2 = (-6 / bw) * (hf * (b - bw) * np.sum(ds + es - 0.5 * hf) + (alpha_E_s - 1) * np.sum(A_sc * (ds + es - dsc)) +\n                    alpha_E_p * np.sum(A_p * (ds + es - dp)) + alpha_E_s * np.sum(A_s * es))\n    a3 = (6 / bw) * (0.5 * hf**2 * (b - bw) * np.sum(ds + es - 2/3 * hf) +\n                    (alpha_E_s - 1) * A_sc * np.sum(dsc * (ds + es - dsc)) +\n                    alpha_E_p * np.sum(A_p * dp * (ds + es - dp)) + alpha_E_s * np.sum(A_s * ds * es))\n\n    a1 = np.sum(a1)\n    a2 = np.sum(a2)\n    a3 = np.sum(a3)\n    # Encontrar as ra\u00edzes\n    roots = np.roots([1, a1, a2, a3])  # np.roots resolve equa\u00e7\u00f5es polinomiais\n\n    if display:\n        pass\n\n    # Filtrar apenas ra\u00edzes reais e dentro do intervalo (0, h)\n    real_roots = [x.real for x in roots if np.isreal(x) and 0 &lt; x.real &lt; h]\n\n    # Retorna a raiz v\u00e1lida ou None se n\u00e3o houver solu\u00e7\u00e3o dentro do intervalo\n    return real_roots[0] if real_roots else np.nan\n</code></pre>"},{"location":"reference/eurocodepy/utils/section_properties/#eurocodepy.utils.section_properties.calc_section_T","title":"<code>calc_section_T(h, bw, bf, hf, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=False, label='SEC\u00c7\u00c3O EM T')</code>","text":"<p>Calculate the area, center of gravity, bending modulus and moment of inertia of a T-section.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Total height of the section.</p> required <code>bw</code> <code>float</code> <p>Web width of the section.</p> required <code>bf</code> <code>float</code> <p>Flange width of the section.</p> required <code>hf</code> <code>float</code> <p>Flange height of the section.</p> required <code>A_s</code> <code>float[]</code> <p>Area of the tensioned reinforcement.</p> required <code>A_sc</code> <code>float[]</code> <p>Area of the compressed reinforcement.</p> required <code>A_p</code> <code>float[]</code> <p>Area of the prestressing tendon.</p> required <code>ds</code> <code>float[]</code> <p>Distance to the tensioned reinforcement from the top.</p> required <code>dsc</code> <code>float[]</code> <p>Distance to the compressed reinforcement from the top.</p> required <code>dp</code> <code>float[]</code> <p>Distance to the prestressing tendon from the top.</p> required <code>alpha_Es</code> <code>float</code> <p>Equivalence factor of the passive steel.</p> required <code>alpha_Ep</code> <code>float</code> <p>Equivalence factor of the prestressed steel.</p> required <code>M</code> <code>float</code> <p>Bending moment.</p> required <code>P</code> <code>float</code> <p>Prestressing normal force.</p> required <code>display</code> <code>bool</code> <p>If True, displays the calculated results. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>A tuple containing two dictionaries, representing the properties of the uncracked and cracked sections respectively. Each dictionary contains the area, center of gravity, and moment of inertia. (prop_un, prop_cr)</p> Source code in <code>eurocodepy/utils/section_properties.py</code> <pre><code>def calc_section_T(h, bw, bf, hf, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=False, label=\"SEC\u00c7\u00c3O EM T\") -&gt; tuple:\n    \"\"\"Calculate the area, center of gravity, bending modulus and moment of inertia of a T-section.\n\n    Args:\n        h (float): Total height of the section.\n        bw (float): Web width of the section.\n        bf (float): Flange width of the section.\n        hf (float): Flange height of the section.\n        A_s (float[]): Area of the tensioned reinforcement.\n        A_sc (float[]): Area of the compressed reinforcement.\n        A_p (float[]): Area of the prestressing tendon.\n        ds (float[]): Distance to the tensioned reinforcement from the top.\n        dsc (float[]): Distance to the compressed reinforcement from the top.\n        dp (float[]): Distance to the prestressing tendon from the top.\n        alpha_Es (float): Equivalence factor of the passive steel.\n        alpha_Ep (float): Equivalence factor of the prestressed steel.\n        M (float): Bending moment.\n        P (float): Prestressing normal force.\n        display (bool, optional): If True, displays the calculated results. Defaults to False.\n\n    Returns:\n        tuple: A tuple containing two dictionaries, representing the properties of the uncracked\n            and cracked sections respectively. Each dictionary contains the area, center of\n            gravity, and moment of inertia.\n            (prop_un, prop_cr)\n\n    \"\"\"\n    if display:\n        print(f\"\\n{label}\")\n        print(f\"   Altura total: {h:.3f}\")\n        print(f\"   Largura da alma: {bw:.3f}\")\n        print(f\"   Largura do banzo: {bf:.3f}\")\n        print(f\"   Altura do banzo: {hf:.3f}\")\n        print(f\"   \u00c1rea da armadura tracionada: {np.sum(A_s):.6f}\")\n        print(f\"   \u00c1rea da armadura comprimida: {np.sum(A_sc):.6f}\")\n        print(f\"   \u00c1rea do cabo de pr\u00e9-esfor\u00e7o: {np.sum(A_p):.6f}\")\n        print(f\"   Dist\u00e2ncia da armadura tracionada: {np.sum(ds):.3f}\")\n        print(f\"   Dist\u00e2ncia da armadura comprimida: {np.sum(dsc):.3f}\")\n        print(f\"   Dist\u00e2ncia do cabo de pr\u00e9-esfor\u00e7o: {np.sum(dp):.3f}\")\n        print(f\"   Fator de equival\u00eancia do a\u00e7o: {alpha_Es:.1f}\")\n        print(f\"   Fator de equival\u00eancia do pr\u00e9-esfor\u00e7o: {alpha_Ep:.1f}\")\n        print(f\"   Momento fletor: {M:.1f}\")\n        print(f\"   For\u00e7a normal de pr\u00e9-esfor\u00e7o: {P:.1f}\")\n    prop_un = calc_section_T_uncrack(h, bw, bf, hf, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=display)\n    prop_cr = calc_section_T_crack(h, bw, bf, hf, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=display)\n    return prop_un, prop_cr\n</code></pre>"},{"location":"reference/eurocodepy/utils/section_properties/#eurocodepy.utils.section_properties.calc_section_T_crack","title":"<code>calc_section_T_crack(h, bw, bf, hf, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=False)</code>","text":"<p>Calculate the area, center of gravity, bending modulus and moment of inertia of a cracked T-section.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Total height of the section.</p> required <code>bw</code> <code>float</code> <p>Web width of the section.</p> required <code>bf</code> <code>float</code> <p>Flange width of the section.</p> required <code>hf</code> <code>float</code> <p>Flange height of the section.</p> required <code>A_s</code> <code>float[]</code> <p>Area of the tensioned reinforcement.</p> required <code>A_sc</code> <code>float[]</code> <p>Area of the compressed reinforcement.</p> required <code>A_p</code> <code>float[]</code> <p>Area of the prestressing tendon.</p> required <code>ds</code> <code>float[]</code> <p>Distance to the tensioned reinforcement from the top.</p> required <code>dsc</code> <code>float[]</code> <p>Distance to the compressed reinforcement from the top.</p> required <code>dp</code> <code>float[]</code> <p>Distance to the prestressing tendon from the top.</p> required <code>alpha_Es</code> <code>float</code> <p>Equivalence factor of the passive steel.</p> required <code>alpha_Ep</code> <code>float</code> <p>Equivalence factor of the prestressed steel.</p> required <code>M</code> <code>float</code> <p>Bending moment.</p> required <code>P</code> <code>float</code> <p>Prestressing normal force.</p> required <code>display</code> <code>bool</code> <p>If True, displays the calculated results. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>the properties of the cracked section. The dictionary contains the area, center of gravity, and moment of inertia.</p> Source code in <code>eurocodepy/utils/section_properties.py</code> <pre><code>def calc_section_T_crack(h, bw, bf, hf, A_s, A_sc, A_p, ds, dsc, dp,\n                alpha_Es, alpha_Ep, M, P, display = False):\n    \"\"\"Calculate the area, center of gravity, bending modulus and moment of inertia of a cracked T-section.\n\n    Args:\n        h (float): Total height of the section.\n        bw (float): Web width of the section.\n        bf (float): Flange width of the section.\n        hf (float): Flange height of the section.\n        A_s (float[]): Area of the tensioned reinforcement.\n        A_sc (float[]): Area of the compressed reinforcement.\n        A_p (float[]): Area of the prestressing tendon.\n        ds (float[]): Distance to the tensioned reinforcement from the top.\n        dsc (float[]): Distance to the compressed reinforcement from the top.\n        dp (float[]): Distance to the prestressing tendon from the top.\n        alpha_Es (float): Equivalence factor of the passive steel.\n        alpha_Ep (float): Equivalence factor of the prestressed steel.\n        M (float): Bending moment.\n        P (float): Prestressing normal force.\n        display (bool, optional): If True, displays the calculated results. Defaults to False.\n\n    Returns:\n        dict: the properties of the cracked section. The dictionary contains the area, center of\n            gravity, and moment of inertia.\n\n    \"\"\"\n    xi = calc_neutral_axis_cracked_T(h, bf, bw, hf, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=display)\n\n    # C\u00e1lculo da \u00e1rea da sec\u00e7\u00e3o fendilhada\n    Aun = xi * bw + hf * (bf - bw) + (alpha_Es - 1) * np.sum(A_sc) + alpha_Es * np.sum(A_s) + alpha_Ep * np.sum(A_p)\n\n    # C\u00e1lculo do centro de gravidade\n    zgs = (0.5 * xi*xi * bw + 0.5 * hf**2 * (bf - bw) + (alpha_Es - 1) * np.sum(dsc * A_sc) +\n              alpha_Es * np.sum(ds * A_s) + alpha_Ep * np.sum(dp * A_p)) / Aun\n    zg = h - zgs\n\n    if zgs &lt; hf:\n        # Se o centro de gravidade estiver dentro da banzo, a sec\u00e7\u00e3o \u00e9 como retangular com bw = bf\n        return calc_section_T_crack(h, bw, bw, 0.0, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=display)\n\n    # C\u00e1lculo do momento de in\u00e9rcia da sec\u00e7\u00e3o fendilhada\n    Iun = np.float64( \n           ((bf - bw) * hf**3) / 12 + (bf - bw) * hf * (zgs - hf / 2)**2 + \n           (bw * xi**3) / 12 + (bw * xi) * (zgs - xi / 2)**2 + \n           (alpha_Es - 1)  * np.sum(A_sc * (dsc - zgs)**2) + \n           alpha_Es * np.sum(A_s * (ds - zgs)**2) + \n           alpha_Ep * np.sum(A_p * (dp - zgs)**2))\n\n    e_p = np.round(dp - zgs, 4)\n    Ws = Iun/zgs\n    Wi = Iun/zg\n    sigma_cs = np.round(-P/Aun - (M - P * e_p) / Ws, 1)\n    sigma_p = np.round(alpha_Ep * (-P / Aun + (M - P * e_p) / Iun * e_p), 1)\n    sigma_sc = np.round(alpha_Es * (-P / Aun + (M - P * e_p) / Iun * (dsc - zgs)), 1)\n    sigma_st = np.round(alpha_Es * (-P / Aun + (M - P * e_p) / Iun * (ds - zgs)), 1)\n\n    if display:\n        print(\"Propriedades da sec\u00e7\u00e3o fendilhada\")\n        print(f\"   \u00c1rea: {Aun:.4f}\")\n        print(f\"   Momento de in\u00e9rcia: {Iun:.6f}\")\n        print(f\"   Centro de gravidade (inf): {zg:.4f}\")\n        print(f\"   Centro de gravidade (sup): {zgs:.4f}\")\n        print(f\"   M\u00f3dulo de flex\u00e3o (sup): {Ws:.6f}\")\n        print(f\"   M\u00f3dulo de flex\u00e3o (inf): {Wi:.6f}\")\n        print(f\"   Profundidade do eixo neutro: {xi:.4f}\")\n        print(f\"   Excentricidade (P): {e_p}\")\n        print(f\"   Sigma_cs: {sigma_cs}\")\n        print(f\"   Sigma_sc: {sigma_sc}\")\n        print(f\"   Sigma_st: {sigma_st}\")\n        print(f\"   Sigma_p: {sigma_p}\")\n\n    return {\"Area\": Aun, \"Inertia\": Iun, \"zGi\": zg, \"zGs\": zgs, \"Wi\": Wi, \"Ws\": Ws, \"NeutralAxis\": xi, \"e_p\": e_p}\n</code></pre>"},{"location":"reference/eurocodepy/utils/section_properties/#eurocodepy.utils.section_properties.calc_section_T_uncrack","title":"<code>calc_section_T_uncrack(h, bw, bf, hf, As, Asc, Ap, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=False)</code>","text":"<p>Calculate the area, center of gravity, bending modulus and moment of inertia of a cracked T-section.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Total height of the section.</p> required <code>bw</code> <code>float</code> <p>Web width of the section.</p> required <code>bf</code> <code>float</code> <p>Flange width of the section.</p> required <code>hf</code> <code>float</code> <p>Flange height of the section.</p> required <code>A_s</code> <code>float[]</code> <p>Area of the tensioned reinforcement.</p> required <code>A_sc</code> <code>float[]</code> <p>Area of the compressed reinforcement.</p> required <code>A_p</code> <code>float[]</code> <p>Area of the prestressing tendon.</p> required <code>ds</code> <code>float[]</code> <p>Distance to the tensioned reinforcement from the top.</p> required <code>dsc</code> <code>float[]</code> <p>Distance to the compressed reinforcement from the top.</p> required <code>dp</code> <code>float[]</code> <p>Distance to the prestressing tendon from the top.</p> required <code>alpha_Es</code> <code>float</code> <p>Equivalence factor of the passive steel.</p> required <code>alpha_Ep</code> <code>float</code> <p>Equivalence factor of the prestressed steel.</p> required <code>M</code> <code>float</code> <p>Bending moment.</p> required <code>P</code> <code>float</code> <p>Prestressing normal force.</p> required <code>display</code> <code>bool</code> <p>If True, displays the calculated results. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>the properties of the uncracked section. The dictionary contains the area, center of gravity, and moment of inertia.</p> Source code in <code>eurocodepy/utils/section_properties.py</code> <pre><code>def calc_section_T_uncrack(h, bw, bf, hf, As, Asc, Ap, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=False):\n    \"\"\"Calculate the area, center of gravity, bending modulus and moment of inertia of a cracked T-section.\n\n    Args:\n        h (float): Total height of the section.\n        bw (float): Web width of the section.\n        bf (float): Flange width of the section.\n        hf (float): Flange height of the section.\n        A_s (float[]): Area of the tensioned reinforcement.\n        A_sc (float[]): Area of the compressed reinforcement.\n        A_p (float[]): Area of the prestressing tendon.\n        ds (float[]): Distance to the tensioned reinforcement from the top.\n        dsc (float[]): Distance to the compressed reinforcement from the top.\n        dp (float[]): Distance to the prestressing tendon from the top.\n        alpha_Es (float): Equivalence factor of the passive steel.\n        alpha_Ep (float): Equivalence factor of the prestressed steel.\n        M (float): Bending moment.\n        P (float): Prestressing normal force.\n        display (bool, optional): If True, displays the calculated results. Defaults to False.\n\n    Returns:\n        dict: the properties of the uncracked section. The dictionary contains the area, center of\n            gravity, and moment of inertia.\n\n    \"\"\"\n    # C\u00e1lculo da \u00e1rea equivalente em bet\u00e3o\n    Aun = h * bw + hf * (bf - bw) + (alpha_Es - 1) * (np.sum(As) + np.sum(Asc)) + (alpha_Ep - 1) * np.sum(Ap)\n\n    # C\u00e1lculo do centro de gravidade\n    zgs = (0.5 * h**2 * bw + 0.5 * hf**2 * (bf - bw) + \n           (alpha_Es - 1) * (np.sum(ds * As) + np.sum(dsc * Asc)) + \n           (alpha_Ep - 1) * np.sum(dp * Ap)) / Aun\n    zg = h - zgs\n\n    # C\u00e1lculo da in\u00e9rcia n\u00e3o fendilhada\n    Iun = np.float64(\n        (bw * h**3)/12 + (bw * h * (0.5 * h - zgs)**2) + \n        ((bf - bw) * hf**3)/12 + (hf * (bf - bw) * (0.5 * hf - zgs)**2) + \n        (alpha_Es - 1) * (np.sum(Asc * (dsc - zgs)**2) + np.sum(As * (ds - zgs)**2)) + \n        (alpha_Ep - 1) * (np.sum(Ap * (dp - zgs)**2)))\n\n    root_un = zgs + P / Aun / (M - P * np.sum(dp - zgs)) * Iun \n\n    e_p = np.round(dp - zgs, 4)\n    Ws = Iun/zgs\n    Wi = Iun/zg\n    sigma_cs = np.round(-P/Aun - (M - P * e_p) / Ws, 1)\n    sigma_ci = np.round(-P/Aun + (M - P * e_p) / Wi, 1)\n    sigma_p = np.round(alpha_Ep * (-P / Aun + (M - P * e_p) / Iun * e_p), 1)\n    sigma_sc = np.round(alpha_Es * (-P / Aun + (M - P * e_p) / Iun * (dsc - zgs)), 1)\n    sigma_st = np.round(alpha_Es * (-P / Aun + (M - P * e_p) / Iun * (ds - zgs)), 1)\n\n    if display:\n        print(\"Propriedades da sec\u00e7\u00e3o n\u00e3o fendilhada\")\n        print(f\"   \u00c1rea: {Aun:.4f}\")\n        print(f\"   Momento de in\u00e9rcia: {Iun:.6f}\")\n        print(f\"   Centro de gravidade (inf): {zg:.4f}\")\n        print(f\"   Centro de gravidade (sup): {zgs:.4f}\")\n        print(f\"   M\u00f3dulo de flex\u00e3o (sup): {Ws:.6f}\")\n        print(f\"   M\u00f3dulo de flex\u00e3o (inf): {Wi:.6f}\")\n        print(f\"   Profundidade do eixo neutro: {root_un:.4f}\")\n        print(f\"   Excentricidade (P): {e_p}\")\n        print(f\"   Sigma_cs: {sigma_cs}\")\n        print(f\"   Sigma_ci: {sigma_ci}\")\n        print(f\"   Sigma_sc: {sigma_sc}\")\n        print(f\"   Sigma_st: {sigma_st}\")\n        print(f\"   Sigma_p: {sigma_p}\")\n\n    return {\"Area\": Aun, \"Inertia\": Iun, \"zGi\": zg, \"zGs\": zgs, \"Wi\": Wi, \"Ws\": Ws, \"NeutralAxis\": root_un, \"e_p\": e_p}\n</code></pre>"},{"location":"reference/eurocodepy/utils/section_properties/#eurocodepy.utils.section_properties.calc_section_rectangular","title":"<code>calc_section_rectangular(h, b, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display=False, label='SEC\u00c7\u00c3O RETANGULAR')</code>","text":"<p>Calculate the area, center of gravity, and moment of inertia of a rectangular section.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Section height.</p> required <code>b</code> <code>float</code> <p>Section width.</p> required <code>A_s</code> <code>float</code> <p>Area of tensioned reinforcement.</p> required <code>A_sc</code> <code>float</code> <p>Area of compressed reinforcement.</p> required <code>A_p</code> <code>float</code> <p>Area of prestressing tendon.</p> required <code>ds</code> <code>float</code> <p>Distance to tensioned reinforcement.</p> required <code>dsc</code> <code>float</code> <p>Distance to compressed reinforcement.</p> required <code>dp</code> <code>float</code> <p>Distance to prestressing tendon.</p> required <code>alpha_Es</code> <code>float</code> <p>Equivalence factor of passive steel.</p> required <code>alpha_Ep</code> <code>float</code> <p>Equivalence factor of prestressed steel.</p> required <code>M</code> <code>float</code> <p>Bending moment.</p> required <code>P</code> <code>float</code> <p>Prestressing normal force.</p> required <code>display</code> <code>bool</code> <p>If True, displays the results. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing two dictionaries, representing the properties of the uncracked and cracked sections respectively. Each dictionary contains the area, center of gravity, and moment of inertia. (prop_un, prop_cr)</p> Source code in <code>eurocodepy/utils/section_properties.py</code> <pre><code>def calc_section_rectangular(h, b, A_s, A_sc, A_p, ds, dsc, dp, alpha_Es, alpha_Ep, M, P, display = False, label=\"SEC\u00c7\u00c3O RETANGULAR\"):\n    \"\"\"Calculate the area, center of gravity, and moment of inertia of a rectangular section.\n\n    Args:\n        h (float): Section height.\n        b (float): Section width.\n        A_s (float): Area of tensioned reinforcement.\n        A_sc (float): Area of compressed reinforcement.\n        A_p (float): Area of prestressing tendon.\n        ds (float): Distance to tensioned reinforcement.\n        dsc (float): Distance to compressed reinforcement.\n        dp (float): Distance to prestressing tendon.\n        alpha_Es (float): Equivalence factor of passive steel.\n        alpha_Ep (float): Equivalence factor of prestressed steel.\n        M (float): Bending moment.\n        P (float): Prestressing normal force.\n        display (bool, optional): If True, displays the results. Defaults to False.\n\n    Returns:\n        tuple: A tuple containing two dictionaries, representing the properties of the uncracked\n            and cracked sections respectively. Each dictionary contains the area, center of\n            gravity, and moment of inertia.\n            (prop_un, prop_cr)\n\n    \"\"\"\n    if display:\n        print(f\"\\n{label}\")\n        print(f\"   Altura: {h:.3f}\")\n        print(f\"   Largura: {b:.3f}\")\n        print(f\"   \u00c1rea da armadura tracionada: {np.sum(A_s):.6f}\")\n        print(f\"   \u00c1rea da armadura comprimida: {np.sum(A_sc):.6f}\")\n        print(f\"   \u00c1rea do cabo de pr\u00e9-esfor\u00e7o: {np.sum(A_p):.6f}\")\n        print(f\"   Dist\u00e2ncia da armadura tracionada: {np.sum(ds):.3f}\")\n        print(f\"   Dist\u00e2ncia da armadura comprimida: {np.sum(dsc):.3f}\")\n        print(f\"   Dist\u00e2ncia do cabo de pr\u00e9-esfor\u00e7o: {np.sum(dp):.3f}\")\n        print(f\"   Fator de equival\u00eancia do a\u00e7o: {alpha_Es:.1f}\")\n        print(f\"   Fator de equival\u00eancia do pr\u00e9-esfor\u00e7o: {alpha_Ep:.1f}\")\n        print(f\"   Momento fletor: {M:.1f}\")\n        print(f\"   For\u00e7a normal de pr\u00e9-esfor\u00e7o: {P:.1f}\")\n    prop_un = calc_section_T_uncrack(h, b, b, 0, A_s, A_sc, A_p, ds, dsc, dp,\n                            alpha_Es, alpha_Ep, M, P, display=display)\n    prop_cr = calc_section_T_crack(h, b, b, 0, A_s, A_sc, A_p, ds, dsc, dp,\n                            alpha_Es, alpha_Ep, M, P, display=display)\n    return prop_un, prop_cr\n</code></pre>"},{"location":"reference/eurocodepy/utils/section_properties/#eurocodepy.utils.section_properties.cubic_equation","title":"<code>cubic_equation(x, a1, a2, a3)</code>","text":"<p>Evaluate the cubic equation x^3 + a1x^2 + a2x + a3.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The variable.</p> required <code>a1</code> <code>float</code> <p>Coefficient of x^2.</p> required <code>a2</code> <code>float</code> <p>Coefficient of x.</p> required <code>a3</code> <code>float</code> <p>Constant term.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The result of the cubic equation.</p> Source code in <code>eurocodepy/utils/section_properties.py</code> <pre><code>def cubic_equation(x: float, a1: float, a2: float, a3: float) -&gt; float:\n    \"\"\"Evaluate the cubic equation x^3 + a1*x^2 + a2*x + a3.\n\n    Args:\n        x (float): The variable.\n        a1 (float): Coefficient of x^2.\n        a2 (float): Coefficient of x.\n        a3 (float): Constant term.\n\n    Returns:\n        float: The result of the cubic equation.\n\n    \"\"\"\n    return x**3 + a1 * x**2 + a2 * x + a3\n</code></pre>"},{"location":"reference/eurocodepy/utils/section_properties/#eurocodepy.utils.section_properties.solve_cubic","title":"<code>solve_cubic(a1, a2, a3, h)</code>","text":"<p>Solves the cubic equation x^3 + a1x^2 + a2x + a3 = 0 and returns the real root within the interval (0, h).</p> <p>Parameters:</p> Name Type Description Default <code>a1</code> <code>float</code> <p>Coefficient of x^2.</p> required <code>a2</code> <code>float</code> <p>Coefficient of x.</p> required <code>a3</code> <code>float</code> <p>Constant term.</p> required <code>h</code> <code>float</code> <p>Upper bound for the root interval.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The real root within (0, h), or np.nan if no such root exists.</p> Source code in <code>eurocodepy/utils/section_properties.py</code> <pre><code>def solve_cubic(a1: float, a2: float, a3: float, h: float) -&gt; float:\n    \"\"\"Solves the cubic equation x^3 + a1*x^2 + a2*x + a3 = 0 and returns the real root within the interval (0, h).\n\n    Args:\n        a1 (float): Coefficient of x^2.\n        a2 (float): Coefficient of x.\n        a3 (float): Constant term.\n        h (float): Upper bound for the root interval.\n\n    Returns:\n        float: The real root within (0, h), or np.nan if no such root exists.\n\n    \"\"\"\n    # Resolver a equa\u00e7\u00e3o c\u00fabica\n    roots = np.roots([1, a1, a2, a3])  # np.roots resolve equa\u00e7\u00f5es polinomiais\n\n    # Filtrar apenas ra\u00edzes reais e dentro do intervalo (0, h)\n    real_roots = [x.real for x in roots if np.isreal(x) and 0 &lt; x.real &lt; h]\n\n    # Retorna a raiz v\u00e1lida ou None se n\u00e3o houver solu\u00e7\u00e3o dentro do intervalo\n    return real_roots[0] if real_roots else np.nan\n</code></pre>"},{"location":"reference/eurocodepy/utils/stress/","title":"stress","text":""},{"location":"reference/eurocodepy/utils/stress/#eurocodepy.utils.stress.FailureCriteria","title":"<code>FailureCriteria</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for failure criteria.</p> Source code in <code>eurocodepy/utils/stress.py</code> <pre><code>class FailureCriteria(Enum):\n    \"\"\"Enum for failure criteria.\"\"\"\n\n    MOHR_COULOMB = \"Mohr-Coulomb\"\n    MOHR_CIRCLE = \"Mohr Circle\"\n    MAX_SHEAR = \"Max Shear Stress\"\n    MAX_PRINCIPAL = \"Max Principal Stress\"\n    MIN_PRINCIPAL = \"Min Principal Stress\"\n    ELLIPTIC = \"Elliptic\"\n    HENCKY = \"Hencky\"\n    RANKINE = \"Rankine\"\n    VON_MISES = \"Von Mises\"\n    TREFFTZ = \"Trefftz\"\n    CONCRETE = \"Concrete\"\n</code></pre>"},{"location":"reference/eurocodepy/utils/stress/#eurocodepy.utils.stress.Invariant","title":"<code>Invariant</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for stress invariants.</p> Source code in <code>eurocodepy/utils/stress.py</code> <pre><code>class Invariant(Enum):\n    \"\"\"Enum for stress invariants.\"\"\"\n\n    I1 = \"I1\"\n    J2 = \"J2\"\n    J3 = \"J3\"\n    MEAN_STRESS = \"Mean Stress\"\n    EQV_STRESS = \"Equivalent Stress\"\n    LODE_R = \"Lode R\"\n    LODE_Z = \"Lode Z\"\n    LODE_THETA = \"Lode Theta\"\n    COS3T = \"Cos(3Theta)\"\n    TRIAXIALITY = \"Triaxiality\"\n</code></pre>"},{"location":"reference/eurocodepy/utils/stress/#eurocodepy.utils.stress.invariants","title":"<code>invariants(sigxx, sigyy, sigzz, sigxy, sigyz, sigzx)</code>","text":"<p>Calculate the stress invariants.</p> <p>Author. Paulo Cachim (2022)</p> <p>Parameters:</p> Name Type Description Default <code>sigxx</code> <code>float</code> <p>stress xx</p> required <code>sigyy</code> <code>float</code> <p>stress yy</p> required <code>sigzz</code> <code>float</code> <p>stress zz</p> required <code>sigxy</code> <code>float</code> <p>stress xy</p> required <code>sigyz</code> <code>float</code> <p>stress yz</p> required <code>sigzx</code> <code>float</code> <p>stress zx</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>stress invariants (list): I1, J2, J3, mean_stress, eqv_stress,             lode_r, lode_z, lode_theta, cos3t, triaxiality</p> Source code in <code>eurocodepy/utils/stress.py</code> <pre><code>def invariants(sigxx: float, sigyy: float, sigzz: float,\n                        sigxy: float, sigyz: float, sigzx: float) -&gt; tuple:\n    \"\"\"Calculate the stress invariants.\n\n    Author. Paulo Cachim (2022)\n\n    Args:\n        sigxx (float): stress xx\n        sigyy (float): stress yy\n        sigzz (float): stress zz\n        sigxy (float): stress xy\n        sigyz (float): stress yz\n        sigzx (float): stress zx\n\n    Returns:\n        stress invariants (list): I1, J2, J3, mean_stress, eqv_stress,\n                        lode_r, lode_z, lode_theta, cos3t, triaxiality\n\n    \"\"\"\n    # stresses = [0.0,0.0,0.0,0.0,0.0,0.0]\n\n    # load the stresses into our matrix and compute the\n    # deviatoric and isotropic stress matricies\n    sigma = np.array([\n                            [sigxx, sigxy, sigzx],\n                            [sigxy, sigyy, sigyz],\n                            [sigzx, sigyz, sigzz]])\n    sigma_iso = (np.trace(sigma) * np.eye(3)) / 3.0\n    sigma_dev = sigma - sigma_iso\n\n    # # compute max shear stress\n    # maxshear = (max(eigvals)-min(eigvals))/2.0\n\n    # compute the stress invariants\n    I1 = np.trace(sigma)\n    J2 = 0.5 * np.trace(np.dot(sigma_dev, sigma_dev))\n    J3 = 0.33333333333333333 * np.trace(np.dot(sigma_dev, np.dot(sigma_dev, sigma_dev)))\n\n    # compute other common stress measures\n    mean_stress = I1 / 3.0\n    eqv_stress = math.sqrt(3.0 * J2)\n\n    # compute lode coordinates\n    lode_r = math.sqrt(2.0 * J2)\n    lode_z = I1 / math.sqrt(3.0)\n\n    stresses = 3.0 * math.sqrt(6.0) * np.linalg.det(sigma_dev / lode_r)\n    stresses = max(stresses, -1)\n    stresses = min(stresses, 1)\n    lode_theta = 1.0 / 3.0 * math.asin(stresses)\n    cos3t = 2.5980762114 * J3 / (J2**1.5)\n\n    # compute the stress triaxiality\n    triaxiality = mean_stress / eqv_stress\n\n    return (\n        I1, J2, J3, mean_stress, eqv_stress,\n        lode_r, lode_z, lode_theta, cos3t, triaxiality,\n    )\n</code></pre>"},{"location":"reference/eurocodepy/utils/stress/#eurocodepy.utils.stress.principal_vectors","title":"<code>principal_vectors(sigxx, sigyy, sigzz, sigxy, sigyz, sigzx)</code>","text":"<p>Calculate the princcipal vectors (size proportional to principal stresses).</p> <p>Author. Paulo Cachim (2022)</p> <p>Args: sigxx (float): stress xx sigyy (float): stress yy sigzz (float): stress zz sigxy (float): stress xy sigyz (float): stress yz sigzx (float): stress zx</p> <p>Returns: ndarray: an array of the principal vectors</p> Source code in <code>eurocodepy/utils/stress.py</code> <pre><code>def principal_vectors(sigxx: float, sigyy: float, sigzz: float,\n    sigxy: float, sigyz: float, sigzx: float) -&gt; np.ndarray:\n    \"\"\"Calculate the princcipal vectors (size proportional to principal stresses).\n\n    Author. Paulo Cachim (2022)\n\n    Args:\n    sigxx (float): stress xx\n    sigyy (float): stress yy\n    sigzz (float): stress zz\n    sigxy (float): stress xy\n    sigyz (float): stress yz\n    sigzx (float): stress zx\n\n    Returns:\n    ndarray: an array of the principal vectors\n\n    \"\"\"\n    values, vectors = np.linalg.eigh(np.array([\n                    [sigxx, sigxy, sigzx],\n                    [sigxy, sigyy, sigyz],\n                    [sigzx, sigyz, sigzz]]))\n\n    return vectors * np.array([values[0] * vectors[0],\n            values[1] * vectors[1],\n            values[2] * vectors[2]])\n</code></pre>"},{"location":"reference/eurocodepy/utils/stress/#eurocodepy.utils.stress.principals","title":"<code>principals(sigxx, sigyy, sigzz, sigxy, sigyz, sigzx)</code>","text":"<p>Calculate the principal stresses and the normalized principal directions.</p> <p>Author. Paulo Cachim (2022).</p> <p>Parameters:</p> Name Type Description Default <code>sigxx</code> <code>float</code> <p>stress xx</p> required <code>sigyy</code> <code>float</code> <p>stress yy</p> required <code>sigzz</code> <code>float</code> <p>stress zz</p> required <code>sigxy</code> <code>float</code> <p>stress xy</p> required <code>sigyz</code> <code>float</code> <p>stress yz</p> required <code>sigzx</code> <code>float</code> <p>stress zx</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>tuple of ndarray: (principal stresses, normalized principal directions)</p> Source code in <code>eurocodepy/utils/stress.py</code> <pre><code>def principals(sigxx: float, sigyy: float, sigzz: float,\n            sigxy: float, sigyz: float, sigzx: float) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Calculate the principal stresses and the normalized principal directions.\n\n    Author. Paulo Cachim (2022).\n\n    Args:\n        sigxx (float): stress xx\n        sigyy (float): stress yy\n        sigzz (float): stress zz\n        sigxy (float): stress xy\n        sigyz (float): stress yz\n        sigzx (float): stress zx\n\n    Returns:\n        tuple of ndarray: (principal stresses, normalized principal directions)\n\n    \"\"\"\n    eigvals, eigvecs = np.linalg.eigh(np.array([[sigxx, sigxy, sigzx],\n                    [sigxy, sigyy, sigyz],\n                    [sigzx, sigyz, sigzz]]))\n    return eigvals, eigvecs\n</code></pre>"}]}